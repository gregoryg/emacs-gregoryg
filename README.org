#+OPTIONS: ':nil *:t -:t ::t <:t H:3 \n:nil ^:t
#+OPTIONS: author:t broken-links:nil c:nil creator:nil
#+OPTIONS: d:(not "LOGBOOK") date:t e:t email:nil f:t inline:t num:nil
#+OPTIONS: p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t
#+OPTIONS: timestamp:t title:t toc:2 todo:t |:t
#+TITLE: gregoryg's Emacs Initialization in Org-Mode
#+DATE: <2019-09-08 Sun>
#+AUTHOR: Greg Grubbs
#+EMAIL: gregory.grubbs@gmail.com
#+LANGUAGE: en
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+CREATOR: Emacs 26.2 (Org mode 9.1.9)
#+setupfile: ~/projects/emacs/org-html-themes/org/theme-readtheorg-local.setup
#+property: header-args:emacs-lisp :tangle ~/.emacs.d/emacs-init.el :results none
#+property: header-args:bash :shebang #!/usr/bin/env bash :results none

* Literate Programming Config file
  This Org Mode file becomes "tangled" by the =org-babel-load-file= function in =init.el= to
  produce the entire config for my Emacs sessions on Windows, MacOS, Linux and ChromeOS

  Hip tip: to exclude entire code block sections from the resulting tangled config file,
  just add a =:tangle no= header to the source block - but do *not* use =:tangle yes= for
  that will lead to tears by interfering with =org-babel-load-file=

  If reading this file on GitHub, use the =raw= view to see all the code markings and
  header parameters.

* Should I use =evil-mode=?

  No.

* Set executable path
  #+begin_src emacs-lisp
    (when (file-exists-p "~/bin")
      (add-to-list 'exec-path "~/bin"))

    (when (file-exists-p "/usr/local/bin")
      (add-to-list 'exec-path "/usr/local/bin"))
  #+end_src

* Deal with required packages
  Explicitly include =/usr/share/emacs/site-lisp/= when using a self-compiled Emacs.
  Debian and other distros place important files from their packages in that path


  #+begin_src emacs-lisp
    (defvar gjg/check-packages-on-startup nil) ; should be nil in repo

    (add-to-list 'load-path "/usr/share/emacs/site-lisp/")
    (add-to-list 'load-path "~/emacs")
  #+end_src

  =straight.el= use-package without package.el
   + [[https://github.com/raxod502/straight.el][Next-generation, purely functional package manager using Git]]
   + [[https://shivjm.blog/switching-to-straight-el/][Switching to straight.el]]

   I moved this into =init.el= due to a compatibility package required for Org
   Initial loading for Straight.el is now in [[file:.emacs.d/init.el][init.el]]

* Greg's customizations!
** Use Emacs as app launcher (with completions)
   #+begin_src emacs-lisp
     (use-package app-launcher
       :straight '(app-launcher :host github :repo "SebastienWae/app-launcher"))
     (global-set-key (kbd "s-SPC") 'app-launcher-run-app)
   #+end_src
** Cleanup on file save
   Tip o' the hat to [[https://github.com/mitchty][@mitchty]]
   Remove trailing whitespace when saving files
    #+begin_src emacs-lisp
      ;; from https://stackoverflow.com/a/3533933/457574
      (defun delete-trailing-whitespace-except-current-line ()
        "do delete-trailing-whitespace, except preserve whitespace of current line"
        (interactive)
        (let ((current-line (buffer-substring (line-beginning-position) (line-end-position)))
              (backward (- (line-end-position) (point))))
          (delete-trailing-whitespace)
          (when (not (string-equal (buffer-substring (line-beginning-position) (line-end-position))
                                   current-line))
            (delete-region (line-beginning-position) (line-end-position))
            (insert current-line)
            (backward-char backward))))


      (add-hook 'before-save-hook 'delete-trailing-whitespace-except-current-line)
   #+end_src

   Make it executable if it should be executable!

   #+begin_src emacs-lisp
   (add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)
   #+end_src

** Emacs version things
   #+begin_src emacs-lisp :tangle /tmp/intothevoid.el
     (when (<= emacs-major-version 27)
       (remove-hook 'kill-emacs-hook #'org-babel-remove-temporary-stable-directory))
   #+end_src
** Linux things
   Fix to make Org export to HTML and open do the right thing: open in the preferred
   browser rather than just HTML in an Emacs buffer
   #+begin_src emacs-lisp
     (when (eq window-system 'x)
       (setq org-file-apps
             '((auto-mode . emacs)
               ("\\.mm\\'" . default)
               ("\\.x?html?\\'" . "/usr/bin/x-www-browser %s")
               ("\\.pdf\\'" . default))))
   #+end_src
** Fonts
   Forever in search of the One True Holy and Apostolic Programmer Font.

   Big fan of Inconsolata, Source Code Pro, and Hack.  Inability to decide on one is
   encoded herein.

   Make it a callable function so I can set new frames.  For now, do not tie it into a
   frame hook - not certain I would want it for every frame.  This would make use of the
   hook variable =after-make-frame-functions=

   #+begin_src emacs-lisp
     (defun gjg/set-frame-font ()
       "Set frame font based on window system"
       (interactive)
       (cond ((or (eq window-system 'mac) (eq window-system 'ns))
              (set-frame-font "Source Code Pro-17"))
             ((eq window-system 'w32)
              (set-face-font 'default '"-outline-Source Code Pro-normal-normal-normal-mono-17-*-*-*-c-*-iso8859-1"))
             ((eq window-system 'x)
              (set-frame-font "Hack-14")
              ;; (set-frame-font "Inconsolata-16")
              )))
     (gjg/set-frame-font)
     ;; (add-hook 'after-make-frame-functions 'gjg/set-frame-font)
     ;; (load-library "fontize")
     ;; (require 'fontize)
     (autoload 'inc-font-size "fontize" "Adjust buffer relative font size" t)
     (autoload 'dec-font-size "fontize" "Adjust buffer relative font size" t)

     (global-set-key [C-kp-subtract] 'dec-font-size)
     (global-set-key [C-kp-add] 'inc-font-size)
   #+end_src
** Basic defaults that aren't default
   So many defaults in Emacs make no sense.  If starting out with Emacs, consider these
   settings to make your first experiences nicer.

   If you have any questions about what these settings do, use Emacs to explore them:
   + If it's a variable being set (line starts with the =setq= function, set the point in
     the variable name and hit =C-h v= for help on that variable.
   + If it's a function (line starts with almost anything other than =setq=, set the point
     in the function name and hit "C-h f"

#+begin_src emacs-lisp
  ;; show parens: useful even in text modes
  (show-paren-mode 1)
  ;; fido-mode in emacs 27+: a new thing to hate
  (fido-mode -1)
  ;; When I want transient mark mode, I'll beat it out of you
  (setq transient-mark-mode nil)
  ;; (do not) display time and battery status in the mode line
  (display-time-mode 0)
  (display-battery-mode 0)
  ;; turn off that stupid toolbar
  (tool-bar-mode -1)
  ;; scroll bars?
  (scroll-bar-mode -1)
  (menu-bar-mode -1)
  ;; don't do that stoopid splash screen
  (setq inhibit-splash-screen t)

  ;; tab indents - if line is already indented, try to auto-complete
  (setq tab-always-indent 'complete)

  (setq-default indent-tabs-mode nil)
  (setq-default tab-always-indent t)
  (setq-default tab-width 4)
  ;; blink parens and similar delimiters
  (show-paren-mode 1)
  ;; ** Global identity (ie, same on all machines) - Emacs does not make good guesses here
  (setq user-full-name "Gregory Grubbs"
	user-mail-address "gregory.grubbs@gmail.com")

  (setq confirm-kill-emacs 'y-or-n-p) ;; confirm to exit emacs

  ;; dippy bird FTW - single character y-n for all yes/no question dialogs
  (fset 'yes-or-no-p 'y-or-n-p)
  (setq shell-file-name "bash")
  ;; (setq shell-command-switch "-ic") ; source .bashrc to get aliases etc
  (setq explicit-shell-file-name shell-file-name)
  (setq explicit-bash-args '("--noediting" "-i"))

  (global-hl-line-mode t) ;; highlight current line - turn off when figuring out faces

  (temp-buffer-resize-mode 1)  ;; crazy cool auto resizing of temp windows

  (setq fill-column 90); good default for wider screens - BUT this is buffer-local so should be set in mode hooks only

  ;; ensure that the default for searches is case-insensitive
  (setq case-fold-search t)

  ;; highlight/colorize everything that can be colorized!
  (global-font-lock-mode 1)

  ;; never split windows horizontally by default
  (setq split-width-threshold nil)
  ;; Here's a choice one: stay in the same column while scrolling!
  (setq scroll-preserve-screen-position t)
  ;; in Emacs23+, make line-move move by a line, ignoring wrapping
  (setq line-move-visual nil)
  ;; enable hugely useful things that are disabled by default
  (put 'narrow-to-region 'disabled nil)
  (put 'set-goal-column 'disabled nil)
  (setq narrow-to-defun-include-comments t)
  ;; echo quickly
  (setq echo-keystrokes 0.1)
  ;; keep the screen from jumping wildly as I cursor down/up
  (setq scroll-conservatively 5)
  ;; remember minibuffer history between sessions
  (savehist-mode t)
  ;; https://emacs.stackexchange.com/a/9952/418
  (use-package exec-path-from-shell :straight t)
  (exec-path-from-shell-initialize)
  (exec-path-from-shell-copy-env "HISTFILE")
  ;; if point is at end of line, keep it there for vertical movement
  (setq track-eol t)
  (setq align-to-tab-stop nil) ;; do not use tabs for align and align-regexp
  (setq Man-notify-method 'pushy) ;; show man page in current window
  (setq auth-source-save-behavior nil) ; NEVER store passwords
  (setq enable-recursive-minibuffers t)
  ;; Allow Emacs to resize mini windows, otherwise this does not work:
  ;;   (setq org-use-fast-todo-selection 'expert)
  (setq resize-mini-windows t)

#+end_src
** Custom Functions in a separate file
   TODO: pull these functions in
   #+begin_src emacs-lisp
     (add-to-list 'load-path "~/emacs")
     (load "gjg-functions")
     (require 'gjg-functions)
   #+end_src
** Key (and mouse) bindings
*** Audio and media
    #+begin_src emacs-lisp
      (bind-key (kbd "<XF86AudioLowerVolume>") (lambda () (interactive) (call-process-shell-command (expand-file-name "~/bin/pulseaudio-control-glados down"))))
      (bind-key (kbd "<XF86AudioRaiseVolume>") (lambda () (interactive) (call-process-shell-command (expand-file-name "~/bin/pulseaudio-control-glados up"))))
      (bind-key (kbd "<XF86AudioMute>") (lambda () (interactive) (call-process-shell-command (expand-file-name "~/bin/pulseaudio-control-glados togmute"))))
      (bind-key (kbd "<XF86AudioPlay>") (lambda () (interactive) (call-process-shell-command "/usr/bin/playerctl play-pause") ))
      (bind-key (kbd "<XF86AudioMute>") (lambda () (interactive) (call-process-shell-command (expand-file-name "~/bin/pulseaudio-control-glados togmute"))))
    #+end_src
*** Big blob of various key bindings
   #+begin_src emacs-lisp
     (global-set-key [home] (lambda () (interactive) (goto-char (point-min))))
     (global-set-key [end] (quote end-of-buffer))
     ;; M-left and M-right on Pixelbook
     (global-unset-key (kbd "<M-left>"))
     (global-unset-key (kbd "<M-right>"))
     (global-set-key (kbd "<M-left>") (lambda () (interactive) (goto-char (point-min))))
     (global-set-key (kbd "<M-right>") 'end-of-buffer)
     (global-unset-key (kbd "C-z"))
     (global-set-key (kbd "C-z") 'undo)
     (global-unset-key (kbd "M-]")) ; unset one next-buffer binding
     (global-unset-key (kbd "M-[")) ; unset one previous-buffer binding
     (global-set-key (kbd "s-g") 'gjg/exwm-select-or-launch-logseq)
     (global-set-key (kbd "s-y") 'gjg/exwm-select-or-launch-spotify)
     (global-set-key (kbd "s--")  'gjg/exwm-select-zoom-meeting)

     (global-set-key [f1] 'delete-other-windows)
     (global-set-key [f2] 'gjg/switch-to-other-buffer)
     (global-set-key [f3] 'gjg/other-window-or-split)
     (global-set-key [f4] 'narrow-to-defun)

     (global-set-key [f5] 'gjg/widen-ask-if-indirect)
     ;; (global-set-key [f6] 'read-only-mode)
     (global-set-key [f6] 'gjg/open-work-agenda)
     (global-set-key [f7] 'hl-line-mode) ;; toggle hl-line-mode for this window only
     ;; (global-set-key [f8] 'bury-buffer)

     (global-set-key [f9] 'bury-buffer)
     (global-set-key [f10] 'dired-omit-mode)
     ;; (global-set-key [f11] 'mac-toggle-max-window)
     (global-set-key [f11] 'gjg/toggle-max-frame)
     (global-set-key [M-f11] 'gjg/toggle-max-frame)
     ;; (global-set-key [f11] 'toggle-fullscreen)
     ;; (global-set-key [f11] 'switch-full-screen)
     ;; (global-set-key (kbd "C-<f11>") 'gjg/emacs-max-coolness)
     (global-set-key [f12] (lambda () (interactive) (message (or (buffer-file-name) "No file associated with this buffer."))))
     (global-set-key (kbd "<C-f12>") 'yow)
     (global-set-key [C-wheel-up] 'text-scale-increase)
     (global-set-key [C-wheel-down] 'text-scale-decrease)
     (global-set-key [S-wheel-up] 'inc-font-size)
     (global-set-key [S-wheel-down] 'dec-font-size)
     (global-set-key (kbd "M-]") 'next-buffer)
     (global-set-key (kbd "M-[") 'previous-buffer)
     (global-set-key (kbd "C-c C-v") 'browse-url-at-point)
     (defalias 'ss 'gjg/open-remote-shell)
     (defalias 'ht 'gjg/highlight-terraform-stuff)
     (defalias 'rb 'rename-buffer)

   #+end_src
*** Mouse actions
    I accidentally hit these mouse combos working on the laptop - disable 'em all!
    #+begin_src emacs-lisp
      (global-unset-key (kbd"C-<down-mouse-1>")) ;; mouse-buffer-menu
      (global-unset-key (kbd"C-<down-mouse-2>")) ;; facemenu-menu
      (global-unset-key (kbd"S-<down-mouse-1>")) ;; mouse-appearance-menu
    #+end_src
** Backup files
   #+begin_src emacs-lisp
     ;; backup files
     (setq
      backup-by-copying t      ; don't clobber symlinks
      backup-directory-alist
      '(("." . "~/.emacs.d/backups"))    ; don't litter my fs tree
      delete-old-versions t
      kept-new-versions 5
      kept-old-versions 5
      version-control nil)
   #+end_src


** Automatic typing - abbrevs and expansions
   #+begin_src emacs-lisp :tangle /tmp/intothevoid.el
;; Dynamic abbrevs should expand both words and symbols
(setq dabbrev-abbrev-char-regexp "\\sw\\|\\s_")
;; and now set up hippie-expand
(global-set-key (kbd "M-/") 'hippie-expand)

   #+end_src
** Games and silliness
   #+begin_src emacs-lisp
     ;; very important: keep a long list of yow lines
     ;;   in emacs 24.4 yow.el is obsolete; use cookie instead
     (when (featurep 'yow)
       (unload-feature 'yow))
     ;; (with-eval-after-load 'cookie
     (defun yow ()
       (interactive)
       (let ((suggest-key-bindings nil))
         (message (cookie gjg/yow-file nil nil))))
     ;; )
     ;; almost as important: keep track of those tetris scores
     (setq tetris-score-file "~/.emacs.d/tetris.score")


   #+end_src
** Multimedia
   #+begin_src emacs-lisp
     (use-package playerctl :straight t)
   #+end_src
** Weird random rarely used maybe interesting things
** Rainbow delimiters
   #+begin_src emacs-lisp
     (use-package rainbow-delimiters :straight t)
   #+end_src
* Encryption
  =epa-file= is a built-in

  Set value of =epg-gpg-program= to location on local system
  #+begin_src emacs-lisp
;; let's get encryption established
;; For gpg, disable external pinentry - let emacs handle pass phrase
;; (setenv "GPG_AGENT_INFO" nil)
(require 'epa-file)
;; (custom-set-variables '(epg-gpg-program  "/usr/local/bin/gpg"))
(epa-file-enable)
(setq epg-pinentry-mode 'loopback)
(require 'org-crypt)
(org-crypt-use-before-save-magic)

  #+end_src
* Window/buffer management
** GJG full screen, movement, transparency
   TODO: figure out global Super key chords in exwm map vs global key map
   #+begin_src emacs-lisp
     ;; unbind some keys in favor of my functions bound to SUPER- combinations
     ;; the existing keys will work in Emacs buffers, but not in EXWM X buffers; the SUPER combos work everywhere
     (global-unset-key (kbd "M-]")) ; next-buffer
     (global-unset-key (kbd "M-[")) ; previous-buffer

     (defun revert-dammit () ; revert buffer without prompting
       (interactive)
       ;; revert buffer, don't use auto-save, preserve modes
       (revert-buffer t t t))
     (defalias 'rd 'revert-dammit)
     (defun gjg/switch-to-other-buffer ()
       (interactive)
       (switch-to-buffer (other-buffer))
       (message "Switched to other-buffer"))
     (defun gjg/split-window-below ()
       "Split window below, switch to the new window AND switch buffer in that window"
       (interactive)
       (split-window-below)
       (other-window 1)
       (switch-to-buffer (other-buffer)))
     (defun gjg/split-window-right ()
       "Split window right, switch to the new window AND switch buffer in that window"
       (interactive)
       (split-window-right)
       (other-window 1)
       (switch-to-buffer (other-buffer)))
     (bind-key "C-x 2" 'gjg/split-window-below)
     (bind-key "C-x 3" 'gjg/split-window-right)

     (use-package ace-window
       :straight t
       :config
       (custom-set-faces
        '(aw-leading-char-face
          ((t (:foreground "deep sky blue" :height 5.0)))
          ))
       :bind
        (("C-x o" . ace-window)))
     ;; (require 'ace-window)
     ;; (custom-set-faces
     ;;  '(aw-leading-char-face
     ;;    ((t (:foreground "deep sky blue" :height 5.0)))))
     ;; (bind-key "C-x o" 'ace-window)
     ;; (setq winum-keymap
     ;;       (let ((map (make-sparse-keymap)))
     ;;         (define-key map (kbd "C-`") 'winum-select-window-by-number)
     ;;         (define-key map (kbd "M-0") 'winum-select-window-0)
     ;;         (define-key map (kbd "M-1") 'winum-select-window-1)
     ;;         (define-key map (kbd "M-2") 'winum-select-window-2)
     ;;         (define-key map (kbd "M-3") 'winum-select-window-3)
     ;;         (define-key map (kbd "M-4") 'winum-select-window-4)
     ;;         (define-key map (kbd "M-5") 'winum-select-window-5)
     ;;         )
     ;;       )
     (use-package winum
       :straight t
       :config
       (setq winum-scope                       'frame-local
             winum-auto-assign-0-to-minibuffer nil
             winum-auto-setup-mode-line        t))
     (winum-mode)
     (set-face-attribute 'winum-face nil :weight 'bold)
     (defun gjg/other-window-with-winum ()
       "if 2 windows, jump to other-window.  Elsecase use winum"
       (interactive)
       (cond ((= 1 winum--window-count)
              (gjg/switch-to-other-buffer))
             ((= 2 winum--window-count)
              (other-window 1))
             ((> 10 winum--window-count)
              ;; jump immediately to window
              ;; (let ((jwin (read-number (format "Jump to window num[1-%d]: " winum--window-count))))
              (let ((jwin (string-to-number (char-to-string (read-char (format "Jump to window num[1-%d]: " winum--window-count))))))
                (message "Jumping to %d" jwin)
                (winum-select-window-by-number jwin)))
             (t
              (let ((jwin (read-number (format "Jump to window num[1-%d]: " winum--window-count))))
                (message "Jumping to %d" jwin)
                (winum-select-window-by-number jwin)))
              ))
     (bind-key "C-x o" 'gjg/other-window-with-winum)
     (bind-key "s-a" 'gjg/open-work-agenda)
     (bind-key "s-o" 'gjg/other-window-with-winum)
     (bind-key "s-b" 'gjg/switch-to-other-buffer)
     (bind-key "s-<up>" 'windmove-up)
     (bind-key "s-<down>" 'windmove-down)
     (bind-key "s-<right>" 'windmove-right)
     (bind-key "s-<left>" 'windmove-left)

     (bind-key "s-0" 'delete-window)
     (bind-key "s-1" 'delete-other-windows)
     (bind-key "s-2" 'gjg/split-window-below)
     (bind-key "s-3" 'gjg/split-window-right)
     (bind-key "M-s-<up>" 'windmove-delete-up)
     (bind-key "M-s-<down>" 'windmove-delete-down)
     (bind-key "M-s-<left>" 'windmove-delete-left)
     (bind-key "M-s-<right>" 'windmove-delete-right)
     (bind-key "s-p" 'playerctl-play-pause-song)
     (bind-key "s-q" 'bury-buffer)
     (bind-key "s-t" 'toggle-truncate-lines)
     (bind-key "s-y" 'gjg/exwm-select-or-launch-spotify)
     (bind-key "s-c" #'(lambda () (interactive) (call-process-shell-command "invert-color.sh")))
     (bind-key "s-." #'(lambda () (interactive) (find-file "~/emacs-gregoryg/README.org")))
     (bind-key "s-," 'gjg/polybar-start-or-toggle)
     (bind-key "s-]" 'ded/org-show-next-heading-tidily)
     (bind-key "s-[" 'ded/org-show-previous-heading-tidily)
     (bind-key "M-SPC" #'(lambda () (interactive) (call-process-shell-command "rofi -modi drun,run -show drun")))
     (bind-key "s-\\" 'switch-to-buffer)
     ;; (Set-face-attribute 'winum-face nil :foreground "deep sky blue")
     (defun gjg/widen-ask-if-indirect ()
       "If buffer is indirect, ask before widening"
       (interactive)
       (if (buffer-base-buffer)
           (when (yes-or-no-p "Buffer is indirect; really widen? ")
         (widen))
         (widen)))
     (defun toggle-transparency (alpha-level)
       (interactive "p")
       (message (format "%s" alpha-level))
       (if (< alpha-level 50) (setq alpha-level 85))
       (let ((myalpha (frame-parameter nil 'alpha)))
         (if (or (not myalpha)
                 (= myalpha 100))
         (set-frame-parameter nil 'alpha alpha-level)
           (set-frame-parameter nil 'alpha 100))
         )
       (message (format "Alpha level is %d" (frame-parameter nil 'alpha)))
       )

     (defun set-transparency (alpha-level)
       (interactive "p")
       (message (format "Alpha level passed in: %s" alpha-level))
       (let ((alpha-level (if (< alpha-level 2)
                  (read-number "Opacity percentage: " 85)
                    alpha-level))
         (myalpha (frame-parameter nil 'alpha)))
         (set-frame-parameter nil 'alpha alpha-level))
       (message (format "Alpha level is %d" (frame-parameter nil 'alpha))))
     (defalias 'set-opacity 'set-transparency )

     (defun toggle-window-split ()
       (interactive)
       (if (= (count-windows) 2)
           (let* ((this-win-buffer (window-buffer))
              (next-win-buffer (window-buffer (next-window)))
              (this-win-edges (window-edges (selected-window)))
              (next-win-edges (window-edges (next-window)))
              (this-win-2nd (not (and (<= (car this-win-edges)
                          (car next-win-edges))
                          (<= (cadr this-win-edges)
                          (cadr next-win-edges)))))
              (splitter
               (if (= (car this-win-edges)
                  (car (window-edges (next-window))))
               'split-window-horizontally
             'split-window-vertically)))
         (delete-other-windows)
         (let ((first-win (selected-window)))
           (funcall splitter)
           (if this-win-2nd (other-window 1))
           (set-window-buffer (selected-window) this-win-buffer)
           (set-window-buffer (next-window) next-win-buffer)
           (select-window first-win)
           (if this-win-2nd (other-window 1))))))

     (define-key ctl-x-4-map "t" 'toggle-window-split)
     ;; *** Full-screen frame defuns

     (defun switch-full-screen ()
       (interactive)
       (shell-command (concat "/usr/bin/wmctrl -i -r " (frame-parameter nil 'outer-window-id) " -btoggle,fullscreen")))

     ;; (defun toggle-fullscreen ()
     ;;   "toggles whether the currently selected frame consumes the entire display or is decorated with a window border"
     ;;   (interactive)
     ;;   (let ((f (selected-frame)))
     ;;     (modify-frame-parameters f `((fullscreen . ,(if (eq nil (frame-parameter f 'fullscreen)) 'fullboth nil))))))

     ;; (defun mac-toggle-max-window ()
     ;;   "Toggle full-screen frame on Linux and OS X - use maxframe.el for Windows"
     ;;   (interactive)
     ;;   (if (frame-parameter nil 'fullscreen)
     ;;       (set-frame-parameter nil 'fullscreen nil)
     ;;     (set-frame-parameter nil 'fullscreen 'fullboth)))
     ;; (defun toggle-full-screen ()
     ;;   "Toggle between full screen and partial screen display on X11;
     ;;     courtesy of http://www.emacswiki.org/cgi-bin/wiki/FullScreen"
     ;;   (interactive)
     ;;   (x-send-client-message nil 0 nil "_NET_WM_STATE" 32
     ;;                          '(2 "_NET_WM_STATE_FULLSCREEN" 0)))


     ;; ;; add toggle for maxframe.el (works on Windows)
     (when (eq window-system 'w32)
       (require 'maxframe)
       (modify-frame-parameters nil '((gjg/frame-maxp . nil))))
     ;; (modify-frame-parameters nil '((gjg/frame-maxp . nil)))
     ;; ;; (defvar gjg/frame-maxp nil "Store whether frame is maximized using maxframe.el")
     (defun gjg/switch-buffer-by-mode ()
       "Switch to a buffer after choosing a mode."
       (interactive)
       (let* ((active-buffers-with-mode (mapcar #'(lambda (x) (with-current-buffer x (cons (buffer-name) (symbol-name major-mode)))) (buffer-list)))
          (distinct-modes (-distinct (mapcar #'cdr active-buffers-with-mode)))
          (selected-mode (ido-completing-read "Mode: " distinct-modes))
          (candidate-buffers (mapcar #'car (cl-remove-if-not '(lambda (x) (string-equal selected-mode (cdr x))) active-buffers-with-mode)))
          (selected-buffer (ido-completing-read "Buffer: " candidate-buffers)))
         (switch-to-buffer selected-buffer)))

     (defun gjg/max-frame ()
       "Maximize the current frame and toggle gjg/frame-maxp"
       (interactive)
       (cond ((eq window-system 'w32)
          (maximize-frame))
         ((eq window-system 'x)
          (switch-full-screen))
         (t
          (mac-toggle-max-window)))
       (modify-frame-parameters nil '((gjg/frame-maxp . t))))

     (defun gjg/restore-frame ()
       "Restore the current frame to its previous size and toggle gjg/frame-maxp"
       (interactive)
       (cond ((eq window-system 'w32)
          (restore-frame))
         ((eq window-system 'x)
          (switch-full-screen))
         (t
          (mac-toggle-max-window)))
       (modify-frame-parameters nil '((gjg/frame-maxp . nil))))

     (defun gjg/toggle-max-frame ()
       "Check the status of gjg/max-framep and change to whichever mode we're not in now."
       (interactive)
       (cond ((eq window-system 'ns)
          (toggle-frame-maximized))
         (t
          (if (eq (frame-parameter nil 'gjg/frame-maxp) nil) (gjg/max-frame) (gjg/restore-frame)))))

   #+end_src
** Winner-mode and Windmove
  winner-mode is a built-in

  #+begin_src emacs-lisp
    ;; winner
    (require 'winner)
    (winner-mode 1)
    ;; windmove
    ;; (windmove-default-keybindings)
    ;; (with-eval-after-load 'windmove
    ;;   (windmove-default-keybindings)
    ;;   ;; Make windmove work in org-mode:
    ;;   (setq org-replace-disputed-keys t))
    ;; (add-hook 'org-shiftup-final-hook 'windmove-up)
    ;; (add-hook 'org-shiftleft-final-hook 'windmove-left)
    ;; (add-hook 'org-shiftdown-final-hook 'windmove-down)
    ;; (add-hook 'org-shiftright-final-hook 'windmove-right)))

    ;; Add advice to stop hangs on EXWM
    ;; The problem happens with floating windows that disappear - like open file dialog or a Zoom dialog when starting a meeting
    ;; The solution is to assure all frames in winner-modified-list pass the frame-live-p test
    (defun gjg/winner-clean-up-modified-list ()
      "Remove dead frames from `winner-modified-list`"
      (dolist (frame winner-modified-list)
        (unless (frame-live-p frame)
          (delete frame winner-modified-list))))
    (advice-add 'winner-save-old-configurations :before #'gjg/winner-clean-up-modified-list)
  #+end_src
** Ibuffer FTW
*** View customizations
    #+begin_src emacs-lisp
      (setq ibuffer-formats
            '((mark modified read-only locked " "
                    (name 50 50 :left :elide)  ; much wider buffer name column
                    " "
                    (size 9 -1 :right)
                    " "
                    (mode 16 16 :left :elide)
                    " " filename-and-process)
              (mark " "
                    (name 16 -1)
                    " " filename))
            )
    #+end_src
*** Filter groups
   Saved filter groups provide a nice organization.

   #+begin_src emacs-lisp
     (require 'ibuffer)
     (global-set-key (kbd "C-x C-b") (lambda () (interactive) (ibuffer)))
     (setq ibuffer-expert t)
     (setq ibuffer-default-sorting-mode 'alphabetic)
     (setq ibuffer-saved-filter-groups
           '(("home"
              ("Org and Markdown" (or (mode . org-mode)
                                      (mode . org-agenda-mode)
                                      (mode . markdown-mode)))
              ("Shells" (or (mode . shell-mode)
                            (mode . eshell-mode)))
              ("EXWM X Apps" (mode . exwm-mode))
              ("Configs" (or (derived-mode .  conf-mode)
                             (mode . yaml-mode)
                             (mode . json-mode)))
              ("Code" (derived-mode .  prog-mode))
              ("Magit" (or (mode . magit-diff-mode)
                           (mode . magit-status-mode)
                           (mode . magit-process-mode)
                           (mode . magit-revision-mode)
                           (mode . magit-refs-mode)))
              ("Dired" (mode . dired-mode))
              ("Tramp sessions" (name . "\*tramp.+"))
              ;; ("Remote" (filename . "\/.+:.+"))
              )))
     (add-hook 'ibuffer-mode-hook
               #'(lambda ()
                  (ibuffer-auto-mode 1)
                  (auto-revert-mode 1)
                  (ibuffer-switch-to-saved-filter-groups "home")))
   #+end_src
*** Preview buffer in side window
    Preview without selecting the window - stay on current line in Ibuffer

    This function should work just like =occur-mode-display-occurence= in =replace.el=
   #+begin_src emacs-lisp
     (defun gjg/ibuffer-only-exwm ()
       (interactive)
       (ibuffer nil "*EXWM Thang*" '((used-mode . exwm-mode)))
       (gjg/ibuffer-preview))
     (global-set-key (kbd "s-e") 'gjg/ibuffer-only-exwm)
     (defun gjg/ibuffer-preview ()
       "View the current file in other window but to do select"
       (interactive)
       (delete-other-windows)
       (when (not (window-parent)) ;; only one window, so split
         (split-window nil nil 'right))
       (let ((buf (ibuffer-current-buffer t)))
         (display-buffer buf '((display-buffer-use-some-window
                                display-buffer-pop-up-window)
                               (inhibit-same-window . t))))
       :refresh-p nil)

     (define-key ibuffer-mode-map (kbd "SPC") 'gjg/ibuffer-preview)
   #+end_src

** Uniquify
   #+begin_src emacs-lisp
     (autoload 'uniquify "uniquify" "unique buffer names dependent on file name")
     (with-eval-after-load 'uniquify
       (setq uniquify-buffer-name-style 'reverse)
       (setq uniquify-separator "/")
       (setq uniquify-after-kill-buffer-p t)
       (setq uniquify-ignore-buffers-re "^\\*"))
   #+end_src
** Themes
*** Modus themes
    I want to soften the contrasts in dark mode - default is white on black.  But
    changing the background too light throws off readability of some things - notably the
    deliimters when using =rainbow-delimiters-mode=.  So without going down the rabbit
    hole to modify all the rainbow-delimiters faces, I'm just nudging the background and
    foreground colors very slightly.
    #+begin_src emacs-lisp
      ;; make the modus themes act more like my brutalist theme in Org
      (use-package modus-themes
        :straight t
        :config
        (setq modus-themes-headings
              '((1 . ( semibold 1.3))
                (2 . ( semibold 1.1))
                (3 . ( semibold 1.1))
                (4 . ( semibold 1.1))
                (5 . ( semibold 1.1))
                (6 . ( semibold 1.1)))
              modus-themes-syntax '(faint alt-syntax)
              modus-themes-org-blocks nil
              modus-themes-org-agenda
              '((header-block . (1.3))
                (header-date . (bold-today 1.2))
                (habit . simplified)
                )
              modus-themes-org-blocks nil
              modus-themes-vivendi-color-overrides
              '((bg-main . "gray10")
                (fg-main . "gray90")
                (bg-hl-line . "gray15")
                )))

    #+end_src
*** Load default theme
    Deferred here until all theme tweaks have been applied
    #+begin_src emacs-lisp
      (if (>  (nth 2 (decode-time )) 16)
          (gjg/go-dark)
        (gjg/go-light))
    #+end_src
** Make things open up in current window
   There's a standard way to force niceness from packages that open buffers in random
   windows just to be annoying.  Here's where those packages are corralled
   #+begin_src emacs-lisp
     ;; Org capture
     (add-to-list 'display-buffer-alist '("^\\*Capture\\*" display-buffer-reuse-window display-buffer-same-window))
     ;; R
     (add-to-list 'display-buffer-alist '("^\\*R" display-buffer-same-window))
     ;; Helpful
     (add-to-list 'display-buffer-alist '("^\\*helpful" display-buffer-same-window))
     ;; Change behavior of Magit status (status only, not magit-diff, magit-process etc)
     (add-to-list 'display-buffer-alist '("^magit:" display-buffer-same-window))
     ;; All interactive SQL modes
     (add-to-list 'display-buffer-alist
                  '((lambda (buffer action)
                      (with-current-buffer buffer
                        (derived-mode-p 'sql-interactive-mode)))
                    display-buffer-same-window))
   #+end_src
* EXWM : The Emacs X Window Manager
   This crazy idea is better than I thought it could be!

   This section is only useable on Linux - or Unix presumably - with X Window System
   running but no window manager.  An entire window manager has been written in Emacs
   Lisp - the fundamental package that exercises the X11 APIs is called =xelb= - its GitHub
   repository is [[https://github.com/ch11ng/xelb][here]] - also available on GNU ELPA.

   The package built atop that to provide a usable window manager is EXWM - Emacs X Window
   Manager - GitHub repo [[https://github.com/ch11ng/exwm][here]]

   EXWM is primarily a tiling window manager, but it supports floating windows as well -
   very nice for transient dialogs.  You have control to take an application window and
   change it to a floating window, along with the ability to move and resize it.

   EXWM supports workspaces, which here is an abstraction based on Emacs frames.  The only
   time I use workspaces in EXWM is when I have 2 or more monitors, where I place one
   workspace per display.

   #+begin_src emacs-lisp
     (use-package exwm :straight t)
   #+end_src
** Patches and egregious hacks
   There is currently [2022-10-17 Mon] *NO* real maintainer of the EXWM repo - @ch11ng has
   disappeared.  This section will attempt to implement patches known to fix current bugs
   until such time as existing PRs start getting merged
*** Fix frame focus for Emacs 29+
    PR is [[https://github.com/ch11ng/exwm/pull/890][ch11ng/exwm#890 Fix frame focus for Emacs 29 by mgi]]
    Discussion on mailing list [[https://debbugs.gnu.org/cgi/bugreport.cgi?bug=58438][#58438 - 29.0.50; EXWM focus lost - GNU bug report logs]]
    Use the patch in below function - compare with exwm.el =exwm--on-ClientMessage=
    #+begin_src emacs-lisp
      (defun exwm--on-ClientMessage (raw-data _synthetic)
        "Handle ClientMessage event."
        (let ((obj (make-instance 'xcb:ClientMessage))
              type id data)
          (xcb:unmarshal obj raw-data)
          (setq type (slot-value obj 'type)
                id (slot-value obj 'window)
                data (slot-value (slot-value obj 'data) 'data32))
          (exwm--log "atom=%s(%s)" (x-get-atom-name type exwm-workspace--current)
                     type)
          (cond
           ;; _NET_NUMBER_OF_DESKTOPS.
           ((= type xcb:Atom:_NET_NUMBER_OF_DESKTOPS)
            (let ((current (exwm-workspace--count))
                  (requested (elt data 0)))
              ;; Only allow increasing/decreasing the workspace number by 1.
              (cond
               ((< current requested)
                (make-frame))
               ((and (> current requested)
                     (> current 1))
                (let ((frame (car (last exwm-workspace--list))))
                  (exwm-workspace--get-remove-frame-next-workspace frame)
                  (delete-frame frame))))))
           ;; _NET_CURRENT_DESKTOP.
           ((= type xcb:Atom:_NET_CURRENT_DESKTOP)
            (exwm-workspace-switch (elt data 0)))
           ;; _NET_ACTIVE_WINDOW.
           ((= type xcb:Atom:_NET_ACTIVE_WINDOW)
            (dolist (f exwm-workspace--list)
              (when (eq id (frame-parameter f 'exwm-outer-id))
                (x-focus-frame f t)))
            (let ((buffer (exwm--id->buffer id))
                  iconic window)
              (when (buffer-live-p buffer)
                (with-current-buffer buffer
                  (when (eq exwm--frame exwm-workspace--current)
                    (if exwm--floating-frame
                        (select-frame exwm--floating-frame)
                      (setq iconic (exwm-layout--iconic-state-p))
                      (when iconic
                        ;; State change: iconic => normal.
                        (set-window-buffer (frame-selected-window exwm--frame)
                                           (current-buffer)))
                      ;; Focus transfer.
                      (setq window (get-buffer-window nil t))
                      (when (or iconic
                                (not (eq window (selected-window))))
                        (select-window window))))))))
           ;; _NET_CLOSE_WINDOW.
           ((= type xcb:Atom:_NET_CLOSE_WINDOW)
            (let ((buffer (exwm--id->buffer id)))
              (when (buffer-live-p buffer)
                (exwm--defer 0 #'kill-buffer buffer))))
           ;; _NET_WM_MOVERESIZE
           ((= type xcb:Atom:_NET_WM_MOVERESIZE)
            (let ((direction (elt data 2))
                  (buffer (exwm--id->buffer id)))
              (unless (and buffer
                           (not (buffer-local-value 'exwm--floating-frame buffer)))
                (cond ((= direction
                          xcb:ewmh:_NET_WM_MOVERESIZE_SIZE_KEYBOARD)
                       ;; FIXME
                       )
                      ((= direction
                          xcb:ewmh:_NET_WM_MOVERESIZE_MOVE_KEYBOARD)
                       ;; FIXME
                       )
                      ((= direction xcb:ewmh:_NET_WM_MOVERESIZE_CANCEL)
                       (exwm-floating--stop-moveresize))
                      ;; In case it's a workspace frame.
                      ((and (not buffer)
                            (catch 'break
                              (dolist (f exwm-workspace--list)
                                (when (or (eq id (frame-parameter f 'exwm-outer-id))
                                          (eq id (frame-parameter f 'exwm-id)))
                                  (throw 'break t)))
                              nil)))
                      (t
                       ;; In case it's a floating frame,
                       ;; move the corresponding X window instead.
                       (unless buffer
                         (catch 'break
                           (dolist (pair exwm--id-buffer-alist)
                             (with-current-buffer (cdr pair)
                               (when
                                   (and exwm--floating-frame
                                        (or (eq id
                                                (frame-parameter exwm--floating-frame
                                                                 'exwm-outer-id))
                                            (eq id
                                                (frame-parameter exwm--floating-frame
                                                                 'exwm-id))))
                                 (setq id exwm--id)
                                 (throw 'break nil))))))
                       ;; Start to move it.
                       (exwm-floating--start-moveresize id direction))))))
           ;; _NET_REQUEST_FRAME_EXTENTS
           ((= type xcb:Atom:_NET_REQUEST_FRAME_EXTENTS)
            (let ((buffer (exwm--id->buffer id))
                  top btm)
              (if (or (not buffer)
                      (not (buffer-local-value 'exwm--floating-frame buffer)))
                  (setq top 0
                        btm 0)
                (setq top (window-header-line-height)
                      btm (window-mode-line-height)))
              (xcb:+request exwm--connection
                  (make-instance 'xcb:ewmh:set-_NET_FRAME_EXTENTS
                                 :window id
                                 :left 0
                                 :right 0
                                 :top top
                                 :bottom btm)))
            (xcb:flush exwm--connection))
           ;; _NET_WM_DESKTOP.
           ((= type xcb:Atom:_NET_WM_DESKTOP)
            (let ((buffer (exwm--id->buffer id)))
              (when (buffer-live-p buffer)
                (exwm-workspace-move-window (elt data 0) id))))
           ;; _NET_WM_STATE
           ((= type xcb:Atom:_NET_WM_STATE)
            (let ((action (elt data 0))
                  (props (list (elt data 1) (elt data 2)))
                  (buffer (exwm--id->buffer id))
                  props-new)
              ;; only support _NET_WM_STATE_FULLSCREEN / _NET_WM_STATE_ADD for frames
              (when (and (not buffer)
                         (memq xcb:Atom:_NET_WM_STATE_FULLSCREEN props)
                         (= action xcb:ewmh:_NET_WM_STATE_ADD))
                (xcb:+request
                    exwm--connection
                    (make-instance 'xcb:ewmh:set-_NET_WM_STATE
                                   :window id
                                   :data (vector xcb:Atom:_NET_WM_STATE_FULLSCREEN)))
                (xcb:flush exwm--connection))
              (when buffer                    ;ensure it's managed
                (with-current-buffer buffer
                  ;; _NET_WM_STATE_FULLSCREEN
                  (when (or (memq xcb:Atom:_NET_WM_STATE_FULLSCREEN props)
                            (memq xcb:Atom:_NET_WM_STATE_ABOVE props))
                    (cond ((= action xcb:ewmh:_NET_WM_STATE_ADD)
                           (unless (exwm-layout--fullscreen-p)
                             (exwm-layout-set-fullscreen id))
                           (push xcb:Atom:_NET_WM_STATE_FULLSCREEN props-new))
                          ((= action xcb:ewmh:_NET_WM_STATE_REMOVE)
                           (when (exwm-layout--fullscreen-p)
                             (exwm-layout-unset-fullscreen id)))
                          ((= action xcb:ewmh:_NET_WM_STATE_TOGGLE)
                           (if (exwm-layout--fullscreen-p)
                               (exwm-layout-unset-fullscreen id)
                             (exwm-layout-set-fullscreen id)
                             (push xcb:Atom:_NET_WM_STATE_FULLSCREEN props-new)))))
                  ;; _NET_WM_STATE_DEMANDS_ATTENTION
                  ;; FIXME: check (may require other properties set)
                  (when (memq xcb:Atom:_NET_WM_STATE_DEMANDS_ATTENTION props)
                    (when (= action xcb:ewmh:_NET_WM_STATE_ADD)
                      (unless (eq exwm--frame exwm-workspace--current)
                        (set-frame-parameter exwm--frame 'exwm-urgency t)
                        (setq exwm-workspace--switch-history-outdated t)))
                    ;; xcb:ewmh:_NET_WM_STATE_REMOVE?
                    ;; xcb:ewmh:_NET_WM_STATE_TOGGLE?
                    )
                  (xcb:+request exwm--connection
                      (make-instance 'xcb:ewmh:set-_NET_WM_STATE
                                     :window id :data (vconcat props-new)))
                  (xcb:flush exwm--connection)))))
           ((= type xcb:Atom:WM_PROTOCOLS)
            (let ((type (elt data 0)))
              (cond ((= type xcb:Atom:_NET_WM_PING)
                     (setq exwm-manage--ping-lock nil))
                    (t (exwm--log "Unhandled WM_PROTOCOLS of type: %d" type)))))
           ((= type xcb:Atom:WM_CHANGE_STATE)
            (let ((buffer (exwm--id->buffer id)))
              (when (and (buffer-live-p buffer)
                         (= (elt data 0) xcb:icccm:WM_STATE:IconicState))
                (with-current-buffer buffer
                  (if exwm--floating-frame
                      (call-interactively #'exwm-floating-hide)
                    (bury-buffer))))))
           (t
            (exwm--log "Unhandled: %s(%d)"
                       (x-get-atom-name type exwm-workspace--current) type)))))
    #+end_src

** Warning about use with =winner-mode=
   I struggled with hangs in EXWM that I of course attributed to EXWM
   or XELB.  The typical reproducible action was to initiate a floating dialog in an X11
   application such as Zoom, or the Open File dialog from a web browser (for example).
   Depending on the timing, I would see a message in Emacs similar to
   #+begin_example
     Error in post-command-hook (winner-save-old-configurations): (wrong-type-argument frame-live-p #<dead frame Open File 0x558a5304a578>)
   #+end_example

   The problem is a failure to check for dead frames before saving window configurations.
   The solution I use is to add advice before one function that removes dead frames from
   the list of frames.

   #+begin_src emacs-lisp :tangle no
     ;; Add advice to stop hangs on EXWM
     ;; The problem happens with floating windows that disappear - like open file dialog or a Zoom dialog when starting a meeting
     ;; The solution is to assure all frames in winner-modified-list pass the frame-live-p test
     (defun gjg/winner-clean-up-modified-list ()
       "Remove dead frames from `winner-modified-list`"
       (dolist (frame winner-modified-list)
         (unless (frame-live-p frame)
           (delete frame winner-modified-list))))
     (advice-add 'winner-save-old-configurations :before #'gjg/winner-clean-up-modified-list)

   #+end_src
** Recommended changes to workflow when using a tiling window manager
*** Web browser should open new windows rather than tabs
    Doing this allows Emacs to search window/tab titles.  It's a weird change at first,
    but it's a much better experience in a tiling window manager that has good search.

    In Firefox, you can go to =about:preferences=.  Under the *Tabs*, uncheck =Open links
    in tabs instead of new windows=

    If you want to make a radical change, find an extension for your web browser that
    disallows tabs altogether - so even when you explicitly ask to open a new tab, the
    extension makes it a new window.
*** Scripts will be required to handle operations normally managed by Desktop Environment
    I have moved all the generated scripts and configs I use to support EXWM - and
    theoretically any other tiling window manager - to [[file:Desktop.org][this Org file]].  I use that Org file to
    generate (tangle) everything I need in a Linux environment.

*** Launching applications without a Desktop Environment
    EXWM default config suggests a handy shell launch command from Emacs, but I prefer to
    use exactly what I do on every other OS - a pop-up app launcher such as [[https://github.com/albertlauncher/albert][Albert]] or ulauncher.

** Unresolved problems
*** TODO Fix clipboard integration / behavior
    + The problem is consistent cut/paste copy/yank behavior between Emacs windows and
      managed X windows.

      + Copy text in Emacs -> paste to Firefox works in =char= mode

      + Copy text in Emacs -> paste to Firefox in =line= mode no worky - have to use right
        mouse click or =S-<insert>  *how to define simulation key??*

      + Copy text in Firefox =char= mode -> yank in Emacs works

      + Copy text in Firefox =line= mode using =M-w= -> yank in Emacs works


** System tray widgets
   EXWM has a system tray that can be enabled, and some panel widgets work with it.  For
   me, I'd rather either use pure Emacs or Linux shell methods of getting info and setting
   values, *or* just go ahead and use a "proper" panel.

    I have found that both =xfce4-panel= and the LXDE panel work a treat!  For
    =xfce4-panel= do *not* check =Don't reserve space on borders= - that way the panel
    will not obscure the echo area at the very bottom of the screen

    One can either bring up Emacs with no DE and then run the panels as processes, or
    hijack the default window manager in one of the lightweight DEs.

*** Useful panel widgets
      + [[https://docs.xfce.org/panel-plugins/clipman/start][xfce4-clipman - a clipboard manager]]
      + parcellite - a different clipboard manager
      + /usr/bin/python3 /usr/share/system-config-printer/applet.py - printer notifications
      + nm-applet --indicator  - NetworkManager applet - absolutely needed
      + /usr/lib/blueberry/blueberry-tray.py - a Blueberry setup app triggered from the panel
      + /usr/bin/python3 /usr/bin/blueman-applet - a *nicer* bluetooth applet with setup
        and file transfer

** Panel with Polybar

   Polybar is a highly  customizable alternative to the XFCE Panel

   Check out the Polybar wiki for more details on how to configure it: https://github.com/polybar/polybar/wiki

   + [[https://awesomeopensource.com/projects/polybar][The Top 422 Polybar Open Source Projects on Github]]


*** Integration with =emacsclient=

   Polybar provides a great, minimalistic panel for your EXWM desktop configuration.  The
   following config integrates =emacsclient= and Polybar with =polybar-msg= to enable you
   to gather *any* information from Emacs and display it in the panel!

   Functions are defined in [[file:gjg-functions.org::*Polybar for use with Linux EXWM and desktop environments][Polybar for use with Linux EXWM and desktop environments]]

*** Panel configuration
    Configurations and script for Polybar are kept in gregoryg/homelab/README-dotfiles

*** Helpful Polybar scripts
**** hideIt.sh - hide *any* X window - we will use it just for polybar
     Polybar - remarkably and shockingly - does not have an autohide feature (I believe).

     So there is a clever script called [[https://raw.githubusercontent.com/Tadly/hideIt.sh/master/hideIt.sh][hideIt.sh]] - which will actually work for any X window

     My current variation is based on [[https://github.com/Tadly/hideIt.sh][Tadly's hideIt.sh]]

     Script(s) and desktop shortcuts are to be found in [[file:Desktop.org][Desktop.org]]
** Interaction between Emacs and X applications
   Emacsclient with --eval allows for some great interactions between the shell and Emacs.
   Let's create a combination of Emacs Lisp and shell script for some of these.

*** Jump to or launch application like Gmail or Spotify
    If we already have a browser window running, select it and bring it to the foreground.
    If not, launch it, showing just unread threads.

**** Function =gjg/exwm-switch-to-buffer-or-launch=

     #+begin_src emacs-lisp
       (defun gjg/exwm-switch-to-buffer-or-launch (searchstring &optional application)
         "Switch to the first buffer matching SEARCHSTRING as a substring
          If no matching buffer is found, launch the APPLICATION using gtk-launch."
         (let
             ((mybuf (car (cl-remove-if-not (lambda (row) (cl-search searchstring (buffer-name row))) (buffer-list)))))
           (if mybuf
               (switch-to-buffer mybuf)
             (if application
                 (call-process-shell-command (concat "gtk-launch " application))
               (message "No \"%s\" window is running." searchstring)))))
     #+end_src

**** Shell script to select corporate Gmail window with unread threads
     This shell script can be called from Polybar (my config includes a button that
     invokes this script)

    #+begin_src bash :tangle ~/bin/gmail-buffer-or-launch.sh
      emacsclient -e '(gjg/exwm-switch-to-buffer-or-launch (concat gjg/employer-name " Mail") "gmail")'
    #+end_src

**** Function to select or launch Logseq
     #+begin_src emacs-lisp
       (defun gjg/exwm-select-or-launch-logseq ()
         "Select the running Spotify window in EXWM, or launch the app"
         (interactive)
         (gjg/exwm-switch-to-buffer-or-launch "Logseq App" "com.logseq.Logseq"))
     #+end_src

**** Function to select or launch Spotify
     #+begin_src emacs-lisp
       (defun gjg/exwm-select-or-launch-spotify ()
         "Select the running Spotify window in EXWM, or launch the app"
         (interactive)
         (gjg/exwm-switch-to-buffer-or-launch "Spotify" "spotify"))
     #+end_src

**** Function to switch quickly to Zoom Meeting
     #+begin_src emacs-lisp
       (defun gjg/exwm-select-zoom-meeting ()
         "Select the running Zoom Meeting window if it's running."
         (interactive)
         (gjg/exwm-switch-to-buffer-or-launch "Zoom Meeting"))
     #+end_src


*** Update Spotify's buffer name when song changes
    If running EXWM, let's keep Spotify's buffer name hip
    #+begin_src emacs-lisp
      (defun gjg/update-spotify-exwm-window (songname)
        "When running EXWM add current song name to buffer name"
        ;; find the buffer
        (when (frame-parameter (selected-frame) 'exwm-active)
          (dolist (mybuf (cl-remove-if-not (lambda (row) (cl-search "Spotify" (buffer-name row))) (buffer-list)))
            (with-current-buffer mybuf
              (when (string= "Spotify" exwm-class-name) (exwm-workspace-rename-buffer (concat exwm-class-name " - " songname)))))))
    #+end_src
    #+begin_src bash :tangle ~/bin/update-spotify-exwm.sh
      # Called from dunst when Spotify makes a notification (changes song)
      # Dunst passes these parameters in order: appname, summary, body, icon, urgency
      echo $0 >> /tmp/update-spotify.log
      summary=$2
      body=$3
      # emacsclient -e "(gjg/update-spotify-exwm-window \"${summary} - ${body}\")"
      emacsclient -e "(gjg/update-spotify-exwm-window \"${body}\")"
    #+end_src
*** Select apps such as secondary Emacs to start in char-mode, start floating/tiled etc.
    Set certain windows to start in char-mode, floating/tiled etc
    #+begin_src emacs-lisp
      (setq exwm-manage-configurations
            '(((member exwm-class-name '("Emacs" "Gnome-terminal" "konsole" "libreoffice-calc" "xdg-desktop-portal-gnome" "kitty"))
               char-mode t)
              ))
    #+end_src
** To launch or not to launch
   My configuration tests for the existence of a window manager.  If one is already
   running, just skip all the EXWM setup and bring up a "normal" Emacs instance.

   I shared this solution in an Emacs Stackexchange question: [[https://emacs.stackexchange.com/a/60455/418][Launch EXWM only when no another WM or DE are being used]]

#+begin_src emacs-lisp
  (when (get-buffer "*window-manager*")
    (kill-buffer "*window-manager*"))
  (when (get-buffer "*window-manager-error*")
    (kill-buffer "*window-manager-error*"))
  (when (executable-find "wmctrl")
    (progn
      (shell-command "wmctrl -m ; echo $?" "*window-manager*" "*window-manager-error*")))
  (setq gjg/exwm-needed-p
        (and (get-buffer "*window-manager-error*")
             (eq window-system 'x)))
#+end_src
** Let's get this show on the road - if no window manager was detected
   We start a large =when= block here
 #+begin_src emacs-lisp
   (when gjg/exwm-needed-p
 #+end_src
*** Start wallpaper with transparency first for aesthetics
    Script below is generated with the [[file:Desktop.org][Org file referenced above]]
    #+begin_src emacs-lisp
      (set-opacity 95)
      ;; (async-start-process "wallpaper-thang"  "nohup" nil (expand-file-name "~/bin/schedule-rotate-wallpapers.sh") "&")
    #+end_src
*** My specific config function
    I did not want =ido= integration and wanted to evolve my config.  So I copied the
    default config function and commenced modifying

    This sets the amazing simulation keys.  What does that little miracle do for us? It
    gives us Emacs keys in Firefox, that's what it does!  And other X applications, of
    course.

    So now we can hit =C-n= to move to the next line.  I use =C-s= to search in Firefox,
    which translates to sending a =C-f=.  There's more I want to configure but I haven't
    entirely figured out how this works in char mode, whether it works with the Super key
    and so forth.

    RESERVED for OBS Studio:
    + Super-X
    + Super-C
    + Super-/


    TODO: Define super-{left,right,0,1,2} to mean the same thing I have in the global
    keymap: windmove etc.

    TODO: Define simulation key for "Print"
     #+begin_src emacs-lisp
         (defun gjg/exwm-config ()
       "Config for moi.  Initially this is a copy of exwm-config-example, but cutting out the ido integration"
       ;; Set the initial workspace number.
       ;; (unless (get 'exwm-workspace-number 'saved-value)
       ;;   (setq exwm-workspace-number 2)) ; GJG changed from default
       ;; Global keybindings.
       ;; (unless (get 'exwm-input-global-keys 'saved-value)
       (message "Setting exwm-input-global-keys")
       (setq exwm-input-global-keys
             `(
           ([?\s-i] . exwm-input-toggle-keyboard) ; toggle line/char mode
           (,(kbd "s-l") .   ;; super/windows l
            (lambda ()
              (interactive)
              (call-process-shell-command "xfce4-screensaver-command -l")))
           ;; 's-r': Reset (to line-mode).
           ([?\s-r] . exwm-reset)
           ([?\s-s] . save-some-buffers)
           ([?\s-f] . exwm-floating-toggle-floating)
           ;; 's-w': Switch workspace.
           ([?\s-w] . exwm-workspace-switch) ;; use this to switch workspaces, not S-<number>
           ;; 's-&': Launch application. - poor man's albert/launchy
           ([?\s-&] . (lambda (command)
                    (interactive (list (read-shell-command "$ ")))
                    (start-process-shell-command command nil command)))
           ;; 's-&': Launch application. - poor man's albert/launchy
           ([?\s-7] . (lambda (command)
                    (interactive (list (read-shell-command "$ ")))
                    (start-process-shell-command command nil command)))
           ([?\s-o] .  gjg/other-window-with-winum)
           ([s-left] . windmove-left)
           ([s-right] . windmove-right)
           ([s-up] . windmove-up)
           ([s-down] . windmove-down)
           ([M-s-up] . windmove-delete-up)
           ([M-s-down] . windmove-delete-down)
           ([M-s-left] . windmove-delete-left)
           ([M-s-right] . windmove-delete-right)
           (,(kbd "M-SPC") . (lambda () (interactive) (call-process-shell-command "rofi -modi drun,run -show drun")))
           (,(kbd "s-SPC") . app-launcher-run-app)
           ;; ([s-SPC] . (lambda () (interactive) (call-process-shell-command "rofi -modi drun,run -show drun")))
           ([?\s-e] . gjg/ibuffer-only-exwm)
           ([s-backspace] . bury-buffer)
           ([?\s-q] . bury-buffer)
           ([?\s-\\] . switch-to-buffer )
           ([?\s-a] . gjg/open-work-agenda)
           ([?\s-b] . gjg/switch-to-other-buffer)
           ([?\s-0] . delete-window)
           ([?\s-1] . delete-other-windows)
           ([?\s-2] . gjg/split-window-below)
           ([?\s-3] . gjg/split-window-right)
           ([?\s-c] . (lambda () (interactive) (call-process-shell-command "invert-color.sh")))
           ([?\s-j] . org-clock-goto)
           ([?\s-p] . playerctl-play-pause-song)
           ([?\s-t] . toggle-truncate-lines)
           ([?\s-g] . gjg/exwm-select-or-launch-logseq)
           ([?\s-y] . gjg/exwm-select-or-launch-spotify)
           (,(kbd "<XF86MonBrightnessUp>") . (lambda () (interactive) (call-process-shell-command "gjg-bright.sh +5")))
           (,(kbd "<XF86MonBrightnessDown>") . (lambda () (interactive) (call-process-shell-command "gjg-bright.sh -5")))
           (,(kbd "<XF86AudioRaiseVolume>") . (lambda nil (interactive) (call-process-shell-command "pulseaudio-control-glados up")))
           (,(kbd "<XF86AudioLowerVolume>") . (lambda nil (interactive) (call-process-shell-command "pulseaudio-control-glados down")))
           (,(kbd "<XF86AudioMute>") . (lambda nil (interactive) (call-process-shell-command "pulseaudio-control-glados togmute")))
           (,(kbd "<XF86AudioPlay>") . playerctl-play-pause-song)
           ([?\s--] . gjg/exwm-select-zoom-meeting)
           ([?\s-.] . (lambda () (interactive) (find-file "~/emacs-gregoryg/README.org")))
           ([?\s-,] . gjg/polybar-start-or-toggle)

           ;; GJG: I don't make much use of workspaces, so don't need the insta-create capability
           ;; 's-N': Switch to certain workspace.
           ;; ,@(mapcar (lambda (i)
           ;;             `(,(kbd (format "s-%d" i)) .
           ;;               (lambda ()
           ;;                 (interactive)
           ;;                 (exwm-workspace-switch-create ,i))))
           ;;           (number-sequence 4 9))
           ))
       ;; )
       ;; Line-editing shortcuts
       (unless (get 'exwm-input-simulation-keys 'saved-value)
         (setq exwm-input-simulation-keys
           '(([?\C-b] . left)
             ([?\C-f] . [right])
             ([?\C-p] . [up])
             ;; ([?\C-P] . [?\C-p]) ; Print
             ([?\C-n] . [down])
             ([?\C-a] . [home])
             ([?\C-e] . [end])
             ([?\M-v] . [prior])
             ([?\C-v] . [next])
             ([?\C-d] . [delete])
             ([?\C-k] . [S-end delete])
             ([?\C-l] . [?\C-l])
             ([?\C-t] . [?\C-t])
             ([?\C-s] . [?\C-f]) ; I'm gonna search/find a better way
             ([?\M-w] . [?\C-c]) ; Copy that!
             ;; ([?\S-p] . [?\C-p]) ; TODO Print - not working
             ([?\C-y] . [?\C-v]) ; yank/paste
             )))
       ;; Enable EXWM
       (exwm-enable)
       ;; ;; Configure Ido
       ;; (exwm-config-ido)
       ;; Other configurations
       ;; (exwm-config-misc)
       )
     #+end_src
*** Require packages and run my custom conifg
  #+begin_src emacs-lisp
    ;; (< 0 (length (with-current-buffer "*window-manager-error*" (buffer-string)))))
    (require 'exwm)
    (require 'exwm-config)
    (gjg/exwm-config)
  #+end_src
*** Configure hooks
**** Deal with displays
    When an external monitor is connected or disconnected, =exwm-randr-screen-change-hook=
    is called.

    The single command I currently run adds my external widescreen monitor to the left of
    the internal display.

    Disconnecting the external monitor was not working well until I started using
    =autorandr= with a laptop-only and a monitor-connected profile.  I allow autodetection
    of the appropriate profile with the =--change= parameter.  The solution came from a
    [[https://www.reddit.com/r/emacs/comments/j0zda7/exwm_randr_config_for_laptop_disconnect/?utm_source=share&utm_medium=web2x&context=3][post on /r/emacs]]

        #+begin_src emacs-lisp
          (require 'exwm-randr)
          ;; (setq exwm-randr-workspace-monitor-plist '(0 "DP-1")) ;; DP-1 is the big monitor, if connected
          (setq exwm-randr-workspace-monitor-plist '(0 "DP-3" 1 "eDP-1")) ;; DP-3 is the big monitor, if connected

          (add-hook 'exwm-randr-screen-change-hook
                    (lambda()
                      (message "Starting exwm-randr-screen-change-hook")
                      (start-process-shell-command
                       "autorandr" nil "autorandr --change ; autorandr"
                       ;; "xrandr" nil "xrandr --output eDP-1 --mode 1920x1200 --pos 0x0 --rotate normal"
                       ;; WORKS WHEN ADDING MONITOR, NOT WHEN DISCONNECTING "xrandr" nil "xrandr --output eDP-1 --mode 1920x1200 --pos 0x0 --rotate normal --output DP-3 --primary --mode 3440x1440 --left-of eDP-1 --rotate normal"
                       ;; and here's how I might get a mirrored setup
                       ;; xrandr --output eDP-1 --mode 1920x1080 --output DP-3 --mode 1920x1080 --same-as eDP-1
                       )))
        #+end_src
**** Intelligently rename new buffers
    By default, each new window's buffer is named by the 'class name': So Firefox, Slack,
    Alacritty and so on.  This means that I will get similar buffer names for each new
    Firefox window: Firefox<1>, Firefox<2>....

    Examining both =exwm-class-name= and =exwm-title= allows us to rename the buffers so
    that navigation via regular Emacs commands is made easy.

        #+begin_src emacs-lisp
          ;; Make class name the buffer name
          (add-hook 'exwm-update-class-hook
                    (lambda ()
                      (cond
                       (:else
                        (exwm-workspace-rename-buffer exwm-class-name)))))
          (add-hook 'exwm-update-title-hook
                    (lambda ()
                      (let ((browsers '(("Mozilla Firefox" . "firefox")
                                        ("Personal - Microsoft​ Edge Beta" . "msedge")
                                        ("Google Chrome" . "chrome")
                                        ("Chromium" . "chromium"))))
                            (cond
                             ;; Browser titles
                             ((s-starts-with-p "Mail - Greg Grubbs - Outlook - " exwm-title)
                              (exwm-workspace-rename-buffer "email - outlook"))
                             ((s-starts-with-p "Calendar - Greg Grubbs - Outlook" exwm-title)
                              (exwm-workspace-rename-buffer "calendar - outlook"))
                             ((s-starts-with-p "Google Hangouts - " exwm-title)
                              (exwm-workspace-rename-buffer "hangouts"))
                             ((s-starts-with-p "Chat - " exwm-title)
                              (exwm-workspace-rename-buffer "chat"))
                             ;; standalone apps
                             ((s-starts-with-p "Slack" exwm-title)
                              (exwm-workspace-rename-buffer "slack"))
                             ((string= "zoom" exwm-class-name)
                              (exwm-workspace-rename-buffer (concat exwm-title " - " exwm-class-name)))
                             ((string= "Logseq" exwm-class-name)
                              (exwm-workspace-rename-buffer (concat exwm-title " - " exwm-class-name " App")))
                             ((string= "Spotify" exwm-class-name)
                              (exwm-workspace-rename-buffer (concat exwm-title " - " exwm-class-name)))
                             (:else
                              (exwm-workspace-rename-buffer
                               (s-replace-all browsers exwm-title)))))))
        #+end_src
**** Clean up on exit
     #+begin_src emacs-lisp
       (add-hook 'exwm-exit-hook
                 (lambda ()
                   (async-start-process "exwm-exit" "pkill" nil "-f" "schedule-rotate-wallpapers.sh" )))
     #+end_src

*** Start up the window manager
    As noted above, I do not use the EXWM system tray.
        #+begin_src emacs-lisp
	  (exwm-enable)
	  ;; (require 'exwm-systemtray)
	  ;; (exwm-systemtray-enable)
        #+end_src
*** Start up xrandr to react to display changes
        #+begin_src emacs-lisp
	  (exwm-randr-enable)
        #+end_src

*** Deal with brightness and volume, since we don't have a DE
    There is a =desktop-environment= package on Melpa, but it's overkill for what I need.
    TODO: Figure out how to specify these keys and modify =exwm-input-global-keys=
    instead.  This section doesn't work

        #+begin_src emacs-lisp :tangle no
          (exwm-input-set-key (kbd "<XF86MonBrightnessUp>")
                              (lambda ()
                                (interactive)
                                (call-process-shell-command "gjg-bright.sh +5")))
          (exwm-input-set-key (kbd "<XF86MonBrightnessDown>")
                              (lambda ()
                                (interactive)
                                (call-process-shell-command "gjg-bright.sh -5")))
          ;; N.B. keyboard backlight level (0 1 2) is kept in /sys/class/leds/dell\:\:kbd_backlight/brightness
          (exwm-input-set-key (kbd "<XF86AudioRaiseVolume>")
                              (lambda ()
                                (interactive)
                                (call-process-shell-command "amixer sset 'Master' 5%+")))
          (exwm-input-set-key (kbd "<XF86AudioLowerVolume>")
                              (lambda ()
                                (interactive)
                                (call-process-shell-command "amixer sset 'Master' 5%-")))
          (exwm-input-set-key (kbd "<XF86AudioMute>")
                              (lambda ()
                                (interactive)
                                (call-process-shell-command "amixer sset 'Master' toggle")))
        #+end_src
*** Navigate and manipulate windows
    Now that we will be running *everything* in Emacs, we will be doing a lot of window
    switching and frame splitting.  Here are some ways to bring sanity to that process and
    hopefully ease Emacs Pinky Syndrome.

    =buffer-expose= is an alternative to alt-tab

    TODO: look for alternative to buffer-expose, as it does not play
    well with EXWM - many times the EXWM windows such as the browsers
    become unusable, with click and normal keyboard events throwing
    warnings/errors
    Oneto consider:
    + [[https://github.com/casouri/emacs-mission-control][GitHub - casouri/emacs-mission-control: Mac mission-control-like buffer switch]]
      #+begin_src emacs-lisp :tangle no
        (straight-use-package
         '(mission-control
           :type git
           :host github
           :repo "casouri/emacs-mission-control"))
        (use-package mission-control
          :straight t
          :config
          (mcon-c-tab-setup-binding))
      #+end_src

    =window-divider-mode= makes it easy to  resize vertically split windows with the mouse - EXWM
    makes it nearly impossible to select the vertical margin without this!

*** Start the OS processes
    #+begin_src emacs-lisp
      (call-process-shell-command "~/bin/emacswm.sh")
      (setenv "EDITOR" "emacsclient")
    #+end_src

** And FINALLY - this must be last - close out the =when= clause
        #+begin_src emacs-lisp
        ) ;; when gjg/exwm-needed-p
        #+end_src

* Commonly used modes
** Start emacs server
   #+begin_src emacs-lisp
     (unless (server-running-p)
       (server-start))
   #+end_src
** Yafolding Mode
   Yafolding mode is useful in code and (maybe even but probably not in) Org.  Let's keep
   Org mode's keys unmolested, and use an additional modifier to toggle hide/show
   #+begin_src emacs-lisp
     (use-package yafolding
       :straight t
       :init
       (unbind-key (kbd "<C-return>") yafolding-mode-map)
       (unbind-key (kbd "<C-S-return>") yafolding-mode-map)
       (unbind-key (kbd "<C-M-return>") yafolding-mode-map)

       (define-key yafolding-mode-map (kbd "C-'") #'yafolding-toggle-element)
       (define-key yafolding-mode-map (kbd "C-M-'") #'yafolding-toggle-all))
       ;; (define-key yafolding-mode-map (kbd "<C-S-return>") #'yafolding-toggle-all)
       ;; (define-key yafolding-mode-map (kbd "<C-M-return>") #'yafolding-toggle-element))
   #+end_src
** Eshell
   Okay, not yet "commonly used" (as of [2020-09-23 Wed]) ... but it appears to be
   awesome.

   Ref Howard Abrams' [[https://www.youtube.com/watch?v=RhYNu6i_uY4&t=1548s][Introduction to EShell - YouTube]]

   + Eshell uses =term= when a non-line-mode command is invoked.  Set it so that the
     =term= window goes away when the process ends.  Also make various =git= things work
     nicely.
   #+begin_src emacs-lisp :tangle no
     (setq eshell-visual-subcommands '(("git" "log" "diff" "show")))
     (setq eshell-destroy-buffer-when-process-dies t)
   #+end_src
** Project.el
   Project.el is built in

   #+begin_src emacs-lisp
     (use-package project :straight t)
     (setq project-switch-commands
        '((project-find-file "Find file")
          (project-find-regexp "Find regexp")
          (project-find-dir "Dired somewhere")
          (project-dired "Root dired" ?r)
          (project-shell "Shell" ?s)
          (magit-project-status "Magit" ?m)
          (treemacs-add-and-display-current-project "Treemacs" ?t)))
     (defun gjg/project-dired-choose ()
       "Visit a directory (with completion) in the current project."
       (interactive)
       (let* ((pr (project-current t))
              (dir (expand-file-name "~/projects/homelab"))
              (localdir (file-name-unquote (file-local-name (expand-file-name dir))))
              (dirs (process-file-shell-command (format "%s -H %s -type d " find-program (shell-quote-argument (directory-file-name localdir))))))

         (completing-read "Ohai: " dirs)))
         ;; (message dirs)))

         ;; (project-find-file-in (thing-at-point 'filename) dirs pr)))
   #+end_src
** EDE
   I have no use for the built-in EDE.  The only thing EDE does for me is to steal the
   =C-c .= keystroke away from Org Mode - thanks for nothin' EDE.

   I'll just remap the keys to the currently-unused =C-c e=

   #+begin_src emacs-lisp
     (with-eval-after-load 'ede
       (define-key ede-minor-mode-map (kbd "C-c e")
                   (lookup-key ede-minor-mode-map (kbd "C-c .")))
       (unbind-key (kbd "C-c .") org-mode-map))
   #+end_src

** Corfu - auto-complete and more
   I want something for auto-complete that behaves more like selectrum and other such
   tools

   + [[https://github.com/minad/corfu][GitHub - minad/corfu: corfu.el - Completion Overlay Region FUnction]]
   #+begin_src emacs-lisp
     (use-package corfu
       :straight t
       ;; Optional customizations
       :custom
       ;; (corfu-cycle t)                ;; Enable cycling for `corfu-next/previous'
       (corfu-auto t)                 ;; Enable auto completion
       (corfu-separator ?\s)          ;; Orderless field separator
       ;; (corfu-quit-at-boundary nil)   ;; Never quit at completion boundary
       ;; (corfu-quit-no-match nil)      ;; Never quit, even if there is no match
       ;; (corfu-preview-current nil)    ;; Disable current candidate preview
       ;; (corfu-preselect-first nil)    ;; Disable candidate preselection
       ;; (corfu-on-exact-match nil)     ;; Configure handling of exact matches
       ;; (corfu-echo-documentation nil) ;; Disable documentation in the echo area
       ;; (corfu-scroll-margin 5)        ;; Use scroll margin

       ;; Enable Corfu only for certain modes.
       ;; :hook ((prog-mode . corfu-mode)
       ;;        (shell-mode . corfu-mode)
       ;;        (eshell-mode . corfu-mode))

       ;; Recommended: Enable Corfu globally.
       ;; This is recommended since Dabbrev can be used globally (M-/).
       ;; See also `corfu-excluded-modes'.
       (corfu-excluded-modes '(shell-mode vterm-mode comint-mode))
       :init
       (global-corfu-mode))


     ;; Add extensions
     (use-package cape
       :straight t
       :config
       (setq cape-dabbrev-check-other-buffers nil)
     ;;   ;; Bind dedicated completion commands
     ;;   ;; Alternative prefix keys: C-c p, M-p, M-+, ...
       :bind (("C-c p p" . completion-at-point) ;; capf
     ;;          ("C-c p t" . complete-tag)        ;; etags
              ("C-c p d" . cape-dabbrev)        ;; or dabbrev-completion
     ;;          ("C-c p h" . cape-history)
              ("C-c p f" . cape-file)
     ;;          ("C-c p k" . cape-keyword)
     ;;          ("C-c p s" . cape-symbol)
     ;;          ("C-c p a" . cape-abbrev)
     ;;          ("C-c p i" . cape-ispell)
     ;;          ("C-c p l" . cape-line)
     ;;          ("C-c p w" . cape-dict)
     ;;          ("C-c p \\" . cape-tex)
     ;;          ("C-c p _" . cape-tex)
     ;;          ("C-c p ^" . cape-tex)
     ;;          ("C-c p &" . cape-sgml)
     ;;          ("C-c p r" . cape-rfc1345))
              )
       :init
       ;; Add `completion-at-point-functions', used by `completion-at-point'.
       (add-to-list 'completion-at-point-functions #'cape-dabbrev)
       (add-to-list 'completion-at-point-functions #'cape-file)
     ;;   ;;(add-to-list 'completion-at-point-functions #'cape-history)
     ;;   ;;(add-to-list 'completion-at-point-functions #'cape-keyword)
     ;;   ;;(add-to-list 'completion-at-point-functions #'cape-tex)
     ;;   ;;(add-to-list 'completion-at-point-functions #'cape-sgml)
     ;;   ;;(add-to-list 'completion-at-point-functions #'cape-rfc1345)
     ;;   ;;(add-to-list 'completion-at-point-functions #'cape-abbrev)
     ;;   ;; (add-to-list 'completion-at-point-functions #'cape-ispell)
     ;;   ;;(add-to-list 'completion-at-point-functions #'cape-dict)
     ;;   ;;(add-to-list 'completion-at-point-functions #'cape-symbol)
     ;;   ;;(add-to-list 'completion-at-point-functions #'cape-line)
       )


     (use-package orderless
       :straight t
       :init
       (setq completion-styles '(orderless basic)
         completion-category-defaults nil
         completion-category-overrides '((file (styles . (partial-completion))))))

     ;; A few more useful configurations...
     ;; (use-package emacs
     ;;   :straight t
     ;;   :init
     ;;   ;; TAB cycle if there are only few candidates
     ;;   (setq completion-cycle-threshold 3)

     ;;   ;; Emacs 28: Hide commands in M-x which do not apply to the current mode.
     ;;   ;; Corfu commands are hidden, since they are not supposed to be used via M-x.
     ;;   ;; (setq read-extended-command-predicate
     ;;   ;;       #'command-completion-default-include-p)

     ;;   ;; Enable indentation+completion using the TAB key.
     ;;   ;; `completion-at-point' is often bound to M-TAB.
     ;;   (setq tab-always-indent 'complete))
   #+end_src
** Marginalia - crazy annotations for completions
   #+begin_src emacs-lisp
     (use-package marginalia
       :straight t
       :bind (("M-A" . marginalia-cycle)
              :map minibuffer-local-map
              ("M-A" . marginalia-cycle)
              )
       :init
       (marginalia-mode))
   #+end_src
** Markdown
   It's common to have very long lines in Markdown text - so turn on =longlines-mode=
   with word wrapping only for those files.
   #+begin_src emacs-lisp
     (use-package markdown-mode
       :straight t
       :hook
       (markdown-mode . visual-line-mode)
     )
   #+end_src
** TRAMP
*** Tweak remote bash shell prompt PS1
    #+begin_src bash :tangle ~/.emacs.d/init_bash.sh
      # Reset the prompt for remote TRAMP shells.
      if [ "${INSIDE_EMACS/*tramp*/tramp}" == "tramp" ] ; then
      #   PS1="[\u@\h \w]$ "
         PS1="[$(echo $PS1 | cut -d':' -f 1-2 ):\w]$ "
      fi
    #+end_src
*** Add methods for Docker, DC/OS, Google Cloud Shell
**** Add a helper script for Kubernetes =kube= method

     + Firstly, implement my custom way of handling multiple clusters
       #+begin_src bash :tangle ~/bin/load-kubeconfigs.sh
         # Stolen from https://medium.com/@alexgued3s/multiple-kubeconfigs-no-problem-f6be646fc07d

         # Start by "resetting" KUBECONFIG
         unset KUBECONFIG
         # If there's already a kubeconfig file in ~/.kube/config it will import that too and all the contexts
         DEFAULT_KUBECONFIG_FILE="$HOME/.kube/config"
         if test -f "${DEFAULT_KUBECONFIG_FILE}"
         then
           export KUBECONFIG="$DEFAULT_KUBECONFIG_FILE"
         fi
         # Your additional kubeconfig files should be inside ~/.kube/config-files
         ADD_KUBECONFIG_FILES="$HOME/.kube/config-files"
         mkdir -p "${ADD_KUBECONFIG_FILES}"

         OIFS="$IFS"
         IFS=$'\n'
         for kubeconfigFile in `find "${ADD_KUBECONFIG_FILES}" -type f -name "*.yml" -o -name "*.yaml"`
         do
             export KUBECONFIG="$kubeconfigFile:$KUBECONFIG"
         done
         IFS="$OIFS"
       #+end_src
     + This will work with the custom method.  It will honor the existing setting of
       context namespace, so set that first if the Pod is running in something other than
       =default= namespace.

       E.g.
       #+begin_src bash
         kn poodle # using alias
         kubectl config set-context --current --namespace poodle # full cmd
       #+end_src
       #+begin_src bash :tangle ~/bin/mykubectl
         source ~/bin/load-kubeconfigs.sh
         kubectl $@
       #+end_src

**** Define TRAMP methods
    #+begin_src emacs-lisp
      ;; add method to connect to Mesosphere DC/OS tasks
      ;; we need to execute a command like the following
      ;;  dcos task exec --tty --interactive <taskname> -- bash
      ;; example TRAMP URI:   //dcos:jupyter:
      (require 'tramp)
      (with-eval-after-load 'tramp
        (add-to-list 'tramp-methods
                     `("docker"
                       (tramp-login-program      "docker")
                       (tramp-login-args         (nil ("exec" "-it") ("-u" "%u") ("%h") ("sh")))
                       (tramp-remote-shell       "/bin/sh")
                       (tramp-remote-shell-args  ("-i" "-c"))))
        ;; Add method to connect to Kubernetes pods
        ;; we need to execute a command like the following
        ;;  kubectl exec -it --namespace jhub jupyter-gregj -- /bin/bash
        ;; example TRAMP URI:   //kexec:jhub@jupyter:
        (add-to-list 'tramp-methods
                     '("kube"
                       (tramp-login-program "~/bin/mykubectl")
                       (tramp-login-args
                        (nil
                         ("exec" "-it")
                         ("--namespace" "%u")
                         ("%h")
                         ("--" "sh")))
                       (tramp-remote-shell "/bin/sh")
                       (tramp-remote-shell-args ("-i" "-c"))))

        ;; Google Cloud Shell
        (add-to-list 'tramp-methods
                     '("gshell"
                       (tramp-login-program        "gcloud alpha cloud-shell ssh")
                       (tramp-default-host "cloud-shell")
                       (tramp-login-args (("#%h")))
                       ;; (tramp-login-args           (("%h")))
                       ;; (tramp-async-args           (("-q")))
                       (tramp-remote-shell         "/bin/bash")
                       (tramp-remote-shell-args    ("-c"))
                       ;; (tramp-gw-args              (("-o" "GlobalKnownHostsFile=/dev/null")
                       ;;                              ("-o" "UserKnownHostsFile=/dev/null")
                       ;;                              ("-o" "StrictHostKeyChecking=no")))
                       (tramp-default-port         22)))
        ;; TRAMP gcloud ssh with no helper script
        (add-to-list 'tramp-methods
                     '("gssh"
                       (tramp-login-program        "gcloud compute ssh")
                       (tramp-login-args           (("%h")))
                       (tramp-async-args           (("-q")))
                       (tramp-remote-shell         "/bin/sh")
                       (tramp-remote-shell-args    ("-c")))))


    #+end_src
*** Handle SUDO - root and other users
    #+begin_src emacs-lisp
;; TRAMP SUDO FUN - snarfed from Peter Dyballa on gmane.emacs.help
(defun my-tramp-header-line-function ()
  (when (string-match "^/.*su\\(do\\)?:" default-directory)
    (setq header-line-format
	      (format-mode-line "----- THIS BUFFER IS VISITED WITH SUDO PRIVILEGES -----"
			                'font-lock-warning-face))))

(with-eval-after-load 'tramp
  (add-hook 'find-file-hook 'my-tramp-header-line-function)
  (add-hook 'dired-mode-hook 'my-tramp-header-line-function))
    #+end_src
*** Shell sugar
**** Open remote shell in current remote directory
#+begin_src emacs-lisp
  (defun gjg/open-shell-prompted (newdir)
    "Directly open shell local or TRAMP remote"
    (interactive "D")
    (message (format "Changing directory to %s" newdir))
    (cd newdir)
    (if (file-remote-p newdir)
        (shell (format "%s-sh" (file-remote-p newdir 'host)))
      (shell
       (format "%s-sh"
        (file-name-nondirectory
         (directory-file-name
          (file-name-directory newdir)))))))



  (defun gjg/open-remote-shell ()
    "If current buffer is remote, open a new uniquely named shell based on host name"
    (interactive)
    (if (file-remote-p default-directory)
        (progn
          ;; do stuff
          (message "Now I shall do stuff")
          (shell (concat (file-remote-p default-directory 'host) "-sh")))
      (shell
       (concat
        (file-name-nondirectory
         (directory-file-name
          (file-name-directory
           default-directory))) "-sh"))))
#+end_src

** Dired
   =dired-dwim-target= is just awesome.  Whenever you have 2 Dired
   windows in a frame, hitting Copy or Rename from one Dired buffer
   automatically suggests the other as the target

   =dired-omit-files= is a regexp for files you want to hide using
   =dired-omit-mode= Depending on your workflow, that may include
   compiled files (.elc, .o etc) as well as normally hidden files.

   =auto-revert-mode= refreshes the visible buffer when something in
   the directory changes.

   #+begin_src emacs-lisp
     ;; (require 'dired)
     (with-eval-after-load 'dired)
     ;; (use-package all-the-icons-dired :straight t)
     (use-package all-the-icons :straight t) ;; currently (<2022-08-22 Mon>) being used *only* for org-agenda-category-icon-alist
     (use-package dired-collapse :straight t)
     (use-package treemacs
       :straight t
       :defer t
       :config
       (progn
         (treemacs-fringe-indicator-mode 'only-when-focused)
         (when treemacs-python-executable
           (treemacs-git-commit-diff-mode t))
         (pcase (cons (not (null (executable-find "git")))
                      (not (null treemacs-python-executable)))
           (`(t . t)
            (treemacs-git-mode 'deferred))
           (`(t . _)
            (treemacs-git-mode 'simple)))
         (treemacs-modify-theme "Default"
           :icon-directory "~/emacs/pixmaps/"
           :config
           (progn
             (treemacs-create-icon :file "sparql-rdf.png" :extensions ("sparql" "rq" "ttl" "trig")))))
       :bind
       (:map treemacs-mode-map
             ("C-o" . treemacs-visit-node-no-split))
       )

     (use-package treemacs-icons-dired
       :straight t
       :hook
       (dired-mode . treemacs-icons-dired-enable-once))

     (define-key dired-mode-map [mouse-1] 'dired-find-file)
     (define-key dired-mode-map [mouse-2] 'dired-find-file)
     (setq dired-dwim-target t
           dired-omit-files "^\\.?#\\|^\\..*"
           delete-by-moving-to-trash nil
           dired-listing-switches "-alh --group-directories-first")

     ;; set key binding in key map prior to dired-x being loaded - for autoload
     (define-key dired-mode-map "\C-x\M-o" 'dired-omit-mode)
     (define-key dired-mode-map (kbd "M-<up>") 'dired-up-directory)
     (define-key dired-mode-map (kbd "M-<down>") 'dired-find-file)
     (autoload 'dired-omit-mode "dired-x" "Dired-X")
     ;; (declare (special dired-x-hands-off-my-keys
     ;; 		  dired-bind-vm
     ;; 		  dired-omit-files-p))
     ;; (add-hook 'dired-load-hook
     ;; 	  (function
     ;; 	   (lambda ()
     ;; 	     (declare (special dired-x-hands-off-my-keys
     ;; 			       dired-bind-vm))
     ;; 	     (load-library "dired-x")
     ;; 	     (setq dired-x-hands-off-my-keys nil
     ;; 		   dired-bind-vm t))))

     (setq auto-revert-verbose nil)
     (add-hook 'dired-mode-hook
           (lambda ()
             (interactive)
             (dired-omit-mode 1)
             ;; (dired-hide-details-mode 1)
             ;; (all-the-icons-dired-mode 1)
             (auto-revert-mode 1)))
     ;; 		      ;; Set dired-x buffer-local variables here.  For example:
     ;; 		      (setq dired-omit-mode t)
     ;; 		      (setq dired-omit-files "^\\..*")
     ;; 		      )))
   #+end_src
*** Open file in relevant OS app
#+begin_src emacs-lisp
  ;; swiped from Gilaras Drakeson <gilaras@gmail.com>
  (defcustom gjg/os-open "xdg-open"
    "Command to open a document, e.g. `xdg-open` on Linux, `sensible-browser` on crostini, `open` on OS X, `explorer` or `cygpath` on Windows"
    :type 'string
    :group 'gjg)


  (defun dired-open (&optional file-list)
    (interactive
     (list (dired-get-marked-files t current-prefix-arg)))
    (progn
      (message (format "Calling %s %s" gjg/os-open file-list))
      (apply 'call-process gjg/os-open nil 0 nil file-list)))
  (define-key dired-mode-map (kbd "C-;") 'dired-open)
#+end_src
** Ediff
   #+begin_src emacs-lisp
     (setq ediff-split-window-function 'split-window-horizontally)
     (setq ediff-window-setup-function 'ediff-setup-windows-plain)
   #+end_src
*** Disable zoom-mode when using Ediff
    TODO: Figure out zoom config for this.  The below is a hack - I should be able to
    disable Zoom in its config by matching mode or buffer name.
    #+begin_src emacs-lisp :tangle no
      (add-hook 'ediff-before-setup-hook
                '(lambda ()
                   (setq gjg/zoom-mode zoom-mode) ;; save current state
                   (zoom-mode -1) ;; off unconditionally for Ediff
                   ))

      (add-hook 'ediff-quit-hook
                '(lambda ()
                   (zoom-mode (if gjg/zoom-mode 1 -1))  ;; reset to prior state
                   (message (format "gjg/zoom-mode is %s, zoom-mode is now %s" gjg/zoom-mode zoom-mode))
                   ))
    #+end_src
** Help and helpful modes
*** Add navigation to Help buffer
   #+begin_src emacs-lisp
     (setq help-window-select t)
     (add-hook 'help-mode-hook
               (lambda ()
                 (local-set-key (kbd "M-p") 'help-go-back)
                 (local-set-key (kbd "M-n") 'help-go-forward)
                 ))
   #+end_src
*** Use the Helpful package
   #+begin_src emacs-lisp
     (use-package helpful
       :straight t
       :config
       (global-set-key (kbd "C-h f") #'helpful-callable)
       (global-set-key (kbd "C-h v") #'helpful-variable)
       (global-set-key (kbd "C-h k") #'helpful-key)
       (global-set-key (kbd "C-h d") #'helpful-at-point)
       (global-set-key (kbd "C-h F") #'helpful-function)
       (global-set-key (kbd "C-h C") #'helpful-command))

     ;; (when (fboundp 'helpful-function)
     ;;   (progn
     ;;     ;; Note that the built-in `describe-function' includes both functions
     ;;     ;; and macros. `helpful-function' is functions only, so we provide
     ;;     ;; `helpful-callable' as a drop-in replacement.
     ;;     ;; (global-set-key (kbd "C-h f") #'helpful-callable)
     ;;     ;; (global-set-key (kbd "C-h v") #'helpful-variable)
     ;;     (global-set-key (kbd "C-h k") #'helpful-key)
     ;;     ;; Lookup the current symbol at point. C-c C-d is a common keybinding
     ;;     ;; for this in lisp modes.
     ;;     (global-set-key (kbd "C-c C-d") #'helpful-at-point)
     ;;     (setq counsel-describe-function-function #'helpful-callable)
     ;;     (setq counsel-describe-variable-function #'helpful-variable)))
   #+end_src

** Selectrum (will it replace Ivy which replaced Ido?)
   #+begin_src emacs-lisp
     (use-package selectrum :straight t)
     (selectrum-mode +1)
     (use-package selectrum-prescient :straight t)
     (selectrum-prescient-mode +1)
     (prescient-persist-mode +1)
   #+end_src


** Occur
*** Navigation
   #+begin_src emacs-lisp
     ;;     Some simple sex-ups for occur-mode
     (define-key occur-mode-map "n" 'occur-next)
     (define-key occur-mode-map "p" 'occur-prev)
     (defadvice occur-next (after gjg/occur-navigation-other-window)
       "Show match in other window as you navigate, as in rgrep"
       (occur-mode-display-occurrence))
     (ad-activate 'occur-next)
     (defadvice occur-prev (after gjg/occur-navigation-other-window)
       "Show match in other window as you navigate, as in rgrep"
       (occur-mode-display-occurrence))
     (ad-activate 'occur-prev)
   #+end_src
** Shell mode
*** Shell mode config
    #+begin_src emacs-lisp
      (custom-set-variables '(shell-kill-buffer-on-exit t)
                            '(shell-command-prompt-show-cwd t))
    #+end_src
*** Config for comint mode
    #+begin_src emacs-lisp
      (defun gjg/turn-on-comint-history (history-file)
        (setq comint-input-ring-file-name history-file)
        (comint-read-input-ring 'silent))
      (setq comint-input-ring-size 5000)
    #+end_src
*** Hook in shell history
    #+begin_src emacs-lisp
      (add-hook 'shell-mode-hook
                (lambda ()
                  (gjg/turn-on-comint-history (getenv "HISFILE"))))
      (add-hook 'kill-buffer-hook #'comint-write-input-ring)
      (add-hook 'kill-emacs-hook
                (lambda ()
                  (--each (buffer-list)
                    (with-current-buffer it (comint-write-input-ring)))))
    #+end_src
*** Bash completions
    #+begin_src emacs-lisp
      (use-package bash-completion
        :straight t
        :config
        (bash-completion-setup))
    #+end_src
*** ANSI color
    The =xterm-color-filter= function is part of the =xterm-color= package.  It does the
    Lord's work in translating ANSI color codes to font properties so that things can look
    awesome.

    #+begin_src emacs-lisp
      (use-package xterm-color :straight t)
      (ansi-color-for-comint-mode-on)
      ;; try some xterm coloring in shell buffers
      (setq comint-output-filter-functions
            (remove 'ansi-color-process-output comint-output-filter-functions))
      (add-hook 'shell-mode-hook
            (lambda ()
              (abbrev-mode 1)
              (add-hook 'comint-preoutput-filter-functions 'xterm-color-filter nil t)))
    #+end_src
*** SSH Agent in subprocesses
    + Not really related to shell-mode, this assures our keychain is activated for things
      such as magit that fire off subproceess
      #+begin_src emacs-lisp
        (use-package keychain-environment :straight t)
        (keychain-refresh-environment)
      #+end_src
** Vterm
   #+begin_src emacs-lisp
     (use-package vterm :straight t)
   #+end_src
** Magit
*** Behavior
    #+begin_src emacs-lisp
      ;; (use-package magit-todos :straight t)
      (use-package magit :straight t
        :config
        (setq magit-clone-set-remote.pushDefault t))
    #+end_src
*** Initiate =magit-todos= only on =magit= invocation, since it loads slowly
    #+begin_src emacs-lisp :tangle no
      (use-package magit-todos :straight t)
      (add-hook 'magit-status-mode-hook
                (lambda ()
                  (magit-todos-mode 1)
                  ))
    #+end_src

** Spelling
   #+begin_src emacs-lisp
     ;; don't try to spell things in Org property drawers and code blocks
     ;; (add-to-list 'ispell-skip-region-alist '(":\\(PROPERTIES\\|LOGBOOK\\):" . ":END:"))
     ;; (add-to-list 'ispell-skip-region-alist '("#\\+begin_src" . "#\\+end_src"))
     ;; redefine the obsolete spell-word
     (defalias 'spell-word  'ispell-word)

     (defalias 'spell-buffer 'ispell-buffer)
   #+end_src
** CSV - Clumsy Stupid Varmint
   #+begin_src emacs-lisp
     (use-package csv-mode :straight t )
   #+end_src
** TTL - Ticky Tacky Lunacy
   #+begin_src emacs-lisp
     (use-package ttl-mode :straight t
       :init
       (add-to-list 'auto-mode-alist '("\\.\\(n3\\|ttl\\|trig\\)\\'" . ttl-mode))
       :config
       (setq ttl-indent-level 2))
   #+end_src
** YAML - You A Moth Licker
   #+begin_src emacs-lisp
     (use-package yaml-mode
       :straight t
       :hook (yaml-mode . (lambda () (yafolding-mode 1)
                            (toggle-truncate-lines 1))))
     (add-hook 'conf-mode-hook
               (lambda ()
                 (yafolding-mode 1)
                 (toggle-truncate-lines 1)))
   #+end_src
** Man pages
   Open man page in current window, rather than other window with
   #+begin_src emacs-lisp
     (custom-set-variables '(Man-notify-method 'pushy))
   #+end_src
** OpenVPN
   Mode to help using OpenVPN
   #+begin_src emacs-lisp :tangle /tmp/intothevoid.el
     (use-package ovpn-mode
       :straight t
       :custom
       (ovpn-mode-authinfo-path "~/.local/.authinfo.gpg")
       (ovpn-mode-base-directory "~/.config/openvpn/")
       (ovpn-mode-preferred-terminal "alacritty")
       :bind (:map ovpn-mode-map
                   (("n" . next-line)
                   ("p" . previous-line)
                   ("m" . ovpn-mode-start-vpn-with-namespace))))
   #+end_src
** Ag / The Silver Searcher/Surfer
   #+begin_src emacs-lisp
     (use-package ag  :straight t)
   #+end_src
** Denote - note taking
   + Prot's denote - on System Crafters [[https://systemcrafters.net/live-streams/july-15-2022/][System Crafters Live! - July 15, 2022 - System Crafters]]
   #+begin_src emacs-lisp
     (use-package denote
       :straight t
       :defer nil
       :init
       (defun gjg/denote-project () (interactive) (project-switch-project "~/gregj-notes"))
       :bind
       ("C-S-d" . gjg/denote-project)
       :config
       (setq denote-directory (expand-file-name "~/gregj-notes/"))
       (setq denote-known-keywords '("journal" "projects" "ideas"))
       ;; (setq denote-prompts '(title subdirectory))
       )
     (require 'denote)

     ;;(setq denote-dired-directories '("~/gregj-notes/"))
     ;; (add-to-list 'denote-dired-directories "~/gregj-notes/")
     (add-hook 'dired-mode-hook #'denote-dired-mode-in-directories)
     ;; (add-to-list 'denote-dired-directories (expand-file-name "~/gregj-notes/"))
     (custom-set-faces
      '(denote-faces-title
        ((t
          (:height 1.1 :weight semibold)))))

     (with-eval-after-load 'org-capture
       (add-to-list 'org-capture-templates
                    '("n" "New note (with Denote)" plain
                      (file denote-last-path)
                      #'denote-org-capture
                      :no-save t
                      :immediate-finish nil
                      :kill-buffer t
                      :jump-to-captured t)))



     ;; Denote templates
     (add-to-list 'denote-templates '(journal . "* Thoughts\n\n* Tasks\n" ) )

     ;; Here's a function for daily journal capture - compatible-ish with Logseq
     (defun gjg/denote-journal ()
       "Create an entry tagged 'journal' with the date as its title."
       (interactive)
       (denote
        (format-time-string "%Y-%m-%d")
        '("journal") ; multiple keywords are a list of strings: '("one" "two")
        nil          ; default Org file type
        (concat denote-directory "journals")
        nil          ; date - default to current-time
        'journal
        ))

   #+end_src
** Highlight indentation
   #+begin_src emacs-lisp
     (use-package highlight-indentation :straight t)
   #+end_src
* Org mode stuff

** Contributions package
   Add =ignore= tag to headlines you don't want to export
   Refer to [[https://emacs.stackexchange.com/a/17677/418][org mode - Is it possible to export content of subtrees without their heading...]]
   #+begin_src emacs-lisp
     (use-package org-contrib
       :straight t
       :config
       (require 'ox-extra)
       (ox-extras-activate '(ignore-headlines)))
   #+end_src
** Habits
   #+begin_src emacs-lisp
     (add-to-list 'org-modules 'org-habit t)
     (require 'org-habit)
     (setq org-habit-show-all-today t
           org-habit-show-done-always-green t
           org-habit-show-habits nil
           org-habit-graph-column 60
           ;; org-habit-completed-glyph 9989
           org-habit-preceding-days 7
           org-habit-following-days 2
           org-habit-show-done-always-green t
           org-habit-show-habits-only-for-today nil)
   #+end_src
** Org key mappings
   Disable some that get in the way
   #+begin_src emacs-lisp
     (with-eval-after-load 'org
       ;; little use for header COMMENT keyword
       (unbind-key (kbd "C-c ;") org-mode-map)       ; org-toggle-comment
       (unbind-key (kbd "C-c ;") org-mode-map)
       ;; don't accidentally archive things
       (unbind-key (kbd "C-c C-x C-a") org-mode-map) ; org-archive-subtree-default
       (unbind-key (kbd "C-c C-x C-s") org-mode-map) ; org-archive-to-subtree
       (unbind-key (kbd "C-c C-x A") org-mode-map)   ; org-archive-to-archive-sibling
       (unbind-key (kbd "C-c C-x a") org-mode-map)   ; org-toggle-archive-tag
       ;; remap the dangerous C-c C-w to avoid nuking regions
       (unbind-key (kbd "C-c C-r") org-mode-map)   ; org-reveal
       (unbind-key (kbd "C-c C-w") org-mode-map)     ; org-refile
       (bind-key (kbd "C-c C-r") 'org-refile org-mode-map)
       ;; keys that conflict with buffer movement
       (unbind-key (kbd "<M-right>") org-mode-map)   ; org-metaright
       (unbind-key (kbd "<M-left>") org-mode-map)    ; org-metaleft
       ;; keys that conflict with windmove package
       ;; (unbind-key (kbd "<S-up>") org-mode-map)       ; org-shiftup
       ;; (unbind-key (kbd "<S-down>") org-mode-map)     ; org-shiftdown
       ;; (unbind-key (kbd "<S-left>") org-mode-map)     ; org-shiftleft
       ;; (unbind-key (kbd "<S-right>") org-mode-map)    ; org-shiftright
       )
   #+end_src
** Org Babel and Source Code Blocks
*** Report time for code block execution
    + Ref: My answer on Emacs Stackexchange
       [[https://emacs.stackexchange.com/a/61357/418][timers - How to time org-mode code block execution? - Emacs Stack Exchange]]
    #+begin_src emacs-lisp :tangle no
      (defun gjg/time-call (time-call &rest args)
        (message "Ohai %s" args)
        (let ((start-time (float-time))
              (result (apply time-call args)))
          (message "Function call took %f seconds" (- (float-time) start-time))
          result))

      (advice-add 'org-babel-execute-src-block :around #'gjg/time-call)
    #+end_src
*** Config including template shortcuts
    TODO: install ob-jupyter package on systems with Jupyter
     #+begin_src emacs-lisp
       ;; (unless (version< org-version "9.2")
       ;;   (require 'org-tempo) ; required for Easy Templates since Org 9.2
       ;;   )
       (with-eval-after-load 'org
         (setq org-confirm-babel-evaluate nil
               org-export-with-sub-superscripts nil)

         ;; ;; The Dreadful Timeline has brought us indentation-sensitive languages
         ;; ;; Python, YAML, Heredoc seem to require that Org not format source code blocks
         ;; (setq org-src-preserve-indentation nil)
         (setq org-src-window-setup 'current-window)
         (setq org-structure-template-alist '(("C" . "comment")
                                              ("e" . "example")
                                              ("E" . "export")
                                              ("h" . "export html")
                                              ("l" . "export latex")
                                              ("\"" . "quote")
                                              ("qp" . "src sparql")
                                              ("qq" . "src sql")
                                              ("S" . "src")
                                              ("sc" . "src conf")
                                              ("sg" . "src sql :product gsql")
                                              ("sj" . "src json")
                                              ("sJ" . "src javascript")
                                              ("sl" . "src emacs-lisp")
                                              ("sp" . "src python")
                                              ("sP" . "src jupyter-python")
                                              ("sq" . "src sql")
                                              ("sr" . "src R")
                                              ("sR" . "src jupyter-R")
                                              ("ss" . "src bash")
                                              ("sy" . "src yaml"))))

     #+end_src
** Org num mode
   #+begin_src emacs-lisp :tangle /tmp/intothevoid.el
     ;; for use with org-num-mode
     (defun org-num-skip-top-level-format (numbering)
       "Number from subtree display function.
     NUMBERING is a list of numbers."
       (concat (mapconcat #'number-to-string (cdr numbering) ".") " "))
     (setq org-num-format-function 'org-num-skip-top-level-format)
   #+end_src
** Org Superstar - appearance of headers
   #+begin_src emacs-lisp
     (use-package org-superstar :straight t
       :hook
       (org-mode . org-superstar-mode))
   #+end_src
** Org-mode hook
   On =auto-fill-mode=: I prefer to have it on, but hate when
   creating links and having it wrap while typing the description.
   For this reason, I want to get in the habit of only adding links
   using =C-c C-l= (=org-insert-link=)

   #+begin_src emacs-lisp
     (add-hook 'org-mode-hook
           (lambda ()
             (auto-fill-mode 1)
             (highlight-regexp ":tangle no" 'hi-pink)
             (highlight-regexp ":tangle /tmp/intothevoid.el" 'hi-aquamarine)
             ;; (org-modern-mode 1)
             (setq org-hide-leading-stars t)
             (setq fill-column 90) ; good default for wide screens
             (setq org-use-property-inheritance t)
             (setq org-link-search-must-match-exact-headline nil)
             (org-defkey org-mode-map [(control tab)] 'org-next-link)
             ;; steal back my keys
             (org-defkey org-mode-map [home] 'beginning-of-buffer)
             (org-defkey org-mode-map [end] 'end-of-buffer)
             ;; 	    ;; (local-set-key (kbd "C-c TAB") 'org-next-link)
             ;; 	    ;; (local-set-key (kbd "S C-c TAB") 'org-previous-link)
             ;; 	    (abbrev-mode 1)
             ;; 	    ;; set sub/superscript interpretation OFFFFFFOOOFFF
             ;; 	    (setq org-use-sub-superscripts nil)
             (setq org-catch-invisible-edits 'show-and-error )))
   #+end_src
** Org tree to indirect
   This useful feature is hampered by poor naming of the resulting buffer, making it very
   difficult to know whether you are editing the original buffer or the created indirect
   buffer.

   There are no user variables that influence the indirect buffer naming, and no hooks
   defined for any function related to =org-tree-to-indirect-buffer=

   It therefore seems the only way to affect it is to advise a function.

   #+begin_src emacs-lisp :tangle /tmp/intothevoid.el
     (defun gjg/rename-org-indirect-buffer (orig-fun &rest arg)
       (rename-buffer (concat "INDIRECT-" (buffer-name))))

     (advice-add 'org-tree-to-indirect-buffer :after 'gjg/rename-org-indirect-buffer)


   #+end_src
** Blogs - linking and image additions
   For blogging especially, we want to quickly add web links and images.  2 packages from
   m?elpa help here
   #+begin_src emacs-lisp
     (use-package org-cliplink :straight t)
     (use-package org-download :straight t)
   #+end_src

   And here's a handy keyboard macro =gjg/url-grab-cliplink=

   Assume point is in an Org file, and there are two windows in the current frame *and*
   the other window is a Web browser (this only works in EXWM!).  Go to the browser
   window, copy the URL, then use =org-cliplink= at the starting point in the original Org window.

   #+begin_src emacs-lisp :tangle /tmp/intothevoid.el
   (fset 'gjg/url-grab-cliplink
   (kmacro-lambda-form [?\C-x ?o ?\C-l ?\M-w tab ?\C-x ?o ?\M-x ?o ?r ?g ?- ?c ?l ?i ?p ?l ?i ?n ?k return] 0 "%d"))
   #+end_src

** Capture Templates
*** Functions to support capture templates
**** Bring in nicely formatted links to be used in the phone log capture template
      These entries are in a table in each customer engagement Org file named =people=

      #+begin_src emacs-lisp
        (defun gjg/annotate-person (s)
          "Provide annotations for completing-read using the data in a \"person\" table as used in my work files"
          (let ((item (assoc s minibuffer-completion-table)))
            (when item (concat
                        (string-pad "" (- 40 (string-width (nth 0 item) )))
                        (nth 2 item)
                        (if (string-empty-p (nth 4 item)) "" (concat " (" (nth 4 item) ")"))
                        ))))

        (defun gjg/add-person-from-table (table)
          "Add person from table to an Org unordered list - used with phone log capture template"
          (let* ((marginalia-align-offset 80)
                 (completion-extra-properties '(:annotation-function gjg/annotate-person))
                 (myperson (assoc (completing-read "Person: " table) table))
                 (myname (nth 0 myperson))
                 (title (nth 2 myperson))
                 (linkedin (nth 1 myperson))
                 (company (nth 4 myperson))
                 (location (nth 3 myperson)))

            ;; Name Title (Company) Location
            (format "+ %s - %s %s - %s"
                    (if (string-empty-p linkedin)
                        myname
                      (concat "[[" linkedin "][" myname "]]"))
                    title
                    (if (string-empty-p company)
                        ""
                      (concat "(" company ")"))
                    location)))
      #+end_src
**** Create new blog post file for blog capture
    #+begin_src emacs-lisp
      ;; *** Org capture
      ;; taken from StackOverflow answer https://stackoverflow.com/questions/11902620/org-mode-how-do-i-create-a-new-file-with-org-capture
      ;; (defun capture-blog-filename (path)
      (defun safe-blog-filename ()
        (let ((thedate (org-read-date nil nil nil "Date of post: "))
              (name (read-string "Blog post title: ")))
          (setq gjg/blogpost-title name)
          (expand-file-name (format "%s-%s.org"
                                    (format-time-string "%Y-%m-%d")
                                    (downcase
                                     (replace-regexp-in-string "-+$" ""
                                                               (replace-regexp-in-string "[^[:alnum:]]+" "-"
                                                                                         (replace-regexp-in-string "[[:punct:]]" "" name)))))
                            "~/projects/blogs/hypecyclist/content/post/"
                            )))
    #+end_src
*** Variables and hook setup
    I want to always be prompted to refile my corporate phone log - so I remap =C-c C-c=
    for only that capture template.
    #+begin_src emacs-lisp
      (setq org-default-notes-file "~/projects/notes.org")
      ;; (with-eval-after-load 'org-capture
      ;;   ;; (add-hook 'org-capture-mode-hook 'turn-on-auto-fill)
      ;;   (add-hook 'org-capture-mode-hook
      ;;             (lambda ()
      ;;               (let ((mykey (plist-get org-capture-plist :key)))
      ;;                 (if (string= "p" mykey )
      ;;                     (define-key org-capture-mode-map (kbd "C-c C-c") 'org-capture-refile)
      ;;                   (define-key org-capture-mode-map (kbd "C-c C-c") 'org-capture-finalize))))))
      (define-key global-map "\C-cc" 'org-capture)
      (setq org-capture-templates nil) ; initialize to nil prior to grand setup below
    #+end_src

*** Template definitions
   + N.B. First set up org-protocol (require the library) prior to using the related
     capture templates.  I'm not doing it at the moment because I can use the JS clip
     extension from ChromeOS (no =emacsclient= binary on Chrome OS, just in a Linux
     container I cannot reach)

**** Blog post
     Start a new blog post for hypecyclist.org using my default Hugo template
     #+begin_src emacs-lisp
       (push
        '("b" "Blog post" plain
                     (file safe-blog-filename)
                     (file "~/.emacs.d/hugo-default-blog.tmpl")
                     :jump-to-captured t)
        org-capture-templates)
     #+end_src

**** org-protocol capture - will I ever ever ever use this again??
     #+begin_src emacs-lisp :tangle no
       (push '("c" "org-protocol-capture" entry "~/projects/private-orgmode/inbox.org"
               "* TODO [[%:link][%:description]]\n\n %i" :immediate-finish nil)
             org-capture-templates)
     #+end_src

**** Add items to a/the inbox - GTD style
     #+begin_src emacs-lisp
       (push
        '("i" "inbox" entry
          (file "~/projects/private-orgmode/inbox.org")
          "* TODO %?\n  :LOGBOOK:\n  CREATED: %U\n  :END:")
        org-capture-templates
        )
     #+end_src

**** Phone/meeting/task - the heart of it all
     TODO: Fix the disappearing clock in the original template definition

     #+begin_src emacs-lisp
       (push
        '("p" "Phone/Meeting" entry
          (file+headline gjg/employer-org-file "Calls and Meetings")
          "* %t %^{type|Call|Meeting|Task} with %^{with|Solutions Team|SE Team|Steven|Marketing|Sales|Engineering|South Sales Team|Central Sales Team}: %^{Subject|Sync-up|Stand-up|Team|Presentation|Intro|Weekly cadence|Learning Update|Working session|Status update}
         %i
         + Team: GG and %?
           \#+begin_src emacs-lisp :var table=people :results append raw :exports results :eval never-export
            (gjg/add-person-from-table table)
           \#+end_src
       ,** Notes
         +
       ,** Next steps
       " :prepend t :clock-in t :clock-keep t :jump-to-captured t) org-capture-templates)
     #+end_src

**** Clock in to a new work "t"ask
     #+begin_src emacs-lisp
       (push
        '             ("t" "Task - clock in using work file" entry
                       (file+headline gjg/employer-org-file "Tasks")
                       "* TODO %^{task description} \n  :LOGBOOK:\n  CREATED: %U\n  :END:\n%i\n   %?"
                       :prepend t :time-prompt nil :clock-in t :clock-keep t :jump-to-captured nil)
        org-capture-templates)
     #+end_src

**** Regular TODO
     #+begin_src emacs-lisp
       (push
        '             ("r" "Regular todo" entry
                       (file "~/projects/private-orgmode/inbox.org")
                       "* TODO %? \n  DEADLINE: %^T\n  :LOGBOOK:\n  CREATED: %U\n  :END:\n%i\n " :prepend nil :time-prompt t)
        org-capture-templates)
     #+end_src
** Exporting
*** General preferences
#+begin_src emacs-lisp
  (custom-set-variables '(org-export-with-sub-superscripts nil)
                        '(org-html-postamble nil))
#+end_src
*** Exporting Babel without evaluation
#+begin_src emacs-lisp
(custom-set-variables '(org-export-use-babel nil))
#+end_src
*** Export without theme interference
	:LOGBOOK:
	- State "DONE"       from "TODO"       [2020-01-14 Tue 10:40]
	- State "DONE"       from "STARTED"    [2020-01-14 Tue 10:40]
	- State "STARTED"    from "TODO"       [2019-09-17 Tue 19:37]
	:END:
	Wrap advice around any means of exporting HTML, including export-and-open
#+begin_src emacs-lisp
  (use-package material-theme :straight t)
  (use-package ox-gfm :straight t)
  (use-package htmlize :straight t)
  ;; export to html - use light theme for export
  ;; tip o' the hat to legoscia https://github.com/legoscia/dotemacs/blob/master/dotemacs.org#theme-for-org-html-export
  (defvar my-org-html-export-theme 'material-light)

  (defun my-with-theme (orig-fun &rest args)
    (load-theme my-org-html-export-theme)
    (unwind-protect
        (apply orig-fun args)
      (disable-theme my-org-html-export-theme)))

  (with-eval-after-load "ox-html"
    (advice-add 'org-export-to-buffer :around 'my-with-theme)
    (advice-add 'org-export-to-file :around 'my-with-theme))
#+end_src
** Speed commands
   The square bracket "show heading tidily" shortcuts can be used as a flexible
   slide show presentation
   #+begin_src emacs-lisp
     (setq org-use-speed-commands t) ;; POWER USER BABY
     ;; (setq org-speed-commands-user
     ;;       '(
     ;;         ("," . org-columns)
     ;;         ("q" . bury-buffer)))
     ;; DAN DAVISON nifty speed commands
     (defun ded/org-show-next-heading-tidily ()
       "Show next entry, keeping other entries closed."
       (interactive)
       (widen)
       (if (save-excursion (end-of-line) (outline-invisible-p))
	   (progn (org-show-entry) (outline-show-children))
	 (outline-next-heading)
	 (unless (and (bolp) (org-at-heading-p))
	   (org-up-heading-safe)
	   (outline-hide-subtree)
	   (error "Boundary reached"))
	 (org-overview)
	 (org-reveal t)
	 (org-show-entry)
	 (outline-show-children)
	 (org-narrow-to-subtree)))

     (defun ded/org-show-previous-heading-tidily ()
       "Show previous entry, keeping other entries closed."
       (interactive)
       (widen)
       (let ((pos (point)))
	 (outline-previous-heading)
	 (unless (and (< (point) pos) (bolp) (org-at-heading-p))
	   (goto-char pos)
	   (outline-hide-subtree)
	   (error "Boundary reached"))
	 (org-overview)
	 (org-reveal t)
	 (org-show-entry)
	 (outline-show-children)
	 (org-narrow-to-subtree)))

     (add-to-list 'org-speed-commands
	      '("]" ded/org-show-next-heading-tidily))
     (add-to-list 'org-speed-commands
	      '("[" ded/org-show-previous-heading-tidily))
     (add-to-list 'org-speed-commands
		  '("s" save-buffer))
     (add-to-list 'org-speed-commands
		  '("d" org-toggle-narrow-to-subtree))



     ;; END DAN DAVISON nifty speed commands

   #+end_src
** Org Agenda
*** Initialize Org Agenda
   #+begin_src emacs-lisp
     (require 'org-agenda)
     (setq org-agenda-custom-commands nil)
   #+end_src
*** Set up agenda files lists
    I keep one set of agenda files for personal / everyday use and another for work use.

    For work files, the rules are:
    + include the primary working file (e.g. mycompany.org.gpg)
    + include all all task files under the active engagements directory
      (e.g. ./mycompany/engagements/customer1/customer1.org.gpg)
    + Active task files are either any encrypted org file under engagements/ or the single
      unencrypted org file named for its containing directory
      (e.g. ./mycompany/engagements/customer2/customer2.org)
    + include the special case =inbox.org=

  #+begin_src emacs-lisp
    ;; Make sure we match encrypted files for Agenda
    ;; ref https://emacs.stackexchange.com/a/36543/418
    (unless (string-match-p "\\.gpg" org-agenda-file-regexp)
      (setq org-agenda-file-regexp
            (replace-regexp-in-string "\\\\\\.org" "\\\\.org\\\\(\\\\.gpg\\\\)?"
                                      org-agenda-file-regexp)))
    (global-set-key (kbd "C-c a") 'org-agenda)
    (setq gjg/org-agenda-directory "~/projects/private-orgmode/")
    (setq gjg/personal-org-agenda-files '("~/projects/private-orgmode/notes.org"
                                          "~/projects/private-orgmode/inbox.org"
                                          "~/projects/private-orgmode/someday.org"
                                          "~/projects/private-orgmode/projects.org"
                                          "~/projects/private-orgmode/habits.org"))
    (defun gjg/get-work-agenda-files ()
      "Return list of work agenda files exculding archive/ dir.  Can be called in :scope param of clocktable"
      (let ((engagement-files (directory-files-recursively (concat (f-dirname gjg/employer-org-file) "/engagements/")
                                                           "\\`[^.].*\\.org\\(\\.gpg\\)?\\'")))
        (add-to-list 'engagement-files gjg/employer-org-file t)
        (add-to-list 'engagement-files "~/projects/private-orgmode/inbox.org" t)))
        ;; (add-to-list 'engagement-files "~/projects/private-orgmode/projects.org" t)))
    (add-to-list 'gjg/agenda-contexts-alist `(work ,(gjg/get-work-agenda-files)))
    (add-to-list 'gjg/agenda-contexts-alist `(home ,gjg/personal-org-agenda-files))
    (add-to-list 'gjg/agenda-contexts-alist `(fitness ,(list "~/projects/private-orgmode/fitness.org")))
    (add-to-list 'gjg/agenda-contexts-alist `(notes ,(list "~/gregj-notes/")))



    (setq gjg/work-agenda-files (gjg/get-work-agenda-files))
    ;; Set agenda files to personal, override in work-related templates
    (setq org-agenda-files gjg/personal-org-agenda-files)
  #+end_src
*** Set icons for agenda views
    These work by =category=
**** Resize icons to be used in agenda views
      Resize icons for use in agenda views to be square - helps with column alignment
      #+begin_src bash
        i=my-/where/ever/icon.png
        j=$(basename $i)
        convert -resize 512x512 $i -background transparent -gravity center -extent 512x512  ~/emacs/pixmaps/$j-512x512.png; done

      #+end_src
**** Set icon definitions by category
     #+begin_src emacs-lisp
       ;;(setq org-agenda-span 'day)
       ;;(setq org-agenda-skip-scheduled-if-done t)
       ;; (setq org-agenda-start-with-log-mode t)
       ;; (setq org-agenda-start-with-clockreport-mode nil)
       (setq org-agenda-category-icon-alist
             `(
               ("emacs" "~/emacs/pixmaps/emacs-512x512.png" nil nil :ascent center :height 32)
               ("Stardog" "~/emacs/pixmaps/stardog-logo-512x512.png" nil nil :ascent center :height 32)
               ("notes" "~/emacs/pixmaps/mindmap-icon-512x512.png" nil nil :ascent center :height 32)
               ("work-habit" "~/emacs/pixmaps/gtd-logo-2019-512x512.png" nil nil :ascent center :height 32)
               ("linux" "~/emacs/pixmaps/linux-color-512x512.png" nil nil :ascent center :height 32)
               ("music" "~/emacs/pixmaps/banjo-transparent-512x512.png" nil nil :ascent center :height 32)
               ("networking" "~/emacs/pixmaps/network-wired-512x512.png" nil nil :ascent center :height 32)
               ;; ("inbox" ,(list (all-the-icons-material "inbox" )) nil nil :ascent center :height 32)
               ("languages" ,(list (all-the-icons-fileicon "moment-tz" )) nil nil :ascent center :height 32)
               ("Chubb" "~/emacs/pixmaps/Chubb-Logo-1985-512x512.png" nil nil :ascent center :height 32)
               ("john deere" "~/emacs/pixmaps/tractor-flat-512x512.png" nil nil :ascent center :height 32)
               ("PicPay" "~/emacs/pixmaps/picpay-logo-512x512.png" nil nil :ascent center :height 32)
               ("guidehouse" "~/emacs/pixmaps/guidehouse-logo-512x512.png" nil nil :ascent center :height 32)
               ("optum" "~/emacs/pixmaps/optum-logo-512x512.png" nil nil :ascent center :height 32)
               ("inbox" "~/emacs/pixmaps/office-inbox-512x512.png" nil nil :ascent center :height 32)
               ("social" "~/emacs/pixmaps/icon-social-events-512x512.png" nil nil :ascent center :height 32)
               ("fitness" "~/emacs/pixmaps/fitness-heart-512x512.png" nil nil :ascent center :height 32)
               ("gwennie" "~/emacs/pixmaps/loon-512x512.png" nil nil :ascent center :height 32)
               ("finances" "~/emacs/pixmaps/finances-512x512.png" nil nil :ascent center :height 32)
               ))
       (setq org-agenda-sticky t
             org-agenda-fontify-priorities t
             org-agenda-hide-tags-regexp "noagenda"
             org-agenda-restore-windows-after-quit t
             -agenda-entry-text-maxlines 10
             org-agenda-diary-file "~/projects/private-orgmode/diary.org"
             org-agenda-include-diary t
             org-special-ctrl-a/e t
             org-agenda-clockreport-parameter-plist '(:link t :maxlevel 99)
             org-cycle-separator-lines 1
             org-clock-history-length 12)

       (setq org-agenda-exporter-settings
             '((ps-number-of-columns 1)
               (ps-landscape-mode t)
               (org-agenda-add-entry-text-maxlines 10)
               (htmlize-output-type 'css)))

      #+end_src
**** Test icons for alignment and um .... prettiness
     Test the icons set in
     #+begin_src org :tangle /tmp/test-icons.org
       ,* Ohai
         Use this to check icons and alignment in a TODO agenda buffer narrowed to this file

       ,* TODO check a thing
         :PROPERTIES:
         :CATEGORY: emacs
         :END:
       ,* TODO check a thing
         :PROPERTIES:
         :CATEGORY: Stardog
         :END:
       ,* TODO check a thing
         :PROPERTIES:
         :CATEGORY: notes
         :END:
       ,* TODO check a thing
         :PROPERTIES:
         :CATEGORY: work-habit
         :END:
       ,* TODO check a thing
         :PROPERTIES:
         :CATEGORY: linux
         :END:
       ,* TODO check a thing
         :PROPERTIES:
         :CATEGORY: music
         :END:
       ,* TODO check a thing
         :PROPERTIES:
         :CATEGORY: networking
         :END:
       ,* TODO check a thing
         :PROPERTIES:
         :CATEGORY: languages
         :END:
       ,* TODO check a thing
         :PROPERTIES:
         :CATEGORY: Chubb
         :END:
       ,* TODO check a thing
         :PROPERTIES:
         :CATEGORY: john deere
         :END:
       ,* TODO check a thing
         :PROPERTIES:
         :CATEGORY: PicPay
         :END:
       ,* TODO check a thing
         :PROPERTIES:
         :CATEGORY: guidehouse
         :END:
       ,* TODO check a thing
         :PROPERTIES:
         :CATEGORY: optum
         :END:
       ,* TODO check a thing
         :PROPERTIES:
         :CATEGORY: inbox
         :END:
       ,* TODO check a thing
         :PROPERTIES:
         :CATEGORY: social
         :END:
       ,* TODO check a thing
         :PROPERTIES:
         :CATEGORY: fitness
         :END:
       ,* TODO check a thing
         :PROPERTIES:
         :CATEGORY: gwennie
         :END:
       ,* TODO check a thing
         :PROPERTIES:
         :CATEGORY: finances
         :END:
     #+end_src
*** Custom Agenda definitions
**** Cross-context agendas
***** Basic Agenda with work habits added
     #+begin_src emacs-lisp
       (add-to-list 'org-agenda-custom-commands
                    '("A" "Agenda + work habits"
                      (
                       (agenda "" ((org-agenda-span 'day)
                                   (org-agenda-sorting-strategy
                                    (quote ((agenda time-up priority-down tag-up))))
                                   ;; (org-agenda-category-filter-preset (list "-work-habit"))
                                   (org-agenda-files (cons "~/projects/private-orgmode/work-habits.org" gjg/personal-org-agenda-files))
                                   (org-deadline-warning-days 0)))
                       )) t)
     #+end_src
***** Notes/Roam/Denote TODOs
      TODO: make category section of agenda the value of keywords in the front matter
      #+begin_src emacs-lisp
        ;; for example, category would be "linux-steam-deck"
        ;; (mapconcat 'identity (mapcar #'substring-no-properties org-file-tags) "-")
        ;; (string-join (mapcar #'substring-no-properties org-file-tags) "-")
        ;; use just org files in the notes directory
        (add-to-list 'org-agenda-custom-commands '("n" . "Notes prefix key")) ; describe prefix
        (add-to-list 'org-agenda-custom-commands
                     '("na" "Notes agenda"
                       ((agenda "" (
                                    (org-agenda-files '("/home/gregj/gregj-notes/"))
                                    (org-agenda-span 'week)
                                    )
                                ))
                       ) t)
        (add-to-list 'org-agenda-custom-commands
                     '("nt" "Zettelkastenistische Note TODOs" todo ""
                       ((org-agenda-files '("/home/gregj/gregj-notes/"))
                        (org-agenda-overriding-header "TODO items from Zettelkasten/Denote/Roam notes")
                        ;; (org-agenda-prefix-format "")
                        )))
      #+end_src
**** Work agendas
***** The big (W)ork agenda
       These views use the work files

       TODO  why does starting with clocktable and/or log-mode not work??
       #+begin_src emacs-lisp
         (add-to-list 'org-agenda-custom-commands
                      '("W" "Work Agenda"
                        (
                         ;; Work / Laptop Habits section
                         (agenda ""
                                 ((org-agenda-files '("~/projects/private-orgmode/work-habits.org"))
                                  (org-agenda-start-with-log-mode nil)
                                  (org-agenda-start-with-clockreport-mode nil)
                                  (org-agenda-overriding-header "Work/Laptop Morning Tasks")))
                         ;; Work agenda with clocked time
                         (agenda ""
                                 ((org-agenda-span 'day)
                                  (org-agenda-files gjg/work-agenda-files)
                                  (org-agenda-start-with-log-mode '(clock))
                                  (org-deadline-warning-days 2)
                                  (org-agenda-start-with-clockreport-mode t)
                                  (org-agenda-start-with-log-mode t)
                                  )
                                 )
                         ;; TODOs for Stardog and prospects/customers
                         (todo ""
                               ((org-agenda-span 'day)
                                (org-agenda-files gjg/work-agenda-files)
                                (org-agenda-overriding-header "Stardog and customer TODOs")
                                (org-deadline-warning-days 21)
                                ))
                         ))
                      t)
       #+end_src
***** special filtering
      #+begin_src emacs-lisp
        (add-to-list 'org-agenda-custom-commands '("p" . "Priority filtered TODO"))
        (add-to-list 'org-agenda-custom-commands
                     '("pa" "#A Priority" todo ""
                       ((org-agenda-entry-types '(:scheduled))
                        (org-agenda-skip-function '(org-agenda-skip-entry-if 'notregexp "\\[#A\\]")))))
        (add-to-list 'org-agenda-custom-commands
                     '("pb" "#B Priority" todo ""
                       ((org-agenda-entry-types '(:scheduled))
                        (org-agenda-skip-function '(org-agenda-skip-entry-if 'notregexp "\\[#B\\]")))))
        (add-to-list 'org-agenda-custom-commands
                     '("pc" "#C Priority" todo ""
                       ((org-agenda-entry-types '(:scheduled))
                        (org-agenda-skip-function '(org-agenda-skip-entry-if 'notregexp "\\[#C\\]")))))

      #+end_src
**** Home based agendas
***** Fitness and @home
      #+begin_src emacs-lisp
        ;; TODO Filter on fitness tag
        (add-to-list 'org-agenda-custom-commands
                     '("f" "Fitness"
                       ((agenda "" (
                                    (org-agenda-span 'day)
                                    (org-agenda-files "~/projects/private-orgmode/fitness.org"))))) t)
        (add-to-list 'org-agenda-custom-commands
                     '("h" "thing TODO at Home"
                       (
                        (agenda "" ((org-agenda-span 'day)
                                    (org-agenda-sorting-strategy
                                     (quote ((agenda time-up priority-down tag-up))))
                                    (org-agenda-category-filter-preset (list "-habits"))
                                    (org-agenda-files (cons "~/projects/private-orgmode/work-habits.org" gjg/personal-org-agenda-files))
                                    (org-deadline-warning-days 0)))
                        (tags-todo "+dailies+SCHEDULED<=\"<today>+1\"" ((org-agenda-files gjg/personal-org-agenda-files)))
                        (tags "reading")
                        (tags "writing")
                        (tags-todo "refile"))
                       ((org-agenda-tag-filter-preset '("-project" "-@office"))
                        )) t)

        (add-to-list 'org-agenda-custom-commands
                     '("i" "Inbox review"
                       ((todo "TODO"
                              ((org-agenda-overriding-header "Review and Refile")
                               (org-agenda-files '(,(concat gjg/org-agenda-directory "inbox.org"))))))) t)
      #+end_src
***** Started/Paused/Waiting personal tasks
      #+begin_src emacs-lisp
      ;; (add-to-list 'org-agenda-custom-commands
      ;; '("P" "Projects" tags "Project|project|PROJECT" ((org-use-tag-inheritance nil))))

      (add-to-list 'org-agenda-custom-commands
                   '("S" "Started Tasks" todo "STARTED" ((org-agenda-todo-ignore-with-date nil))))

      (add-to-list 'org-agenda-custom-commands
                   '("w" "Tasks waiting on something" tags "WAITING|PAUSED" ((org-use-tag-inheritance nil))))

      #+end_src
*** Agenda hooks setup
    #+begin_src emacs-lisp
      ;; org-agenda: some handy keys
      ;; you might also want to set:
      (setq org-agenda-skip-unavailable-files t)
      (add-hook 'org-agenda-mode-hook
                (lambda ()
                  ;; undo the horrendous "o" key binding (bound to 'delete-other-windows)
                  ;;       (local-unset-key "o")
                  ;; rebind to a sweet and beautiful function
                  (org-defkey org-agenda-mode-map "o" 'org-agenda-show)
                  (yafolding-mode 1)
                  (local-unset-key "a") ;; don't let this accidentally archive a tree!
                  ;; "R" is used for clock report by default
                  ;; (define-key org-agenda-mode-map "R" 'org-agenda-refile)
                  (define-key org-agenda-mode-map "'" 'org-agenda-clockreport-mode)
                  (define-key org-agenda-mode-map  "g" 'org-agenda-redo) ;; instead of org-agenda-redo-all
                  ;; (define-key org-agenda-mode-map "h" 'org-habit-toggle-display-in-agenda)
                  ))
      (add-hook 'org-export-preprocess-hook
                (lambda ()
                  (org-dblock-update 2) ;; update all dynamic blocks in the buffer
                  ))
      ;; Function stolen from Bernt Hansen on gmane.emacs.orgmode: insert inactive time stamp for new entries

      (setq org-agenda-format-date
            (concat "%Y-%m-%d %a "
                    (make-string (- (window-width) 15) (string-to-char "_"))))

   #+end_src
*** Clock table
    #+begin_src emacs-lisp :tangle /tmp/intothevoid.el
      ;; First set clock summary to *not* show hours as days
      ;; ref: https://stackoverflow.com/a/54376827/457574
      (setq org-duration-format (quote h:mm))

      (setq org-clocktable-defaults
            '(:maxlevel 2
                 :lang "en"
                 :scope file
                 :block nil
                 :wstart 1
                 :mstart 1
                 :tstart nil
                 :tend nil
                 :step nil
                 :stepskip0 nil
                 :fileskip0 t
                 :tags nil
                 :match nil
                 :emphasize t
                 :link t
                 :narrow 75!
                 :indent t
                 :hidefiles nil
                 :formula nil
                 :timestamp nil
                 :level nil
                 :tcolumns nil
                 :formatter nil)
            )
    #+end_src
*** Agenda context
    This is something to help separate work time.

    No dependency on Org or Org Agenda being loaded

    #+begin_src emacs-lisp
      (let* ((thetime (decode-time))
             (dow (nth 6 thetime))
             (hour (nth 2 thetime)))
        (if (and (< dow 6) (> hour 7) (< hour 18))
            (gjg/select-agenda-context 'work)
          (gjg/select-agenda-context 'home)))
    #+end_src

** Tags/TODOs/Projects Oh My
   #+begin_src emacs-lisp
     (setq org-tag-persistent-alist
	   '(("habit")
	     ("billable")
	     ("noexport" . ?x)
	     ))
     (setq org-tag-alist '(("project" . ?p)
			   ("NEXT" . ?n)
			   ("noexport" . ?x)
			   ("cloud" . ?c)
			   (:startgroup . nil)
			   ("@customer")
			   ("@office" . ?o)
			   ("@home" . ?h)
			   ("@errands" . ?e)
			   ("@happy-hour")
			   (:endgroup . nil)
			   ("maybe-someday" . ?m)
			   ("writing" . ?w)
			   ))
     ;; Projects are identified by a :Project: tag unless they are marked DONE;
     ;;   Any project must have one sub-task identified by :NEXT: to be considered un-stuck
     ;;   MAYBE: exclude special tags like Someday/Maybe
     (setq org-stuck-projects '("Project|project/-DONE"
				nil
				("NEXT")
				""))
     (setq org-columns-default-format "%TODO %CATEGORY %60ITEM(Task)%5Effort(Estim){:} %5CLOCKSUM(Clock) %SCHEDULED(Time) %DEADLINE")
     (setq org-todo-keywords (quote ((sequence "TODO(t)" "STARTED(s!)" "PAUSED(p!)" "|" "DONE(d!)")      ;; ordinary sequence is Todo -> Started -> Done
				     (sequence "WAITING(w@/!)" "MAYBE(m!)" "NEXT(n!)" "OPEN(O@)" "|" "CANCELLED(c@/!)" "SUBMITTED(S)") ;; "oddball" states that any task may be set to
				     ;; (sequence "QUOTE(q!)" "QUOTED(Q!)" "|" "APPROVED(A@)" "EXPIRED(E@)" "REJECTED(R@)")     ;; sequence for quotes
				     )))
     ;; (setq org-todo-keyword-faces
     ;;       '(("TODO"
     ;;          (:foreground "#ff39a3" :weight bold))
     ;;         ("STARTED" . "#E35DBF")
     ;;         ("CANCELLED" :foreground "green" :weight bold :strike-through t)
     ;;         ("PROPOSED" . "pink")
     ;;         ("PAUSED"  . "yellow")
     ;;         ("WAITING" . "yellow")))

     ;; (setq org-todo-state-tags-triggers
     ;;       (quote (("CANCELLED" ("CANCELLED" . t))
     ;; 	      ("WAITING" ("WAITING" . t) ("NEXT"))
     ;; 	      ("SOMEDAY" ("WAITING" . t))
     ;; 	      (done ("NEXT") ("WAITING"))
     ;; 	      ("TODO" ("WAITING") ("CANCELLED"))
     ;; 	      ("STARTED" ("WAITING") ("NEXT" . t)))))
     ;; Change task state to STARTED when clocking in
     (setq org-clock-in-switch-to-state "STARTED")

     (setq org-tags-exclude-from-inheritance '("Project" "project" "interview2"))
					     ;(setq org-tag-alist '(("project" . ?p)("car" . ?c)))
   #+end_src
** Refile
   I think the best approach here is to use =org-agenda-files= as the source for refile
   targets.  Then set =org-agenda-files= to whatever is appropriate for current context -
   i.e., work vs home

   #+begin_src emacs-lisp
     ;; navigate to files using org-refile; use C-u C-c C-w
     (setq org-outline-path-complete-in-steps nil) ; use ivy/selectrum for quicker completion
     (setq gjg/refile-targets (seq-remove (lambda (elt) (string= "~/projects/private-orgmode/inbox.org" elt))
                                          (append gjg/personal-org-agenda-files gjg/work-agenda-files)))
     (setq org-refile-targets `((gjg/refile-targets :maxlevel . 2)
                                (,(directory-files-recursively denote-directory org-agenda-file-regexp) :maxlevel . 2))
           org-refile-use-outline-path 'file
           org-refile-target-verify-function
           (lambda ()
             (not (member "ARCHIVE" (org-get-tags)))))

     ;; (setcdr (assoc 'org-refile ivy-initial-inputs-alist) "")
     ;; (setcdr (assoc 'org-agenda-refile ivy-initial-inputs-alist) "")
     ;; (setcdr (assoc 'org-capture-refile ivy-initial-inputs-alist) "")

     (defun gjg/org-refile-goto ()
       "Call org-refile with arg to visit an org-mode location. A convenience function to bind to a global key."
       (interactive)
       (org-refile 1))


   #+end_src

** Clocking time
*** Variables and keys
    Keep =org-clock-persist= unset (its default) to avoid opening files that may have had
    clock activity - the problem in my case is that many of those files are encrypted so I
    have to enter a pass phrase just to open nearly any Org mode file!  The problematic
    code is in the =org-clock= library:
    #+begin_src emacs-lisp :tangle no
      (defun org-clock-load ()
        "Load clock-related data from disk, maybe resuming a stored clock."
        (when (and org-clock-persist (not org-clock-loaded))
          (if (not (file-readable-p org-clock-persist-file))
          (message "Not restoring clock data; %S not found" org-clock-persist-file)
            (message "Restoring clock data")
            ;; Load history.
            (load-file org-clock-persist-file)
            (setq org-clock-loaded t)
            (pcase-dolist (`(,(and file (pred file-exists-p)) . ,position)
                   org-clock-stored-history)
          (org-clock-history-push position (find-file-noselect file)))
      ...
    #+end_src
    #+begin_src emacs-lisp
      (setq org-clock-persist nil
            org-clock-string-limit 60 ; truncate very long clocked tasks
            org-clock-report-include-clocking-task t
            org-read-date-prefer-future 'time)
      ;; (org-clock-persistence-insinuate)
      ;; make the clock jump key global!
      (global-set-key (kbd "s-j") 'org-clock-goto)
    #+end_src
*** Clock in also to Harvest for work files
    + Goal - when clocking in on work tasks (org file is somewhere in
      ~/projects/private-orgmode/rancher), prompt for project/task to start timer for in
      Harvest also.

      TODO: Make =hcl= commands async
      #+begin_src emacs-lisp :tangle no
        (defun gjg/start-harvest-timer ()
          (interactive)
          (let ((harvest-alias
                 (completing-read
                  "Harvest project: "
                  (split-string
                   (concat "non-harvest,"
                           (string-trim (shell-command-to-string "hcl aliases"))) "[ ,]+"))))
                  ;; nil ; no predicate to limit choices
                  ;; nil ; do not require match
                  ;; "non-harvest")))
            (if (string= "@" (substring harvest-alias 0 1))
                (progn
                      (message (format "Clocking in to %s" harvest-alias))
                      (call-process-shell-command
                       (format "hcl start %s '%s'" harvest-alias org-clock-heading)
                       nil
                       "harvest-commands"))
              (message "Not clocking into Harvest"))))


        (defun gjg/stop-harvest-timer ()
          (interactive)
          (call-process-shell-command
           "hcl stop"
           nil
           "harvest-commands")
          (message "Stopped harvest timer (if any)"))

        ;; (add-hook 'org-clock-in-hook 'gjg/start-harvest-timer)
        ;; (add-hook 'org-clock-out-hook 'gjg/stop-harvest-timer)

                  ;; (message (format "Selected task is %s" org-clock-heading) )))
      #+end_src
** Behavior
#+begin_src emacs-lisp
  (setq org-adapt-indentation t
        org-agenda-window-setup 'current-window ; make c-y pay attention to current level
        org-yank-adjusted-subtrees t
        ;; org-yank-folded-subtrees nil
        org-insert-heading-respect-content t    ; new headings go AFTER CONTENT, even from the middle of content area
        org-indirect-buffer-display 'other-window
        org-reverse-note-order t                ; notes go at the top
        org-return-follows-link t
        org-treat-S-cursor-todo-selection-as-state-change nil ; use S-arrow without having to log state change!
        org-log-into-drawer t
        org-export-use-babel nil
        org-export-with-sub-superscripts nil
        org-html-extension "org.html"
        org-replace-disputed-keys t)
  ;; delete the seleted region when something is typed - don't do that
  (delete-selection-mode -1)

  ;; show only current/today's/all time in the clock task modeline
  ;; this SHOULD be settable on a file basis by using property CLOCK_MODELINE_TOTAL
  (setq org-clock-mode-line-total 'today)
  (setq org-loop-over-headlines-in-active-region t)
#+end_src
** Org Drill flashcards
#+begin_src emacs-lisp :tangle no
(defun gjg/org-drill-set-cloze1 ()
  "Set current question as `cloze1` type"
  (interactive)
  (insert ":PROPERTIES:\n:DRILL_CARD_TYPE: hide1cloze\n:END:\n")
  )

#+end_src

* Programming language modes

** All modes derived from =prog-mode=
   #+begin_src emacs-lisp
     (add-hook 'prog-mode-hook
               (lambda ()
                      (rainbow-delimiters-mode 1)
                 (corfu-mode 1)
                 (yafolding-mode 1)
                 (electric-pair-local-mode 1)))
   #+end_src

   Let's throw in IELM =inferior-emacs-lisp-mode=, which derives from =comint-mode=
   #+begin_src emacs-lisp
     (add-hook 'inferior-emacs-lisp-mode-hook
               (lambda ()
                 (rainbow-delimiters-mode 1)
                 (corfu-mode 1)
                 (electric-pair-local-mode 1)))

   #+end_src
** Language Servers and setup for LSP / Eglot
*** Language Servers
**** Bash
     #+begin_src bash
       sudo npm install --save-dev bash-language-server
     #+end_src
**** Go
     #+begin_src bash
       sudo apt -y install gopls
     #+end_src
**** Go
     #+begin_src bash
       go install golang.org/x/tools/gopls@latest
     #+end_src

**** JavaScript / TypeScript / Node.js
     #+begin_src bash
       sudo npm install --save-dev typescript-language-server
     #+end_src
**** Python
     #+begin_src bash
       sudo apt -y install python3-pyls
     #+end_src
**** R
     #+begin_src R
       install.packages("languageserver")
     #+end_src
**** SQL
     #+begin_src bash
       sudo npm i -g sql-language-server
     #+end_src
**** YAML
     #+begin_src bash
       sudo npm install --save-dev yaml-language-server
     #+end_src
*** Eglot
    Pretty sure I'll use this in future in favor of lsp-mode
    #+begin_src emacs-lisp
      (use-package eglot :straight t)
    #+end_src
** SPARQL
   #+begin_src emacs-lisp
     (use-package sparql-mode :straight t
       :mode "\\.\\(sparql\\|rq\\|sms\\|sms2\\)\\'"
       ;; :hook (sparql-mode . lsp-deferred)
       ;; :config
       ;; (add-to-list 'lsp-language-id-configuration '(sparql-mode . "sparql"))
       ;; :custom
       ;; (sparql-language-server)
       )
   #+end_src
   #+begin_src emacs-lisp
     ;; (add-to-list 'lsp-language-id-configuration '(".*\\.sparql" . "sparql"))
;;     (add-to-list 'lsp-language-id-configuration '(sparql-mode . "sparql"))
   #+end_src

** Clojure
   #+begin_src emacs-lisp
     ;; (add-hook 'cider-repl-mode-hook #'company-
     (use-package clojure-mode
       :straight t
       :mode "\\.clj[sc]?\\'"
       ;; :config
       ;; (add-hook 'clojure-mode-hook #'lispy-mode)
       )

     (use-package cider
       :mode "\\.clj[sc]?\\'"
       :straight t)
     ;; ;; (add-to-list 'load-path "~/emacs/cider")
     ;; (autoload 'cider "cider" "Cider for Clojure")
     ;; (require 'cider)
     ;; (eval-after-load "cider"
     ;;   '(progn
     ;;      ;; (require 'cider)
     ;;      ;; (defadvice cider--lein-present-p (around gjg-find-the-damn-script activate)
     ;;      ;;   "Lein shell script is not detected on Windows as executable"
     ;;      ;;   (if (eq window-system 'w32)
     ;;      ;;       (setq ad-return-value (or (file-remote-p default-directory)
     ;;      ;;    			     (locate-file "lein" exec-path nil 'exists)))
     ;;      ;;     (ad-do-it)))
     ;;      (add-hook 'cider-repl-mode-hook 'company-mode)
     ;;      (add-hook 'cider-mode-hook 'company-mode)))

   #+end_src
** Go
   Initial configuration was nabbed from a 2-parter by @tleydn
   [[http://tleyden.github.io/blog/2014/05/22/configure-emacs-as-a-go-editor-from-scratch/][Configure Emacs as a Go Editor From Scratch]]

   #+begin_src emacs-lisp :tangle no
     (use-package go-mode
       :defer t
       :straight t
       :custom
       :config
       (add-hook 'go-mode-hook (lambda () (add-hook 'before-save-hook 'ime-go-before-save)))
       (use-package go-autocomplete :straight t)
       (auto-complete-mode 1)
       (setenv "GOPATH" (expand-file-name "~/projects/coding/go/"))
       )
     ;; (setenv "GOPATH" (expand-file-name "~/projects/coding/go/"))
     ;; (defun my-go-mode-hook ()
     ;;   ; Use goimports instead of go-fmt
     ;;   (setq gofmt-command "goimports")
     ;;   ;; Call Gofmt before saving
     ;;   (add-hook 'before-save-hook 'gofmt-before-save)
     ;;   ;; jump into code with M-. and jump back with M-*
     ;;   (local-set-key (kbd "M-.") 'godef-jump)
     ;;   (local-set-key (kbd "M-*") 'pop-tag-mark)
     ;;   ;; Customize compile command to run go build
     ;;   ;; NOTE: may want to start with =go generate= for some projects
     ;;   (if (not (string-match "go" compile-command))
     ;;       (set (make-local-variable 'compile-command)
     ;;            "go build -v && go test -v && go vet"))
     ;;   ;; ; Go oracle/guru
     ;;   ;; (load-file "$GOPATH/src/golang.org/x/tools/cmd/oracle/oracle.el")
     ;;   ;; (load-file "$GOPATH/sr")
     ;;   (auto-complete-mode 1)
     ;;   )
     ;; (add-hook 'go-mode-hook 'my-go-mode-hook)
     ;; (with-eval-after-load 'go-mode
     ;;   (require 'go-autocomplete))
   #+end_src

** Rust
   + [[https://robert.kra.hn/posts/2021-02-07_rust-with-emacs/][Configuring Emacs for Rust development | Robert Krahn]]
   #+begin_src emacs-lisp :tangle no
     (use-package rust-mode
       :straight t)
   #+end_src

** Javascript
*** Prefer =js2= mode
   #+begin_src emacs-lisp :tangle no
     (use-package js2-mode
       :straight t
       :config
       (add-to-list 'auto-mode-alist '("\\.js$" . js2-mode)))
   #+end_src
*** Treat =.cue= as JSON or Bazel
    #+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("\\.cue$" . bazel-mode))

    #+end_src
** Python
*** LSP Language Server
    Just make sure the language server is installed before using LSP with Python
    #+begin_src bash
      pip install -U setuptools
      pip install python-lsp-server[all]
    #+end_src
*** Python mode setup
   #+begin_src emacs-lisp
     ;; Python

     (use-package python
       :straight t
       :custom
       (org-babel-python-command "python3")
       :config
       (setq python-shell-interpreter "ipython3"
             python-shell-interpreter-args "-i --simple-prompt")
       (setq org-babel-python-command "python3")
       (add-hook 'python-mode-hook
                 (lambda ()
                   (setq indent-tabs-mode nil)
                   (setq python-indent-offset 4)
                   (setq tab-width 4)
                   (pyvenv-mode t)))
       )
     (use-package pyvenv :straight t
       :config
       (setenv "WORKON_HOME" (expand-file-name "~/.local/python-venvs/") )
       )

     (custom-set-variables '(org-babel-python-command "python3"))

     ;; (setq ansi-color-drop-regexp
     ;;       "\033\\[\\([ABCDsuK]\\|[12][JK]\\|=[0-9]+[hI]\\|[0-9;]*[Hf]\\|\\?[0-9]+[hl]\\|[0-9]+[CD]\\|J\\|6n\\)")
   #+end_src
*** Treat Bazel/Starlark files as Python
    #+begin_src emacs-lisp
      (add-to-list 'auto-mode-alist '("\\.starlark$" . python-mode))
    #+end_src
** Jupyter
   + Interesting blog post: [[https://sqrtminusone.xyz/posts/2021-05-01-org-python/][Replacing Jupyter Notebook with Org Mode]]
     + consider setting =(org-babel-jupyter-override-src-block "python")=
     + consider =(setq ob-async-no-async-languages-alist '("python" "jupyter-python"))=
   +

   #+begin_src emacs-lisp :tangle no
     ;; (use-package jupyter
     ;;   :straight t
     ;;   )
     ;; config from https://martinralbrecht.wordpress.com/2020/08/23/conda-jupyter-and-emacs/
     (use-package jupyter
       :straight t
       :commands (jupyter-run-server-repl
                  jupyter-run-repl
                  jupyter-server-list-kernels)
       :init (eval-after-load 'jupyter-org-extensions ; conflicts with my helm config, I use <f2 #>
               '(unbind-key "C-c h" jupyter-org-interaction-mode-map)))
     ;; (use-package ob-ipython ; abandoned project https://github.com/syl20bnr/spacemacs/issues/9941#issuecomment-543227397
     ;;   :straight t)
     ;; (use-package ein :straight t)
     ;; (when (memq window-system '(mac ns x))
     ;;   (exec-path-from-shell-initialize))
   #+end_src
** R
   #+begin_src emacs-lisp :tangle no
     (use-package polymode :straight t
       :config
       (add-to-list 'auto-mode-alist '("\\.Snw" . poly-noweb+r-mode))
       (add-to-list 'auto-mode-alist '("\\.Rnw" . poly-noweb+r-mode))
       (add-to-list 'auto-mode-alist '("\\.Rmd" . poly-markdown+r-mode)))
     (use-package ess :straight t
       :config
       (setq ess-sas-edit-keys-toggle nil)
       :init (require 'ess-site))
   #+end_src
** Scheme
   Setup for Guile Scheme - primarily for use on Guix system
   #+begin_src emacs-lisp :tangle no
     (use-package geiser
       :straight t
       :config
       (setq geiser-default-implementation 'guile
             geiser-active-implementations '(guile)
             ;; geiser-repl-default-port 44555 ; for Gambit Scheme (from @daviwil)
             ))
     (use-package geiser-guile :straight t)
   #+end_src
** SQL and even GSQL
*** Format SQL
    Emacs doesn't come out of the box with a useful SQL formatter, so go ahead and use an
    external process

    Ref https://emacs.stackexchange.com/a/35683/418

    #+begin_src bash
      pip3 install sqlparse
    #+end_src

    #+begin_src emacs-lisp :tangle no
      (defun gjg/sqlparse-region (beg end)
        (interactive "r")
        (shell-command-on-region
         beg end
         "python -c 'import sys, sqlparse; print(sqlparse.format(sys.stdin.read(), reindent=True))'"
         t t))
    #+end_src

*** MySQL / MariaDB

    + Assure that client prompt is recognized for both products
   #+begin_src emacs-lisp
     ;; (add-hook 'sql-interactive-mode-hook (lambda ()
     ;;                                        (setq sql-prompt-regexp "\\(Maria[BD]*\\|MySQL\\) [^\\>]+\\>")
     ;;                                        ))
     (with-eval-after-load 'sql
       ;; (sql-set-product-feature 'mysql :prompt-regexp "^\\(MariaDB\\|[Mm][Yy][Ss][Qq][Ll]\\) *\\[?[\\[\\]]]_a-zA-Z0-9()]*\\]?> ")
       (sql-set-product-feature 'mysql :prompt-regexp
                                "^\\(MariaDB\\|MySQL\\|mysql\\) \\[[\\(\\)_a-zA-Z]*\\]> ")
       (setq sql-mysql-options '("-C" "-t" "-f" "-n"))
       (sql-set-product-feature 'sqlite :prompt-regexp
                                "^\\(sqlite\\|\\|mysql\\) *\\[[\\(\\)_a-zA-Z]*\\]> ")
       )
   #+end_src
   + Allow for alternative port
     #+begin_src emacs-lisp
       (setq sql-mysql-login-params '(user password server database port))
       (setq sql-port 3306)
     #+end_src

*** Postgresql
    + Allow for alternative port
     #+begin_src emacs-lisp :tangle no
       (setq sql-postgres-login-params '(user password server database port))
       ;; (setq sql-port 3306)
     #+end_src
*** GSQL for TigerGraph
    Working on syntax highlighting for GSQL
    #+begin_src emacs-lisp :tangle no
      (load "~/projects/emacs/gsql-mode.el/gsql-mode")
    #+end_src
** Music notation - Lilypond et al
   =lilypond-mode= is provided by Lilypond installation - in debian it will be found
   installed in =/usr/share/emacs/site-lisp/lilypond-mode.el=

   #+begin_src emacs-lisp :tangle no
     (require 'lilypond-mode nil t) ; comes from lilypond OS package
     (use-package lilypond :straight t) ; provides ob-lilypond
   #+end_src

   =lilypond-mode= is not derived from =prog-mode= but we want the same hooks
   #+begin_src emacs-lisp :tangle no
     (setq LilyPond-mode-hook prog-mode-hook)
   #+end_src
** FINAL step after all language modes have been configured
   #+begin_src emacs-lisp
     (use-package ob-http :straight t)
     (org-babel-do-load-languages
      'org-babel-load-languages
      (append org-babel-load-languages
              '(
                (sparql . t)
                (clojure . t)
                (http . t) ;; curl
                (js . t)
                (latex . t)
                ;;                (jupyter . t) ;; makes Emacs core dump??? (related to compiled zmq)
                (plantuml . t)
                (lilypond . t)
                (python . t)
                (shell  . t)
                (sql . t)
                )))
   #+end_src
* Devops
** Working with containers
   This is largely a function of TRAMP.  I have added simple ways to
   get Dired and =shell-mode= in
   + Docker containers using =docker-tramp= package
   + DC/OS tasks with the =dcos= TRAMP method
   + Kubernetes pods with the =kube= TRAMP method.  This will grab a
     shell on the first container defined in the pod
   + Google Cloud Shell with =gshell= TRAMP method

** Highlight Terraform and Ansible messages
   This function highlights the typical lines for:
   + Terraform (Creation/Destruction complete)
   + Ansible (RUNNING/STAGE/TASK/PLAY)
   + Docker build (Step n/n)

  #+begin_src emacs-lisp
    (defun gjg/highlight-terraform-stuff ()
      (interactive)
      ; Terraform patterns
      (highlight-regexp "Creation complete" 'hi-green)
      (highlight-regexp "Destruction complete" 'hi-pink)
      ; Docker build
      (highlight-regexp "Step [0-9]+/[0-9]+ : [A-Z]+" 'hi-aquamarine)
      ; Ansible
      (highlight-regexp "\\(RUNNING\\|STAGE\\|TASK\\|PLAY\\) .+" 'hi-black-b))

    (defun gjg/highlight-squid ()
      (interactive)
      ;; Registry pull-through cache
      (highlight-regexp "^HIT" 'hi-green)
      (highlight-regexp "^MISS" 'hi-pink)
      ;; Docker pull-through registry patterns
      (highlight-regexp "\"HIT\"" 'hi-green)
      (highlight-regexp "\"MISS\"" 'hi-pink)
      ;; Squid caching patterns
      (highlight-regexp "[A-Z_]*_HIT[A-Z_]*" 'hi-green)
      (highlight-regexp "[A-Z_]*_MISS[A-Z_]*" 'hi-pink)
      (highlight-regexp "[A-Z_]*_UNMODIFIED[A-Z_]*" 'hi-green)
      (highlight-regexp "application/[-a-z0-9A-Z]+" 'hi-yellow)
      (highlight-regexp "/[^/]+\.rpm" 'hi-black-b)
      (highlight-regexp "/[^/]+\.deb" 'hi-black-b))
  #+end_src

* Parade of Modelines
 The mode line is the most tweaky damn part of Emacs.  I can't get my head around the
 format mechanism, hence all packages must be tried.

 Fancy icons may require fonts (like =texlive-fonts-extra=)

** Frame title and mode line tweaks
  #+begin_src emacs-lisp
    ;; (require 'spaceline-config)
    ;; (setq spaceline-always-show-segments t)
    ;; (spaceline-spacemacs-theme)
    ;; show column number in modeline - in addition to line number
    (line-number-mode 1)
    (column-number-mode 1)
    ;; do not show load average
    (setq display-time-default-load-average nil)

    (setq frame-title-format (concat "emacs@" (system-name) " - %f; %b"))
    ;; fancy git icon
    (defadvice vc-mode-line (after strip-backend () activate)
      (when (stringp vc-mode)
        (let ((gitlogo (replace-regexp-in-string "^ Git." "  " vc-mode))) ;; symbol from fonts-font-awesome
          (setq vc-mode gitlogo))))

  #+end_src
** Awesome Tray
   #+begin_src emacs-lisp :tangle no
     (use-package awesome-tray
       :straight (awesome-tray :type git :host github :repo "manateelazycat/awesome-tray")
       :config
       (setq awesome-tray-active-modules
             '("location" "git" "buffer-read-only" "buffer-name" "mode-name" "input-method" "battery" "date")
             awesome-tray-buffer-name-buffer-changed t
             awesome-tray-buffer-read-only-style "%")
       (awesome-tray-mode 0))
   #+end_src
** Doom modeline
   #+begin_src emacs-lisp
     (use-package minions
       :straight t
       :hook (doom-modeline-mode . minions-mode)
       :custom
       (minions-mode-line-lighter ""))

     (use-package doom-modeline
       :straight t
       :ensure t
       :after eshell     ;; Make sure it gets hooked after eshell
       :hook (after-init . doom-modeline-init)
       ;; :custom-face
       ;; ;; (mode-line ((t (:height 0.85))))
       ;; (mode-line-inactive ((t (:height 0.95))))
       :custom
       ;; (doom-modeline-height 15)
       ;; (doom-modeline-bar-width 6)
       (doom-modeline-lsp t)
       (doom-modeline-github nil)
       ;; (doom-modeline-mu4e nil)
       ;; (doom-modeline-irc nil)
       (doom-modeline-minor-modes t)
       ;; (doom-modeline-persp-name nil)
       (doom-modeline-buffer-file-name-style 'truncate-except-project)
       (doom-modeline-major-mode-icon nil)
       :config
       ; remove selection-info segment from default
       (doom-modeline-def-modeline 'main
         '(bar workspace-name window-number modals matches follow buffer-info remote-host buffer-position word-count parrot )
         '(objed-state misc-info persp-name battery grip irc mu4e gnus github debug repl lsp minor-modes input-method indent-info buffer-encoding major-mode process vcs checker time))
       (doom-modeline-mode 1)
       ;; (doom-modeline-add-variable-watcher
       ;;  'doom-modeline--buffer-file-state-icon
       ;;  (lambda (_sym val op _where)
       ;;    (when (string= (buffer-name _where) "tryit.el")
       ;;      (message "DEBUG: %s %s %s %s" _sym val op _where))
       ;;    (when (eq op 'set)
       ;;      ;; (when (and val (not (string-empty-p val)))
       ;;        (setq doom-modeline--buffer-file-state-icon
       ;;              "🚫"
       ;;              ;; (string-replace "" "OHAI" val)
       ;;              )
       ;;      ;; )
       ;;  )))
       )
   #+end_src
** Moodline
   #+begin_src emacs-lisp :tangle no
     (use-package mood-line
       :straight t
       :config
       (mood-line-mode 1))
   #+end_src
** Simple mode line
   #+begin_src emacs-lisp :tangle no
     (use-package simple-modeline
       :straight t
       :config
       (simple-modeline-mode 1))
   #+end_src
** Smart Mode line
   + Smart mode line defines a face for battery charging/discharging - thus green for
     10% plugged in, and red for 90% on battery.  I prefer the way =battery.el= sets
     faces for level of charge with +/- optionally for charging/discharging.
   #+begin_src emacs-lisp :tangle no
     (use-package smart-mode-line-powerline-theme
       :straight t)
     (use-package smart-mode-line
       :straight t
       :config
       (sml/setup))

     (advice-remove 'battery-update 'ad-Advice-battery-update)
   #+end_src
** Hide the little bleeder altogether
   Set to hide globally, then bind a Super key to toggle only the current buffer. Super
   nice to use when screen sharing
   #+begin_src emacs-lisp
     (use-package hide-mode-line
       :straight t
       :config
       (global-hide-mode-line-mode 0)
       (bind-key "s-m" 'mood-line-mode))
   #+end_src
* Section of trying-things-out-and-please-remember-to-delete-them-afterwards
** Org super links
   + In constant search of cool backlinks
   + [[https://github.com/toshism/org-super-links][GitHub - toshism/org-super-links: Package to create links with auto backlinks]]
   #+begin_src emacs-lisp
     (use-package org-super-links
       :straight (org-super-links :type git :host github :repo "toshism/org-super-links" :branch "develop")
       :bind (("C-c s s" . org-super-links-link)
              ("C-c s l" . org-super-links-store-link)
              ("C-c s C-l" . org-super-links-insert-link)))
   #+end_src
* Final steps
#+begin_src emacs-lisp
(shell (get-buffer-create "sh1"))
#+end_src
