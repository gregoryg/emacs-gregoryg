#+OPTIONS: ':nil *:t -:t ::t <:t H:3 \n:nil ^:t
#+OPTIONS: author:t broken-links:nil c:nil creator:nil
#+OPTIONS: d:(not "LOGBOOK") date:t e:t email:nil f:t inline:t num:nil
#+OPTIONS: p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t
#+OPTIONS: timestamp:t title:t toc:2 todo:t |:t
#+TITLE: gregoryg's Emacs Initialization in Org-Mode
#+DATE: <2019-09-08 Sun>
#+AUTHOR: Greg Grubbs
#+EMAIL: gregory.grubbs@gmail.com
#+LANGUAGE: en
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+CREATOR: Emacs 26.2 (Org mode 9.1.9)
#+setupfile: ~/projects/emacs/org-html-themes/org/theme-readtheorg-local.setup
#+property: header-args:emacs-lisp :tangle ~/.emacs.d/emacs-init.el :results none
#+property: header-args:bash :comments both :shebang #!/usr/bin/env bash :results none

* Literate Programming Config file
  This Org Mode file becomes "tangled" by the =org-babel-load-file= function in =init.el= to
  produce the entire config for my Emacs sessions on Windows, MacOS, Linux and ChromeOS

  Hip tip: to exclude entire code block sections from the resulting tangled config file,
  just add a =:tangle no= header to the source block - but do *not* use =:tangle yes= for
  that will lead to tears by interfering with =org-babel-load-file=

  If reading this file on GitHub, use the =raw= view to see all the code markings and
  header parameters.

* Should I use =evil-mode=?

  No.

* Set executable path
  #+begin_src emacs-lisp
    (when (file-exists-p "~/bin")
      (add-to-list 'exec-path "~/bin"))

    (when (file-exists-p "/usr/local/bin")
      (add-to-list 'exec-path "/usr/local/bin"))
  #+end_src

* Deal with required packages
  Explicitly include =/usr/share/emacs/site-lisp/= when using a self-compiled Emacs.
  Debian and other distros place important files from their packages in that path


  #+begin_src emacs-lisp
    (defvar gjg/check-packages-on-startup nil) ; should be nil in repo

    (add-to-list 'load-path "/usr/share/emacs/site-lisp/")
    (add-to-list 'load-path "~/emacs")
  #+end_src

  =straight.el= use-package without package.el
   + [[https://github.com/raxod502/straight.el][Next-generation, purely functional package manager using Git]]
   + [[https://shivjm.blog/switching-to-straight-el/][Switching to straight.el]]

   I moved this into =init.el= due to a compatibility package required for Org
   Initial loading for Straight.el is now in [[file:.emacs.d/init.el][init.el]]

* Greg's customizations!
** Do async things
   #+begin_src emacs-lisp
     (use-package async :straight t)
     (use-package ob-async :straight t)
   #+end_src
** Revert buffer shortcut
   #+begin_src emacs-lisp
     (defun revert-dammit () ; revert buffer without prompting
       (interactive)
       ;; revert buffer, don't use auto-save, preserve modes
       (revert-buffer t t t))
     (defalias 'rd 'revert-dammit)
   #+end_src
** Use Emacs as app launcher (with completions)
   [[file:img/emacs-app-launcher.png]]
   #+begin_src emacs-lisp
     (use-package app-launcher
       :straight '(app-launcher :host github :repo "SebastienWae/app-launcher"))
     (global-set-key (kbd "s-SPC") 'app-launcher-run-app)
   #+end_src
** Use Rofi as app launcher
*** Generate the script that *should* be in the adi1090x repo
    #+begin_src bash :tangle ~/bin/launch-rofi.sh
      rofidir="$HOME/.config/rofi"
      theme="${1:-type-1}"
      style="${2:-style-1}"

      echo "DEBUG: theme is ${theme}, style is ${style}"
      rofi \
          -show drun \
          -theme ${rofidir}/launchers/${theme}/${style}.rasi
    #+end_src
*** Emacs function to call with crazy randomness
   Here's a helper script to launch =adi1090x='s themed rofi configs
   Nice theme/style combos (ref [[https://github.com/adi1090x/rofi#previews][adi1090x/rofi â‰« github.com]])
   #+begin_src emacs-lisp
     ;; alternative launch for use with my dotfiles config:
     ;;    (call-process-shell-command "rofi -modi drun,run -show drun")
     (defun gjg/launch-rofi ()
       "Launch one of adi1090x rofi themes."
       (interactive)

       (let* ((preferidos '( (6 5) (6 6) (6 7) (7 6)))
              (selected (nth (random (length preferidos)) preferidos)))
         (call-process-shell-command (format "~/bin/launch-rofi.sh type-%d style-%d" (car selected) (nth 1 selected)))
         ;; (message "Rofi launched with type %d and style %d " (car selected) (nth 1 selected))
         ))
   #+end_src
** Cleanup on file save
   Tip o' the hat to [[https://github.com/mitchty][@mitchty]]
   Remove trailing whitespace when saving files
    #+begin_src emacs-lisp
      ;; from https://stackoverflow.com/a/3533933/457574
      (defun delete-trailing-whitespace-except-current-line ()
        "do delete-trailing-whitespace, except preserve whitespace of current line"
        (interactive)
        (let ((current-line (buffer-substring (line-beginning-position) (line-end-position)))
              (backward (- (line-end-position) (point))))
          (delete-trailing-whitespace)
          (when (not (string-equal (buffer-substring (line-beginning-position) (line-end-position))
                                   current-line))
            (delete-region (line-beginning-position) (line-end-position))
            (insert current-line)
            (backward-char backward))))


      (add-hook 'before-save-hook 'delete-trailing-whitespace-except-current-line)
   #+end_src

   Make it executable if it should be executable!

   #+begin_src emacs-lisp
   (add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)
   #+end_src

** Linux things
   Fix to make Org export to HTML and open do the right thing: open in the preferred
   browser rather than just HTML in an Emacs buffer
   #+begin_src emacs-lisp
     (when (eq window-system 'x)
       (setq org-file-apps
             '((auto-mode . emacs)
               ("\\.mm\\'" . default)
               ("\\.x?html?\\'" . "/usr/bin/x-www-browser %s")
               ("\\.pdf\\'" . default))))
   #+end_src
** Fonts
   Forever in search of the One True Holy and Apostolic Programmer Font.

   Big fan of Inconsolata, Source Code Pro, and Hack.  Inability to decide on one is
   encoded herein.

   Make it a callable function so I can set new frames.  For now, do not tie it into a
   frame hook - not certain I would want it for every frame.  This would make use of the
   hook variable =after-make-frame-functions=

   Emacs 29 obviates my need for the inc/dec functions in =fontize.el= The key bindings
   for the new-in-Emacs-29 frame font resize functions are
   * =C-x C-M-+= -,0


   #+begin_src emacs-lisp
     (defun gjg/set-frame-font ()
       "Set frame font based on window system"
       (interactive)
       (cond ((or (eq window-system 'mac) (eq window-system 'ns))
              (set-frame-font "Source Code Pro-17"))
             ((eq window-system 'w32)
              (set-face-font 'default '"-outline-Source Code Pro-normal-normal-normal-mono-17-*-*-*-c-*-iso8859-1"))
             ((eq window-system 'x)
              (set-frame-font "Hack-14")
              ;; (set-frame-font "Inconsolata-16")
              )))
     (gjg/set-frame-font)
     ;; (add-hook 'after-make-frame-functions 'gjg/set-frame-font)
     (cond
      ((< emacs-major-version 29) ; from "fontize" package in ~/emacs/
       (autoload 'inc-font-size "fontize" "Adjust buffer relative font size" t)
       (autoload 'dec-font-size "fontize" "Adjust buffer relative font size" t))
      (t
       (defun inc-font-size ()
         (interactive)
         (global-text-scale-adjust 1))
       (defun dec-font-size ()
         (interactive)
         (global-text-scale-adjust -1))))

     (global-set-key [C-kp-subtract] 'dec-font-size)
     (global-set-key [C-kp-add] 'inc-font-size)
   #+end_src
** Basic defaults that aren't default
   So many defaults in Emacs make no sense.  If starting out with Emacs, consider these
   settings to make your first experiences nicer.

   If you have any questions about what these settings do, use Emacs to explore them:
   + If it's a variable being set (line starts with the =setq= function, set the point in
     the variable name and hit =C-h v= for help on that variable.
   + If it's a function (line starts with almost anything other than =setq=, set the point
     in the function name and hit "C-h f"

#+begin_src emacs-lisp
  ;; show parens: useful even in text modes
  (show-paren-mode 1)
  ;; fido-mode in emacs 27+: a new thing to hate
  (fido-mode -1)
  ;; When I want transient mark mode, I'll beat it out of you
  (setq transient-mark-mode nil)
  ;; (do not) display time and battery status in the mode line
  (display-time-mode 0)
  (display-battery-mode 0)
  ;; turn off that stupid toolbar
  (tool-bar-mode -1)
  ;; scroll bars?
  (scroll-bar-mode -1)
  (menu-bar-mode -1)
  ;; don't do that stoopid splash screen
  (setq inhibit-splash-screen t)

  ;; tab indents - if line is already indented, try to auto-complete
  (setq tab-always-indent 'complete)

  (setq-default indent-tabs-mode nil)
  (setq-default tab-always-indent t)
  (setq-default tab-width 4)
  ;; blink parens and similar delimiters
  (show-paren-mode 1)
  ;; ** Global identity (ie, same on all machines) - Emacs does not make good guesses here
  (setq user-full-name "Gregory Grubbs"
    user-mail-address "gregory.grubbs@gmail.com")

  (setq confirm-kill-emacs 'y-or-n-p) ;; confirm to exit emacs

  ;; dippy bird FTW - single character y-n for all yes/no question dialogs
  (fset 'yes-or-no-p 'y-or-n-p)
  (setq shell-file-name "bash")
  ;; (setq shell-command-switch "-ic") ; source .bashrc to get aliases etc
  (setq explicit-shell-file-name shell-file-name)
  (setq explicit-bash-args '("--noediting" "-i"))

  (global-hl-line-mode t) ;; highlight current line - turn off when figuring out faces

  (temp-buffer-resize-mode 1)  ;; crazy cool auto resizing of temp windows

  (setq fill-column 90); good default for wider screens - BUT this is buffer-local so should be set in mode hooks only

  ;; ensure that the default for searches is case-insensitive
  (setq case-fold-search t)

  ;; highlight/colorize everything that can be colorized!
  (global-font-lock-mode 1)

  ;; never split windows horizontally by default
  (setq split-width-threshold nil)
  ;; Here's a choice one: stay in the same column while scrolling!
  (setq scroll-preserve-screen-position t)
  ;; in Emacs23+, make line-move move by a line, ignoring wrapping
  (setq line-move-visual nil)
  ;; enable hugely useful things that are disabled by default
  (put 'narrow-to-region 'disabled nil)
  (put 'set-goal-column 'disabled nil)
  (setq narrow-to-defun-include-comments t)
  ;; echo quickly
  (setq echo-keystrokes 0.1)
  ;; keep the screen from jumping wildly as I cursor down/up
  (setq scroll-conservatively 5)
  ;; remember minibuffer history between sessions
  (savehist-mode t)
  ;; https://emacs.stackexchange.com/a/9952/418
  (use-package exec-path-from-shell :straight t)
  (exec-path-from-shell-initialize)
  (exec-path-from-shell-copy-env "HISTFILE")
  ;; if point is at end of line, keep it there for vertical movement
  (setq track-eol t)
  (setq align-to-tab-stop nil) ;; do not use tabs for align and align-regexp
  (setq auth-source-save-behavior nil) ; NEVER store passwords
  (setq enable-recursive-minibuffers t)
  ;; Allow Emacs to resize mini windows, otherwise this does not work:
  ;;   (setq org-use-fast-todo-selection 'expert)
  (setq resize-mini-windows t)
  ;; as of Emacs 29
  (setq pixel-scroll-precision-mode t)
#+end_src
** Custom Functions in a separate file
   TODO: pull these functions in
   #+begin_src emacs-lisp
     (add-to-list 'load-path "~/emacs")
     (load "gjg-functions")
     (require 'gjg-functions)
   #+end_src
** Key (and mouse) bindings
*** Audio and media
    #+begin_src emacs-lisp
      (defun gjg/volume (volcmd)
        "Control volume with pulseaudio script."
        (let ((audioctl (expand-file-name "~/bin/pulseaudio-control-glados")))
          (call-process-shell-command (concat audioctl " " volcmd))))
      (bind-key (kbd "<XF86AudioLowerVolume>") (lambda () (interactive) (gjg/volume "down")))
      (bind-key (kbd "<XF86AudioRaiseVolume>") (lambda () (interactive) (gjg/volume "up")))
      (bind-key (kbd "<XF86AudioMute>") (lambda () (interactive) (gjg/volume "togmute")))
      (bind-key (kbd "<XF86AudioPlay>") (lambda () (interactive) (call-process-shell-command "/usr/bin/playerctl play-pause") ))
    #+end_src
*** Big blob of various key bindings
   #+begin_src emacs-lisp
     (global-set-key [home] (lambda () (interactive) (goto-char (point-min))))
     (global-set-key [end] (quote end-of-buffer))
     ;; M-left and M-right on Pixelbook
     (global-unset-key (kbd "<M-left>"))
     (global-unset-key (kbd "<M-right>"))
     (global-set-key (kbd "<M-left>") (lambda () (interactive) (goto-char (point-min))))
     (global-set-key (kbd "<M-right>") 'end-of-buffer)
     (global-unset-key (kbd "C-z"))
     (global-set-key (kbd "C-z") 'undo)
     (global-unset-key (kbd "M-]")) ; unset one next-buffer binding
     (global-unset-key (kbd "M-[")) ; unset one previous-buffer binding
     (global-set-key (kbd "s-g") 'gjg/exwm-select-or-launch-logseq)
     (global-set-key (kbd "s-g") 'gjg/exwm-select-slack)
     (global-set-key (kbd "s-'") 'gjg/add-person-from-table)
     (global-set-key (kbd "s-y") 'gjg/exwm-select-or-launch-spotify)
     (global-set-key (kbd "s--")  'gjg/exwm-select-zoom-meeting)
     (global-set-key (kbd "s-=")  'gjg/exwm-select-teams-meeting)

     (global-set-key [f1] 'delete-other-windows)
     (global-set-key [f2] 'gjg/switch-to-other-buffer)
     (global-set-key [f3] 'gjg/other-window-or-split)
     (global-set-key [f4] 'narrow-to-defun)

     (global-set-key [f5] 'gjg/widen-ask-if-indirect)
     ;; (global-set-key [f6] 'read-only-mode)
     (global-set-key [f6] 'gjg/open-work-agenda)
     (global-set-key [f7] 'hl-line-mode) ;; toggle hl-line-mode for this window only
     ;; (global-set-key [f8] 'bury-buffer)

     (global-set-key [f9] 'bury-buffer)
     (global-set-key [f10] 'dired-omit-mode)
     ;; (global-set-key [f11] 'mac-toggle-max-window)
     (global-set-key [f11] 'gjg/toggle-max-frame)
     (global-set-key [M-f11] 'gjg/toggle-max-frame)
     ;; (global-set-key [f11] 'toggle-fullscreen)
     ;; (global-set-key [f11] 'switch-full-screen)
     ;; (global-set-key (kbd "C-<f11>") 'gjg/emacs-max-coolness)
     (global-set-key [f12] (lambda () (interactive) (message (or (buffer-file-name) "No file associated with this buffer."))))
     (global-set-key (kbd "<C-f12>") 'yow)
     (global-set-key [C-wheel-up] 'text-scale-increase)
     (global-set-key [C-wheel-down] 'text-scale-decrease)
     (global-set-key [S-wheel-up] 'inc-font-size)
     (global-set-key [S-wheel-down] 'dec-font-size)
     (global-set-key (kbd "M-]") 'next-buffer)
     (global-set-key (kbd "M-[") 'previous-buffer)
     (global-set-key (kbd "C-c C-v") 'browse-url-at-point)
     ;; (unbind-key (kbd "C-c C-o") sh-mode-map)
     (global-set-key (kbd "C-c C-o") 'org-open-at-point)  ; open Org links in tangled files!
     (defalias 'ss 'gjg/open-remote-shell)
     (defalias 'ht 'gjg/highlight-terraform-stuff)
     (defalias 'rb 'rename-buffer)

   #+end_src
*** Mouse actions
    I accidentally hit these mouse combos working on the laptop - disable 'em all!
    #+begin_src emacs-lisp
      (global-unset-key (kbd"C-<down-mouse-1>")) ;; mouse-buffer-menu
      (global-unset-key (kbd"C-<down-mouse-2>")) ;; facemenu-menu
      (global-unset-key (kbd"S-<down-mouse-1>")) ;; mouse-appearance-menu
    #+end_src
** Backup files
   #+begin_src emacs-lisp
     ;; backup files
     (setq
      backup-by-copying t      ; don't clobber symlinks
      backup-directory-alist
      '(("." . "~/.emacs.d/backups"))    ; don't litter my fs tree
      delete-old-versions t
      kept-new-versions 5
      kept-old-versions 5
      version-control nil)
   #+end_src


** Automatic typing
*** Abbreviations while typing
    Abbrevs are stored in =~/.emacs.d/abbrev_defs=
    #+begin_src emacs-lisp
     ;; Dynamic abbrevs should expand both words and symbols
     (setq dabbrev-abbrev-char-regexp "\\sw\\|\\s_")
    #+end_src
*** Dynamic expansions with =M-/=
    The question to settle here is should I stick with default Dabbrev, or re-activate
    hippie-expand which I've used forever - also a built-in now?  Not sure I know the diff
    anymore
    #+begin_src emacs-lisp
      ;; and now set up hippie-expand
      (global-set-key (kbd "M-/") 'hippie-expand)
    #+end_src
** Games and silliness
   #+begin_src emacs-lisp
     ;; very important: keep a long list of yow lines
     ;;   in emacs 24.4 yow.el is obsolete; use cookie instead
     (when (featurep 'yow)
       (unload-feature 'yow))
     ;; (with-eval-after-load 'cookie
     (defun yow ()
       (interactive)
       (let ((suggest-key-bindings nil))
         (message (cookie gjg/yow-file nil nil))))
     ;; )
     ;; almost as important: keep track of those tetris scores
     (setq tetris-score-file "~/.emacs.d/tetris.score")
   #+end_src
   #+begin_src emacs-lisp :tangle no  :results value  :exports results
     (yow)
   #+end_src

** Multimedia
   Control whatever media is playing
   Requires =playerctl= OS package as well
   #+begin_src emacs-lisp
     (use-package playerctl :straight t)
   #+end_src
** Rainbow delimiters
   #+begin_src emacs-lisp
     (use-package rainbow-delimiters :straight t)
   #+end_src
* Encryption
  =epa-file= is a built-in

  Set value of =epg-gpg-program= to location on local system
  #+begin_src emacs-lisp
;; let's get encryption established
;; For gpg, disable external pinentry - let emacs handle pass phrase
;; (setenv "GPG_AGENT_INFO" nil)
(require 'epa-file)
;; (custom-set-variables '(epg-gpg-program  "/usr/local/bin/gpg"))
(epa-file-enable)
(setq epg-pinentry-mode 'loopback)
(require 'org-crypt)
(org-crypt-use-before-save-magic)

  #+end_src
* Window/buffer management
** GJG full screen, movement, transparency
** GJG Transparency / Opacity management
   Emacs 29 ushers in a bold new era where a frame's background can be made transparent
   without affecting the transparency of foreground text and other elements.  Who'd-a
   thunk?  Use that feature when available

   #+begin_src emacs-lisp
     ;; TODO ; fix toggle-transparency
     (defun toggle-transparency (alpha-level)
       (interactive "p")
       (message (format "%s" alpha-level))
       (when (< alpha-level 50) (setq alpha-level 85))
       (let ((myalpha (or (frame-parameter nil 'alpha) 100))
             (frame-param (if (< emacs-major-version 29) 'alpha 'alpha-background)))

         (set-frame-parameter nil frame-param myalpha)
         (message (format "Frame %s level is %d" frame-param myalpha))))

     (defun set-transparency (alpha-level)
       ;; in Emacs 29+, set background opacity
       ;; before 29, we have no choice but to set frame opacity
       (interactive "p")
       (message (format "Alpha level passed in: %s" alpha-level))
       (let ((alpha-level (if (< alpha-level 2)
                              (read-number "Opacity percentage: " 85)
                            alpha-level))
             (frame-param (if (< emacs-major-version 29) 'alpha 'alpha-background)))
         (set-frame-parameter nil frame-param alpha-level)
         (message (format "Frame %s level is %d" frame-param alpha-level))))
     (defalias 'set-opacity 'set-transparency )

   #+end_src
** Packages for window and buffer nav
   #+begin_src emacs-lisp
     (use-package ace-window :straight t
       :config
       (custom-set-faces
        '(aw-leading-char-face
          ((t (:foreground "deep sky blue" :height 5.0)))
          ))
       :bind
        (("C-x o" . ace-window)))
     (use-package winum :straight t
       :config
       (setq winum-scope                       'frame-local
             winum-auto-assign-0-to-minibuffer nil
             winum-auto-setup-mode-line        t))
     (winum-mode)
     (set-face-attribute 'winum-face nil :weight 'bold)
     (defun gjg/other-window-with-winum ()
       "if 2 windows, jump to other-window.  Elsecase use winum"
       (interactive)
       (cond ((= 1 winum--window-count)
              (gjg/switch-to-other-buffer))
             ((= 2 winum--window-count)
              (other-window 1))
             ((> 10 winum--window-count)
              ;; jump immediately to window
              ;; (let ((jwin (read-number (format "Jump to window num[1-%d]: " winum--window-count))))
              (let ((jwin (string-to-number (char-to-string (read-char (format "Jump to window num[1-%d]: " winum--window-count))))))
                (message "Jumping to %d" jwin)
                (winum-select-window-by-number jwin)))
             (t
              (let ((jwin (read-number (format "Jump to window num[1-%d]: " winum--window-count))))
                (message "Jumping to %d" jwin)
                (winum-select-window-by-number jwin)))
              ))
   #+end_src
** GJG Window splitting
   #+begin_src emacs-lisp
     ;; unbind some keys in favor of my functions bound to SUPER- combinations
     ;; the existing keys will work in Emacs buffers, but not in EXWM X buffers; the SUPER combos work everywhere
     (global-unset-key (kbd "M-]")) ; next-buffer
     (global-unset-key (kbd "M-[")) ; previous-buffer
     (defun gjg/switch-to-other-buffer ()
       (interactive)
       (switch-to-buffer (other-buffer))
       (message "Switched to other-buffer"))
     (defun gjg/split-window-below ()
       "Split window below, switch to the new window AND switch buffer in that window"
       (interactive)
       (split-window-below)
       (other-window 1)
       (switch-to-buffer (other-buffer)))
     (defun gjg/split-window-right ()
       "Split window right, switch to the new window AND switch buffer in that window"
       (interactive)
       (split-window-right)
       (other-window 1)
       (switch-to-buffer (other-buffer)))
     (defun toggle-window-split ()
       (interactive)
       (if (= (count-windows) 2)
           (let* ((this-win-buffer (window-buffer))
                  (next-win-buffer (window-buffer (next-window)))
                  (this-win-edges (window-edges (selected-window)))
                  (next-win-edges (window-edges (next-window)))
                  (this-win-2nd (not (and (<= (car this-win-edges)
                                              (car next-win-edges))
                                          (<= (cadr this-win-edges)
                                              (cadr next-win-edges)))))
                  (splitter
                   (if (= (car this-win-edges)
                          (car (window-edges (next-window))))
                       'split-window-horizontally
                     'split-window-vertically)))
             (delete-other-windows)
             (let ((first-win (selected-window)))
               (funcall splitter)
               (if this-win-2nd (other-window 1))
               (set-window-buffer (selected-window) this-win-buffer)
               (set-window-buffer (next-window) next-win-buffer)
               (select-window first-win)
               (if this-win-2nd (other-window 1))))))


   #+end_src
** Indirect buffer use
   #+begin_src emacs-lisp
     (defun gjg/widen-ask-if-indirect ()
       "If buffer is indirect, ask before widening"
       (interactive)
       (if (buffer-base-buffer)
           (when (yes-or-no-p "Buffer is indirect; really widen? ")
             (widen))
         (widen)))
   #+end_src
** Full screen functions - MAY BE OBSOLETE
   Certainly all this is irrelevant when using EXWM or any tiling window manager
   #+begin_src emacs-lisp :tangle no
     ;; *** Full-screen frame defuns

     (defun switch-full-screen ()
       (interactive)
       (shell-command (concat "/usr/bin/wmctrl -i -r " (frame-parameter nil 'outer-window-id) " -btoggle,fullscreen")))

     ;; (defun toggle-fullscreen ()
     ;;   "toggles whether the currently selected frame consumes the entire display or is decorated with a window border"
     ;;   (interactive)
     ;;   (let ((f (selected-frame)))
     ;;     (modify-frame-parameters f `((fullscreen . ,(if (eq nil (frame-parameter f 'fullscreen)) 'fullboth nil))))))

     ;; (defun mac-toggle-max-window ()
     ;;   "Toggle full-screen frame on Linux and OS X - use maxframe.el for Windows"
     ;;   (interactive)
     ;;   (if (frame-parameter nil 'fullscreen)
     ;;       (set-frame-parameter nil 'fullscreen nil)
     ;;     (set-frame-parameter nil 'fullscreen 'fullboth)))
     ;; (defun toggle-full-screen ()
     ;;   "Toggle between full screen and partial screen display on X11;
     ;;     courtesy of http://www.emacswiki.org/cgi-bin/wiki/FullScreen"
     ;;   (interactive)
     ;;   (x-send-client-message nil 0 nil "_NET_WM_STATE" 32
     ;;                          '(2 "_NET_WM_STATE_FULLSCREEN" 0)))


     ;; ;; add toggle for maxframe.el (works on Windows)
     (when (eq window-system 'w32)
       (require 'maxframe)
       (modify-frame-parameters nil '((gjg/frame-maxp . nil))))
     ;; (modify-frame-parameters nil '((gjg/frame-maxp . nil)))
     ;; ;; (defvar gjg/frame-maxp nil "Store whether frame is maximized using maxframe.el")
     (defun gjg/switch-buffer-by-mode ()
       "Switch to a buffer after choosing a mode."
       (interactive)
       (let* ((active-buffers-with-mode (mapcar #'(lambda (x) (with-current-buffer x (cons (buffer-name) (symbol-name major-mode)))) (buffer-list)))
          (distinct-modes (-distinct (mapcar #'cdr active-buffers-with-mode)))
          (selected-mode (completing-read "Mode: " distinct-modes))
          (candidate-buffers (mapcar #'car (cl-remove-if-not '(lambda (x) (string-equal selected-mode (cdr x))) active-buffers-with-mode)))
          (selected-buffer (completing-read "Buffer: " candidate-buffers)))
         (switch-to-buffer selected-buffer)))

     (defun gjg/max-frame ()
       "Maximize the current frame and toggle gjg/frame-maxp"
       (interactive)
       (cond ((eq window-system 'w32)
          (maximize-frame))
         ((eq window-system 'x)
          (switch-full-screen))
         (t
          (mac-toggle-max-window)))
       (modify-frame-parameters nil '((gjg/frame-maxp . t))))

     (defun gjg/restore-frame ()
       "Restore the current frame to its previous size and toggle gjg/frame-maxp"
       (interactive)
       (cond ((eq window-system 'w32)
          (restore-frame))
         ((eq window-system 'x)
          (switch-full-screen))
         (t
          (mac-toggle-max-window)))
       (modify-frame-parameters nil '((gjg/frame-maxp . nil))))

     (defun gjg/toggle-max-frame ()
       "Check the status of gjg/max-framep and change to whichever mode we're not in now."
       (interactive)
       (cond ((eq window-system 'ns)
          (toggle-frame-maximized))
         (t
          (if (eq (frame-parameter nil 'gjg/frame-maxp) nil) (gjg/max-frame) (gjg/restore-frame)))))

   #+end_src
** Big bunch of key bindings for Window/Buffer navigation
   TODO: figure out global Super key chords in exwm map vs global key map
   #+begin_src emacs-lisp
     (bind-key "C-x 2" 'gjg/split-window-below)
     (bind-key "C-x 3" 'gjg/split-window-right)
     (bind-key "C-x o" 'gjg/other-window-with-winum)
     (bind-key "s-a" 'gjg/open-work-agenda)
     (bind-key "s-o" 'gjg/other-window-with-winum)
     (bind-key "s-b" 'gjg/switch-to-other-buffer)
     (bind-key "s-<up>" 'windmove-up)
     (bind-key "s-<down>" 'windmove-down)
     (bind-key "s-<right>" 'windmove-right)
     (bind-key "s-<left>" 'windmove-left)

     (bind-key "s-0" 'delete-window)
     (bind-key "s-1" 'delete-other-windows)
     (bind-key "s-2" 'gjg/split-window-below)
     (bind-key "s-3" 'gjg/split-window-right)
     (bind-key "M-s-<up>" 'windmove-delete-up)
     (bind-key "M-s-<down>" 'windmove-delete-down)
     (bind-key "M-s-<left>" 'windmove-delete-left)
     (bind-key "M-s-<right>" 'windmove-delete-right)
     (bind-key "s-p" 'playerctl-play-pause-song)
     (bind-key "s-q" 'bury-buffer)
     (bind-key "s-t" 'toggle-truncate-lines)
     (bind-key "s-'" 'gjg/add-person-from-table)
     (bind-key "s-y" 'gjg/exwm-select-or-launch-spotify)
     (bind-key "s-c" 'gjg/exwm-select-or-launch-google-chat)
     ;; (bind-key "s-c" #'(lambda () (interactive) (call-process-shell-command "invert-color.sh")))
     (bind-key "s-." #'(lambda () (interactive) (find-file "~/emacs-gregoryg/README.org")))
     (bind-key "s-," 'gjg/polybar-start-or-toggle)
     (bind-key "s-]" 'ded/org-show-next-heading-tidily)
     (bind-key "s-[" 'ded/org-show-previous-heading-tidily)
     ;; (bind-key "M-SPC" #'(lambda () (interactive) (call-process-shell-command "rofi -modi drun,run -show drun")))
     (bind-key "M-SPC" 'gjg/launch-rofi)
     (bind-key "s-\\" 'switch-to-buffer)
     ;; (Set-face-attribute 'winum-face nil :foreground "deep sky blue")
     (define-key ctl-x-4-map "t" 'toggle-window-split)
   #+end_src
** Winner-mode and Windmove
  winner-mode is a built-in

  #+begin_src emacs-lisp
    ;; winner
    (require 'winner)
    (winner-mode 1)
    ;; windmove
    ;; (windmove-default-keybindings)
    ;; (with-eval-after-load 'windmove
    ;;   (windmove-default-keybindings)
    ;;   ;; Make windmove work in org-mode:
    ;;   (setq org-replace-disputed-keys t))
    ;; (add-hook 'org-shiftup-final-hook 'windmove-up)
    ;; (add-hook 'org-shiftleft-final-hook 'windmove-left)
    ;; (add-hook 'org-shiftdown-final-hook 'windmove-down)
    ;; (add-hook 'org-shiftright-final-hook 'windmove-right)))

    ;; Add advice to stop hangs on EXWM
    ;; The problem happens with floating windows that disappear - like open file dialog or a Zoom dialog when starting a meeting
    ;; The solution is to assure all frames in winner-modified-list pass the frame-live-p test
    (defun gjg/winner-clean-up-modified-list ()
      "Remove dead frames from `winner-modified-list`"
      (dolist (frame winner-modified-list)
        (unless (frame-live-p frame)
          (delete frame winner-modified-list))))
    (advice-add 'winner-save-old-configurations :before #'gjg/winner-clean-up-modified-list)
  #+end_src
** Ibuffer FTW
*** View customizations
    #+begin_src emacs-lisp
      (setq ibuffer-formats
            '((mark modified read-only locked " "
                    (name 50 50 :left :elide)  ; much wider buffer name column
                    " "
                    (size 9 -1 :right)
                    " "
                    (mode 16 16 :left :elide)
                    " " filename-and-process)
              (mark " "
                    (name 16 -1)
                    " " filename))
            )
    #+end_src
*** Filter groups
   Saved filter groups provide a nice organization.

   #+begin_src emacs-lisp
     (require 'ibuffer)
     (global-set-key (kbd "C-x C-b") (lambda () (interactive) (ibuffer)))
     (setq ibuffer-expert t)
     (setq ibuffer-default-sorting-mode 'alphabetic)
     (setq ibuffer-saved-filter-groups
           '(("home"
              ("Org and Markdown" (or (mode . org-mode)
                                      (mode . org-agenda-mode)
                                      (mode . markdown-mode)))
              ("Shells" (or (mode . shell-mode)
                            (mode . eshell-mode)))
              ("EXWM X Apps" (mode . exwm-mode))
              ("Configs" (or (derived-mode .  conf-mode)
                             (mode . yaml-mode)
                             (mode . json-mode)))
              ("Code" (derived-mode .  prog-mode))
              ("Magit" (or (mode . magit-diff-mode)
                           (mode . magit-status-mode)
                           (mode . magit-process-mode)
                           (mode . magit-revision-mode)
                           (mode . magit-refs-mode)))
              ("Dired" (mode . dired-mode))
              ("Tramp sessions" (name . "\*tramp.+"))
              ;; ("Remote" (filename . "\/.+:.+"))
              )))
     (add-hook 'ibuffer-mode-hook
               #'(lambda ()
                  (ibuffer-auto-mode 1)
                  (auto-revert-mode 1)
                  (ibuffer-switch-to-saved-filter-groups "home")))
   #+end_src
*** Preview buffer in side window
    Preview without selecting the window - stay on current line in Ibuffer

    This function should work just like =occur-mode-display-occurence= in =replace.el=
   #+begin_src emacs-lisp
     (defun gjg/ibuffer-only-exwm ()
       (interactive)
       (ibuffer nil "*EXWM Thang*" '((used-mode . exwm-mode)))
       (gjg/ibuffer-preview))
     (global-set-key (kbd "s-e") 'gjg/ibuffer-only-exwm)
     (defun gjg/ibuffer-preview ()
       "View the current file in other window but to do select"
       (interactive)
       (delete-other-windows)
       (when (not (window-parent)) ;; only one window, so split
         (split-window nil nil 'right))
       (let ((buf (ibuffer-current-buffer t)))
         (display-buffer buf '((display-buffer-use-some-window
                                display-buffer-pop-up-window)
                               (inhibit-same-window . t))))
       :refresh-p nil)

     (define-key ibuffer-mode-map (kbd "SPC") 'gjg/ibuffer-preview)
   #+end_src

** Uniquify
   #+begin_src emacs-lisp
     (autoload 'uniquify "uniquify" "unique buffer names dependent on file name")
     (with-eval-after-load 'uniquify
       (setq uniquify-buffer-name-style 'reverse)
       (setq uniquify-separator "/")
       (setq uniquify-after-kill-buffer-p t)
       (setq uniquify-ignore-buffers-re "^\\*"))
   #+end_src
** Themes
*** Modus themes
    Use the built-in

    I want to soften the contrasts in dark mode - default is white on black.  But
    changing the background too light throws off readability of some things - notably the
    deliimters when using =rainbow-delimiters-mode=.  So without going down the rabbit
    hole to modify all the rainbow-delimiters faces, I'm just nudging the background and
    foreground colors very slightly.
    #+begin_src emacs-lisp
      ;; make the modus themes act more like my brutalist theme in Org
      ;; (require 'modus-themes)
      (defun gjg/my-modus-themes-custom-faces ()
        "Tweak faces"
        (message "Setting custom org-habit face for Modus themes")
        (modus-themes-with-colors
          (custom-set-faces
           `(org-habit-clear-face ((,c :background ,bg-graph-green-0 :foreground "black")))
           `(org-habit-clear-future-face ((,c :background ,bg-graph-green-1 )))
           `(org-habit-ready-face ((,c :background ,bg-graph-green-0 :foreground "black")))
           `(org-habit-ready-future-face ((,c :background ,bg-graph-green-1 ))))))
      (add-hook 'modus-themes-after-load-theme-hook #'gjg/my-modus-themes-custom-faces)
      (setq modus-themes-headings
            '((1 . ( semibold 1.3))
              (2 . ( semibold 1.1))
              (3 . ( semibold 1.1))
              (4 . ( semibold 1.1))
              (5 . ( semibold 1.1))
              (6 . ( semibold 1.1)))
            modus-themes-syntax '(faint alt-syntax)
            modus-themes-org-blocks nil
            modus-themes-org-agenda
            '((header-block . (1.3))
              (header-date . (bold-today 1.2))
              (habit . simplified))
            modus-themes-org-blocks nil
            ;; modus-themes-vivendi-color-overrides
            modus-themes-common-palette-overrides
            '(,@modus-themes-preset-overrides-intense)
            modus-vivendi-tinted-palette-overrides
            '((bg-main "#1a1a1a")  ; gray10
              (fg-main "#e5e5e5")  ; gray90
              (fg-heading-4 "#f4a460")
              (bg-hl-line "#262626")))
    #+end_src
*** Load default theme
    Deferred here until all theme tweaks have been applied
    #+begin_src emacs-lisp
      (let ((hour (nth 2 (decode-time))))
        (if (or (< hour 9) (> hour 16))
            (gjg/go-dark)
          (gjg/go-light)))
    #+end_src
** Make things open up in preferred window
   There's a standard way to force niceness from functions that open buffers in random
   windows just to be annoying.  Here's where those functions are corralled
   #+begin_src emacs-lisp
     ;; Org capture
     (add-to-list 'display-buffer-alist '("^\\*Capture\\*" display-buffer-reuse-window display-buffer-same-window))
     ;; R
     (add-to-list 'display-buffer-alist '("^\\*R" display-buffer-same-window))
     ;; Helpful
     (add-to-list 'display-buffer-alist '("^\\*helpful" display-buffer-reuse-mode-window))
     ;; Change behavior of Magit status (status only, not magit-diff, magit-process etc)
     (add-to-list 'display-buffer-alist '("^magit:" display-buffer-same-window))
     ;; All interactive SQL modes
     (add-to-list 'display-buffer-alist
                  '((lambda (buffer action)
                      (with-current-buffer buffer
                        (derived-mode-p 'sql-interactive-mode)))
                    display-buffer-same-window))
   #+end_src

   + Here's an example of wrangling a window to display in a direction, with width and
     height constraints
     #+begin_src emacs-lisp :tangle no
       (add-to-list 'display-buffer-alist
                    '(("\\*org-roam\\*"
                       (display-buffer-in-direction)
                       (direction . right)
                       (window-width . 0.33)
                       (window-height . fit-window-to-buffer))))
     #+end_src

** Enable resizing windows with mouse as a normal human
    =window-divider-mode= makes it easy to resize vertically split windows with the
   mouse - EXWM makes it nearly impossible to select the vertical margin without this!

   This is a built-in minor mode
   #+begin_src emacs-lisp
     (window-divider-mode 1)
   #+end_src

* EXWM : The Emacs X Window Manager
   This crazy idea is better than I thought it could be!

   This section is only useable on Linux - or Unix presumably - with X Window System
   running but no window manager.  An entire window manager has been written in Emacs
   Lisp - the fundamental package that exercises the X11 APIs is called [[https://github.com/ch11ng/xelb][XELB]]

   The package built atop that to provide a usable window manager is [[https://github.com/ch11ng/exwm][EXWM]] - Emacs X Window
   Manager

   EXWM is primarily a tiling window manager, but it supports floating windows as well -
   very nice for transient dialogs.  You have control to take an application window and
   change it to a floating window, along with the ability to move and resize it.

   EXWM supports workspaces, which here is an abstraction based on Emacs frames.  The only
   time I use workspaces in EXWM is when I have 2 or more monitors, where I place one
   workspace per display.

   #+begin_src emacs-lisp
     (use-package exwm :straight t)
   #+end_src
** Patches and egregious hacks
   There is currently [2022-10-17 Mon] *NO* real maintainer of the EXWM repo - @ch11ng has
   disappeared.  This section will attempt to implement patches known to fix current bugs
   until such time as existing PRs start getting merged
*** Fix frame focus for Emacs 29+
    [2022-12-03 Sat] THIS PATCH IS INCLUDED IN EXWM 0.27!
    [[file:.emacs.d/straight/repos/exwm/exwm.el::defun exwm--on-ClientMessage (raw-data _synthetic][exwm--on-ClientMessage]]
    #+begin_src emacs-lisp :tangle no
      (defun exwm--on-ClientMessage (raw-data _synthetic)
        "Handle ClientMessage event."
        (let ((obj (make-instance 'xcb:ClientMessage))
              type id data)
          (xcb:unmarshal obj raw-data)
          (setq type (slot-value obj 'type)
                id (slot-value obj 'window)
                data (slot-value (slot-value obj 'data) 'data32))
          (exwm--log "atom=%s(%s)" (x-get-atom-name type exwm-workspace--current)
                     type)
          (cond
           ;; _NET_NUMBER_OF_DESKTOPS.
           ((= type xcb:Atom:_NET_NUMBER_OF_DESKTOPS)
            (let ((current (exwm-workspace--count))
                  (requested (elt data 0)))
              ;; Only allow increasing/decreasing the workspace number by 1.
              (cond
               ((< current requested)
                (make-frame))
               ((and (> current requested)
                     (> current 1))
                (let ((frame (car (last exwm-workspace--list))))
                  (exwm-workspace--get-remove-frame-next-workspace frame)
                  (delete-frame frame))))))
           ;; _NET_CURRENT_DESKTOP.
           ((= type xcb:Atom:_NET_CURRENT_DESKTOP)
            (exwm-workspace-switch (elt data 0)))
           ;; _NET_ACTIVE_WINDOW.
           ((= type xcb:Atom:_NET_ACTIVE_WINDOW)
            (dolist (f exwm-workspace--list)
              (when (eq id (frame-parameter f 'exwm-outer-id))
                (x-focus-frame f t)))
            (let ((buffer (exwm--id->buffer id))
                  iconic window)
              (when (buffer-live-p buffer)
                (with-current-buffer buffer
                  (when (eq exwm--frame exwm-workspace--current)
                    (if exwm--floating-frame
                        (select-frame exwm--floating-frame)
                      (setq iconic (exwm-layout--iconic-state-p))
                      (when iconic
                        ;; State change: iconic => normal.
                        (set-window-buffer (frame-selected-window exwm--frame)
                                           (current-buffer)))
                      ;; Focus transfer.
                      (setq window (get-buffer-window nil t))
                      (when (or iconic
                                (not (eq window (selected-window))))
                        (select-window window))))))))
           ;; _NET_CLOSE_WINDOW.
           ((= type xcb:Atom:_NET_CLOSE_WINDOW)
            (let ((buffer (exwm--id->buffer id)))
              (when (buffer-live-p buffer)
                (exwm--defer 0 #'kill-buffer buffer))))
           ;; _NET_WM_MOVERESIZE
           ((= type xcb:Atom:_NET_WM_MOVERESIZE)
            (let ((direction (elt data 2))
                  (buffer (exwm--id->buffer id)))
              (unless (and buffer
                           (not (buffer-local-value 'exwm--floating-frame buffer)))
                (cond ((= direction
                          xcb:ewmh:_NET_WM_MOVERESIZE_SIZE_KEYBOARD)
                       ;; FIXME
                       )
                      ((= direction
                          xcb:ewmh:_NET_WM_MOVERESIZE_MOVE_KEYBOARD)
                       ;; FIXME
                       )
                      ((= direction xcb:ewmh:_NET_WM_MOVERESIZE_CANCEL)
                       (exwm-floating--stop-moveresize))
                      ;; In case it's a workspace frame.
                      ((and (not buffer)
                            (catch 'break
                              (dolist (f exwm-workspace--list)
                                (when (or (eq id (frame-parameter f 'exwm-outer-id))
                                          (eq id (frame-parameter f 'exwm-id)))
                                  (throw 'break t)))
                              nil)))
                      (t
                       ;; In case it's a floating frame,
                       ;; move the corresponding X window instead.
                       (unless buffer
                         (catch 'break
                           (dolist (pair exwm--id-buffer-alist)
                             (with-current-buffer (cdr pair)
                               (when
                                   (and exwm--floating-frame
                                        (or (eq id
                                                (frame-parameter exwm--floating-frame
                                                                 'exwm-outer-id))
                                            (eq id
                                                (frame-parameter exwm--floating-frame
                                                                 'exwm-id))))
                                 (setq id exwm--id)
                                 (throw 'break nil))))))
                       ;; Start to move it.
                       (exwm-floating--start-moveresize id direction))))))
           ;; _NET_REQUEST_FRAME_EXTENTS
           ((= type xcb:Atom:_NET_REQUEST_FRAME_EXTENTS)
            (let ((buffer (exwm--id->buffer id))
                  top btm)
              (if (or (not buffer)
                      (not (buffer-local-value 'exwm--floating-frame buffer)))
                  (setq top 0
                        btm 0)
                (setq top (window-header-line-height)
                      btm (window-mode-line-height)))
              (xcb:+request exwm--connection
                  (make-instance 'xcb:ewmh:set-_NET_FRAME_EXTENTS
                                 :window id
                                 :left 0
                                 :right 0
                                 :top top
                                 :bottom btm)))
            (xcb:flush exwm--connection))
           ;; _NET_WM_DESKTOP.
           ((= type xcb:Atom:_NET_WM_DESKTOP)
            (let ((buffer (exwm--id->buffer id)))
              (when (buffer-live-p buffer)
                (exwm-workspace-move-window (elt data 0) id))))
           ;; _NET_WM_STATE
           ((= type xcb:Atom:_NET_WM_STATE)
            (let ((action (elt data 0))
                  (props (list (elt data 1) (elt data 2)))
                  (buffer (exwm--id->buffer id))
                  props-new)
              ;; only support _NET_WM_STATE_FULLSCREEN / _NET_WM_STATE_ADD for frames
              (when (and (not buffer)
                         (memq xcb:Atom:_NET_WM_STATE_FULLSCREEN props)
                         (= action xcb:ewmh:_NET_WM_STATE_ADD))
                (xcb:+request
                    exwm--connection
                    (make-instance 'xcb:ewmh:set-_NET_WM_STATE
                                   :window id
                                   :data (vector xcb:Atom:_NET_WM_STATE_FULLSCREEN)))
                (xcb:flush exwm--connection))
              (when buffer                    ;ensure it's managed
                (with-current-buffer buffer
                  ;; _NET_WM_STATE_FULLSCREEN
                  (when (or (memq xcb:Atom:_NET_WM_STATE_FULLSCREEN props)
                            (memq xcb:Atom:_NET_WM_STATE_ABOVE props))
                    (cond ((= action xcb:ewmh:_NET_WM_STATE_ADD)
                           (unless (exwm-layout--fullscreen-p)
                             (exwm-layout-set-fullscreen id))
                           (push xcb:Atom:_NET_WM_STATE_FULLSCREEN props-new))
                          ((= action xcb:ewmh:_NET_WM_STATE_REMOVE)
                           (when (exwm-layout--fullscreen-p)
                             (exwm-layout-unset-fullscreen id)))
                          ((= action xcb:ewmh:_NET_WM_STATE_TOGGLE)
                           (if (exwm-layout--fullscreen-p)
                               (exwm-layout-unset-fullscreen id)
                             (exwm-layout-set-fullscreen id)
                             (push xcb:Atom:_NET_WM_STATE_FULLSCREEN props-new)))))
                  ;; _NET_WM_STATE_DEMANDS_ATTENTION
                  ;; FIXME: check (may require other properties set)
                  (when (memq xcb:Atom:_NET_WM_STATE_DEMANDS_ATTENTION props)
                    (when (= action xcb:ewmh:_NET_WM_STATE_ADD)
                      (unless (eq exwm--frame exwm-workspace--current)
                        (set-frame-parameter exwm--frame 'exwm-urgency t)
                        (setq exwm-workspace--switch-history-outdated t)))
                    ;; xcb:ewmh:_NET_WM_STATE_REMOVE?
                    ;; xcb:ewmh:_NET_WM_STATE_TOGGLE?
                    )
                  (xcb:+request exwm--connection
                      (make-instance 'xcb:ewmh:set-_NET_WM_STATE
                                     :window id :data (vconcat props-new)))
                  (xcb:flush exwm--connection)))))
           ((= type xcb:Atom:WM_PROTOCOLS)
            (let ((type (elt data 0)))
              (cond ((= type xcb:Atom:_NET_WM_PING)
                     (setq exwm-manage--ping-lock nil))
                    (t (exwm--log "Unhandled WM_PROTOCOLS of type: %d" type)))))
           ((= type xcb:Atom:WM_CHANGE_STATE)
            (let ((buffer (exwm--id->buffer id)))
              (when (and (buffer-live-p buffer)
                         (= (elt data 0) xcb:icccm:WM_STATE:IconicState))
                (with-current-buffer buffer
                  (if exwm--floating-frame
                      (call-interactively #'exwm-floating-hide)
                    (bury-buffer))))))
           (t
            (exwm--log "Unhandled: %s(%d)"
                       (x-get-atom-name type exwm-workspace--current) type)))))
    #+end_src

** Warning about use with =winner-mode=
   I struggled with hangs in EXWM that I of course attributed to EXWM
   or XELB.  The typical reproducible action was to initiate a floating dialog in an X11
   application such as Zoom, or the Open File dialog from a web browser (for example).
   Depending on the timing, I would see a message in Emacs similar to
   #+begin_example
     Error in post-command-hook (winner-save-old-configurations): (wrong-type-argument frame-live-p #<dead frame Open File 0x558a5304a578>)
   #+end_example

   The problem is a failure to check for dead frames before saving window configurations.
   The solution I use is to add advice before one function that removes dead frames from
   the list of frames.

   #+begin_src emacs-lisp :tangle no
     ;; Add advice to stop hangs on EXWM
     ;; The problem happens with floating windows that disappear - like open file dialog or a Zoom dialog when starting a meeting
     ;; The solution is to assure all frames in winner-modified-list pass the frame-live-p test
     (defun gjg/winner-clean-up-modified-list ()
       "Remove dead frames from `winner-modified-list`"
       (dolist (frame winner-modified-list)
         (unless (frame-live-p frame)
           (delete frame winner-modified-list))))
     (advice-add 'winner-save-old-configurations :before #'gjg/winner-clean-up-modified-list)

   #+end_src
** Recommended changes to workflow when using a tiling window manager
*** Web browser should open new windows rather than tabs
    Doing this allows Emacs to search window/tab titles.  It's a weird change at first,
    but it's a much better experience in a tiling window manager that has good search.

    In Firefox, you can go to =about:preferences=.  Under the *Tabs*, uncheck =Open links
    in tabs instead of new windows=

    If you want to make a radical change, find an extension for your web browser that
    disallows tabs altogether - so even when you explicitly ask to open a new tab, the
    extension makes it a new window.
*** Scripts will be required to handle operations normally managed by Desktop Environment
    I have moved all the generated scripts and configs I use to support EXWM - and
    theoretically any other tiling window manager - to [[file:Desktop.org][this Org file]].  I use that Org file to
    generate (tangle) everything I need in a Linux environment.

*** Launching applications without a Desktop Environment
    EXWM default config suggests a handy shell launch command from Emacs, but I prefer to
    use exactly what I do on every other OS - a pop-up app launcher such as [[https://github.com/albertlauncher/albert][Albert]] or ulauncher.

** Unresolved problems
*** TODO Fix clipboard integration / behavior
    + The problem is consistent cut/paste copy/yank behavior between Emacs windows and
      managed X windows.

      + Copy text in Emacs -> paste to Firefox works in =char= mode

      + Copy text in Emacs -> paste to Firefox in =line= mode no worky - have to use right
        mouse click or =S-<insert>  *how to define simulation key??*

      + Copy text in Firefox =char= mode -> yank in Emacs works

      + Copy text in Firefox =line= mode using =M-w= -> yank in Emacs works


** System tray widgets
   EXWM has a system tray that can be enabled, and some panel widgets work with it.  For
   me, I'd rather either use pure Emacs or Linux shell methods of getting info and setting
   values, *or* just go ahead and use a "proper" panel.

    I have found that both =xfce4-panel= and the LXDE panel work a treat!  For
    =xfce4-panel= do *not* check =Don't reserve space on borders= - that way the panel
    will not obscure the echo area at the very bottom of the screen

    One can either bring up Emacs with no DE and then run the panels as processes, or
    hijack the default window manager in one of the lightweight DEs.

*** Useful panel widgets
      + [[https://docs.xfce.org/panel-plugins/clipman/start][xfce4-clipman - a clipboard manager]]
      + parcellite - a different clipboard manager
      + /usr/bin/python3 /usr/share/system-config-printer/applet.py - printer notifications
      + nm-applet --indicator  - NetworkManager applet - absolutely needed
      + /usr/lib/blueberry/blueberry-tray.py - a Blueberry setup app triggered from the panel
      + /usr/bin/python3 /usr/bin/blueman-applet - a *nicer* bluetooth applet with setup
        and file transfer

** Panel with Polybar

   Polybar is a highly  customizable alternative to the XFCE Panel

   Check out the Polybar wiki for more details on how to configure it: https://github.com/polybar/polybar/wiki

   + [[https://awesomeopensource.com/projects/polybar][The Top 422 Polybar Open Source Projects on Github]]


*** Integration with =emacsclient=

   Polybar provides a great, minimalistic panel for your EXWM desktop configuration.  The
   following config integrates =emacsclient= and Polybar with =polybar-msg= to enable you
   to gather *any* information from Emacs and display it in the panel!

   Functions are defined in [[file:gjg-functions.org::*Polybar for use with Linux EXWM and desktop environments][Polybar for use with Linux EXWM and desktop environments]]

*** Panel configuration
    Configurations and script for Polybar are kept in gregoryg/homelab/README-dotfiles

*** Helpful Polybar scripts
**** hideIt.sh - hide *any* X window - we will use it just for polybar
     Polybar - remarkably and shockingly - does not have an autohide feature (I believe).

     So there is a clever script called [[https://raw.githubusercontent.com/Tadly/hideIt.sh/master/hideIt.sh][hideIt.sh]] - which will actually work for any X window

     My current variation is based on [[https://github.com/Tadly/hideIt.sh][Tadly's hideIt.sh]]

     Script(s) and desktop shortcuts are to be found in [[file:Desktop.org][Desktop.org]]
** Interaction between Emacs and X applications
   Emacsclient with --eval allows for some great interactions between the shell and Emacs.
   Let's create a combination of Emacs Lisp and shell script for some of these.

*** Jump to or launch application like Gmail or Spotify
    If we already have a browser window running, select it and bring it to the foreground.
    If not, launch it, showing just unread threads.
**** Function =gjg/exwm-switch-to-buffer-or-launch=

     #+begin_src emacs-lisp
       (defun gjg/exwm-switch-to-buffer-or-launch (searchstring &optional application)
         "Switch to the first buffer matching SEARCHSTRING as a substring
          If no matching buffer is found, launch the APPLICATION using gtk-launch."
         (let
             ((mybuf (car (cl-remove-if-not (lambda (row) (cl-search searchstring (buffer-name row))) (buffer-list)))))
           (if mybuf
               (switch-to-buffer mybuf)
             (if application
                 (call-process-shell-command (concat "gtk-launch " application))
               (message "No \"%s\" window is running." searchstring)))))
     #+end_src
**** Shell script to select corporate Gmail window with unread threads
     This shell script can be called from Polybar (my config includes a button that
     invokes this script)

    #+begin_src bash :tangle ~/bin/gmail-buffer-or-launch.sh
      emacsclient -e '(gjg/exwm-switch-to-buffer-or-launch (concat gjg/employer-name " Mail") "gmail")'
    #+end_src
**** Function to select WHATEVER IS PLAYING MUSIC
     This makes use of the `playerctl` command to give us the window title

     #+begin_src emacs-lisp
       ; playerctl statuses: Stopped / Paused / Playing
       (defun gjg/exwm-select-music-window ()
         "Select the window currently playing audio as determined by playerctl."
         (interactive)
         (let* ((playerctlrtn (with-temp-buffer
                                (list (apply
                                       'call-process
                                       "playerctl" nil (current-buffer) nil
                                       '("metadata" "title"))
                                      (substring (buffer-string) 0 -1))))
                (exitcode     (nth 0 playerctlrtn))
                (window-title (nth 1 playerctlrtn)))
           (if (zerop exitcode)
               (gjg/exwm-switch-to-buffer-or-launch window-title)
             (message "No recognized audio player."))))

     #+end_src
**** Function to select or launch Google Chat
     #+begin_src emacs-lisp
       (defun gjg/exwm-select-or-launch-google-chat ()
         "Select the running Google Chat window in EXWM, or launch the app"
         (interactive)
         (gjg/exwm-switch-to-buffer-or-launch "GChat" "google-chat"))
     #+end_src
**** Function to select or launch Logseq
     #+begin_src emacs-lisp
       (defun gjg/exwm-select-or-launch-logseq ()
         "Select the running Spotify window in EXWM, or launch the app"
         (interactive)
         (gjg/exwm-switch-to-buffer-or-launch "Logseq App" "com.logseq.Logseq"))
     #+end_src
**** Function to select or launch Spotify
     #+begin_src emacs-lisp
       (defun gjg/exwm-select-or-launch-spotify ()
         "Select the running Spotify window in EXWM, or launch the app"
         (interactive)
         (gjg/exwm-switch-to-buffer-or-launch "Spotify" "spotify"))
     #+end_src
**** Function to switch quickly to Zoom Meeting
     #+begin_src emacs-lisp
       (defun gjg/exwm-select-zoom-meeting ()
         "Select the running Zoom Meeting window if it's running."
         (interactive)
         (gjg/exwm-switch-to-buffer-or-launch "Zoom Meeting"))
     #+end_src
**** Function to switch quickly to Microsoft Teams in Edge
     #+begin_src emacs-lisp
       (defun gjg/exwm-select-teams-meeting ()
         "Select the running Microsoft Teams window if it's running."
         (interactive)
         (gjg/exwm-switch-to-buffer-or-launch "Microsoft Teams â‰« teams.microsoft.com"))
     #+end_src
**** Function to switch quickly to good ole Slack
     #+begin_src emacs-lisp
       (defun gjg/exwm-select-slack ()
         "Select the running Slack window if it's running, otherwise launch."
         (interactive)
         (gjg/exwm-switch-to-buffer-or-launch "slack stardog" "com.slack.Slack"))
     #+end_src
*** Update Spotify's buffer name when song changes
    If running EXWM, let's keep Spotify's buffer name hip
    #+begin_src emacs-lisp
      (defun gjg/update-spotify-exwm-window (songname)
        "When running EXWM add current song name to buffer name"
        ;; find the buffer
        (when (frame-parameter (selected-frame) 'exwm-active)
          (dolist (mybuf (cl-remove-if-not (lambda (row) (cl-search "Spotify" (buffer-name row))) (buffer-list)))
            (with-current-buffer mybuf
              (when (string= "Spotify" exwm-class-name) (exwm-workspace-rename-buffer (concat exwm-class-name " - " songname)))))))
    #+end_src
    #+begin_src bash :tangle ~/bin/update-spotify-exwm.sh
      # Called from dunst when Spotify makes a notification (changes song)
      # Dunst passes these parameters in order: appname, summary, body, icon, urgency
      echo $0 >> /tmp/update-spotify.log
      summary=$2
      body=$3
      # emacsclient -e "(gjg/update-spotify-exwm-window \"${summary} - ${body}\")"
      # emacsclient -e "(gjg/update-spotify-exwm-window \"${body}\")"
      emacsclient -e "(gjg/update-spotify-exwm-window \"${summary}\")"
    #+end_src
*** Select apps such as secondary Emacs to start in char-mode, start floating/tiled etc.
    Set certain windows to start in char-mode, floating/tiled etc
    #+begin_src emacs-lisp
      (setq exwm-manage-configurations
            '(((member exwm-class-name '("Emacs" "Gnome-terminal" "konsole" "libreoffice-calc" "xdg-desktop-portal-gnome" "kitty" "UXTerm"))
               char-mode t)
              ((member exwm-class-name '("Pavucontrol"))
               floating t)
              ;; ((and (string= "zoom" exwm-class-name) (string= "Settings" exwm-title))
              ;;  floating t)
              ))
    #+end_src
** To launch or not to launch
   My configuration tests for the existence of a window manager.  If one is already
   running, just skip all the EXWM setup and bring up a "normal" Emacs instance.

   I shared this solution in an Emacs Stackexchange question: [[https://emacs.stackexchange.com/a/60455/418][Launch EXWM only when no another WM or DE are being used]]

#+begin_src emacs-lisp
  (when (get-buffer "*window-manager*")
    (kill-buffer "*window-manager*"))
  (when (get-buffer "*window-manager-error*")
    (kill-buffer "*window-manager-error*"))
  (when (executable-find "wmctrl")
    (progn
      (shell-command "wmctrl -m ; echo $?" "*window-manager*" "*window-manager-error*")))
  (setq gjg/exwm-needed-p
        (and (get-buffer "*window-manager-error*")
             (eq window-system 'x)))
#+end_src
** Let's get this show on the road - if no window manager was detected
   We start a large =when= block here
 #+begin_src emacs-lisp
   (when gjg/exwm-needed-p
 #+end_src
*** Start wallpaper with transparency first for aesthetics
    Script below is generated with the [[file:Desktop.org][Org file referenced above]]
    #+begin_src emacs-lisp
      (set-opacity 85)
      (async-start-process "wallpaper-thang"  "nohup" nil (expand-file-name "~/bin/schedule-rotate-wallpapers.sh") "&")
    #+end_src
*** My specific config function
    I did not want =ido= integration and wanted to evolve my config.  So I copied the
    default config function and commenced modifying

    This sets the amazing simulation keys.  What does that little miracle do for us? It
    gives us Emacs keys in Firefox, that's what it does!  And other X applications, of
    course.

    So now we can hit =C-n= to move to the next line.  I use =C-s= to search in Firefox,
    which translates to sending a =C-f=.  There's more I want to configure but I haven't
    entirely figured out how this works in char mode, whether it works with the Super key
    and so forth.

    RESERVED for OBS Studio:
    + Super-X
    + Super-C
    + Super-/


    TODO: Define super-{left,right,0,1,2} to mean the same thing I have in the global
    keymap: windmove etc.

    TODO: Define simulation key for "Print"
     #+begin_src emacs-lisp
         (defun gjg/exwm-config ()
       "Config for moi.  Initially this is a copy of exwm-config-example, but cutting out the ido integration"
       ;; Set the initial workspace number.
       ;; (unless (get 'exwm-workspace-number 'saved-value)
       ;;   (setq exwm-workspace-number 2)) ; GJG changed from default
       ;; Global keybindings.
       ;; (unless (get 'exwm-input-global-keys 'saved-value)
       (message "Setting exwm-input-global-keys")
       (setq exwm-input-global-keys
             `(
           ([?\s-i] . exwm-input-toggle-keyboard) ; toggle line/char mode
           (,(kbd "s-<escape>") . gjg/lock-screen)
           ;; 's-r': Reset (to line-mode).
           ([?\s-r] . exwm-reset)
           ([?\s-s] . save-some-buffers)
           ([?\s-f] . exwm-floating-toggle-floating)
           ;; 's-w': Switch workspace.
           ([?\s-w] . exwm-workspace-switch) ;; use this to switch workspaces, not S-<number>
           ;; 's-&': Launch application. - poor man's albert/launchy
           ([?\s-&] . (lambda (command)
                    (interactive (list (read-shell-command "$ ")))
                    (start-process-shell-command command nil command)))
           ;; 's-&': Launch application. - poor man's albert/launchy
           ([?\s-7] . (lambda (command)
                    (interactive (list (read-shell-command "$ ")))
                    (start-process-shell-command command nil command)))
           ([?\s-o] .  gjg/other-window-with-winum)
           ([s-left] . windmove-left)
           ([s-right] . windmove-right)
           ([s-up] . windmove-up)
           ([s-down] . windmove-down)
           ([M-s-up] . windmove-delete-up)
           ([M-s-down] . windmove-delete-down)
           ([M-s-left] . windmove-delete-left)
           ([M-s-right] . windmove-delete-right)
           (,(kbd "M-SPC") . gjg/launch-rofi)
           (,(kbd "s-SPC") . app-launcher-run-app)
           ([?\s-e] . gjg/ibuffer-only-exwm)
           ([s-backspace] . bury-buffer)
           ([?\s-q] . bury-buffer)
           ([?\s-\\] . switch-to-buffer )
           ([?\s-a] . gjg/open-work-agenda)
           ([?\s-b] . gjg/switch-to-other-buffer)
           ([?\s-0] . delete-window)
           ([?\s-1] . delete-other-windows)
           ([?\s-2] . gjg/split-window-below)
           ([?\s-3] . gjg/split-window-right)
           ;; ([?\s-c] . (lambda () (interactive) (call-process-shell-command "invert-color.sh")))
           ([?\s-j] . org-clock-goto)
           ([?\s-p] . playerctl-play-pause-song)
           ([?\s-t] . toggle-truncate-lines)
           ([?\s-g] . gjg/exwm-select-or-launch-logseq)
           ([?\s-k] . gjg/exwm-select-slack)
           ([?\s-c] . gjg/exwm-select-or-launch-google-chat)
           ([?\s-y] . gjg/exwm-select-or-launch-spotify)
           (,(kbd "<XF86MonBrightnessUp>") . (lambda () (interactive) (call-process-shell-command "gjg-bright.sh +5")))
           (,(kbd "<XF86MonBrightnessDown>") . (lambda () (interactive) (call-process-shell-command "gjg-bright.sh -5")))
           (,(kbd "<XF86AudioRaiseVolume>") . (lambda () (interactive) (gjg/volume "up")))
           (,(kbd "<XF86AudioLowerVolume>") . (lambda () (interactive) (gjg/volume "down")))
           (,(kbd "<XF86AudioMute>") . (lambda () (interactive) (gjg/volume "togmute")))
           (,(kbd "<XF86AudioPlay>") . playerctl-play-pause-song)
           ([?\s--] . gjg/exwm-select-zoom-meeting)
           ([?\s-=] . gjg/exwm-select-teams-meeting)
           ([?\s-.] . (lambda () (interactive) (find-file "~/emacs-gregoryg/README.org")))
           ([?\s-,] . gjg/polybar-start-or-toggle)

           ;; GJG: I don't make much use of workspaces, so don't need the insta-create capability
           ;; 's-N': Switch to certain workspace.
           ;; ,@(mapcar (lambda (i)
           ;;             `(,(kbd (format "s-%d" i)) .
           ;;               (lambda ()
           ;;                 (interactive)
           ;;                 (exwm-workspace-switch-create ,i))))
           ;;           (number-sequence 4 9))
           ))
       ;; )
       ;; Line-editing shortcuts
       (unless (get 'exwm-input-simulation-keys 'saved-value)
         (setq exwm-input-simulation-keys
           '(([?\C-b] . left)
             ([?\C-f] . [right])
             ([?\C-p] . [up])
             ;; ([?\C-P] . [?\C-p]) ; Print
             ([?\C-n] . [down])
             ([?\C-a] . [home])
             ([?\C-e] . [end])
             ([?\M-v] . [prior])
             ([?\C-v] . [next])
             ([?\C-d] . [delete])
             ([?\C-k] . [S-end delete])
             ([?\C-l] . [?\C-l])
             ([?\C-t] . [?\C-t])
             ([?\C-s] . [?\C-f]) ; I'm gonna search/find a better way
             ([?\M-w] . [?\C-c]) ; Copy that!
             ;; ([?\S-p] . [?\C-p]) ; TODO Print - not working
             ([?\C-y] . [?\C-v]) ; yank/paste
             )))
       ;; Enable EXWM
       (exwm-enable)
       ;; ;; Configure Ido
       ;; (exwm-config-ido)
       ;; Other configurations
       ;; (exwm-config-misc)
       )
     #+end_src
*** Require packages and run my custom conifg
  #+begin_src emacs-lisp
    ;; (< 0 (length (with-current-buffer "*window-manager-error*" (buffer-string)))))
    (require 'exwm)
    (require 'exwm-config)
    (gjg/exwm-config)
  #+end_src
*** Configure hooks
**** Deal with displays
    When an external monitor is connected or disconnected, =exwm-randr-screen-change-hook=
    is called.

    The single command I currently run adds my external widescreen monitor to the left of
    the internal display.

    Disconnecting the external monitor was not working well until I started using
    =autorandr= with a laptop-only and a monitor-connected profile.  I allow autodetection
    of the appropriate profile with the =--change= parameter.  The solution came from a
    [[https://www.reddit.com/r/emacs/comments/j0zda7/exwm_randr_config_for_laptop_disconnect/?utm_source=share&utm_medium=web2x&context=3][post on /r/emacs]]

        #+begin_src emacs-lisp
          (require 'exwm-randr)
          ;; (setq exwm-randr-workspace-monitor-plist '(0 "DP-1")) ;; DP-1 is the big monitor, if connected
          (setq exwm-randr-workspace-monitor-plist '(0 "DP-3" 1 "eDP-1")) ;; DP-3 is the big monitor, if connected

          (add-hook 'exwm-randr-screen-change-hook
                    (lambda()
                      (message "Starting exwm-randr-screen-change-hook")
                      (start-process-shell-command
                       "autorandr" nil "autorandr --change ; autorandr"
                       ;; "xrandr" nil "xrandr --output eDP-1 --mode 1920x1200 --pos 0x0 --rotate normal"
                       ;; WORKS WHEN ADDING MONITOR, NOT WHEN DISCONNECTING "xrandr" nil "xrandr --output eDP-1 --mode 1920x1200 --pos 0x0 --rotate normal --output DP-3 --primary --mode 3440x1440 --left-of eDP-1 --rotate normal"
                       ;; and here's how I might get a mirrored setup
                       ;; xrandr --output eDP-1 --mode 1920x1080 --output DP-3 --mode 1920x1080 --same-as eDP-1
                       )))
        #+end_src
**** Intelligently rename new buffers
    By default, each new window's buffer is named by the 'class name': So Firefox, Slack,
    Alacritty and so on.  This means that I will get similar buffer names for each new
    Firefox window: Firefox<1>, Firefox<2>....

    Examining both =exwm-class-name= and =exwm-title= allows us to rename the buffers so
    that navigation via regular Emacs commands is made easy.

        #+begin_src emacs-lisp
          ;; Make class name the buffer name
          (add-hook 'exwm-update-class-hook
                    (lambda ()
                      (cond
                       (:else
                        (exwm-workspace-rename-buffer exwm-class-name)))))
          (add-hook 'exwm-update-title-hook
                    (lambda ()
                      (let ((browsers '(("Mozilla Firefox" . "firefox")
                                        ("Personal - Microsoftâ€‹ Edge" . "edge")
                                        ("Google Chrome" . "chrome")
                                        ("Chromium" . "chromium"))))
                            (cond
                             ;; Browser titles
                             ((s-starts-with-p "Mail - Greg Grubbs - Outlook - " exwm-title)
                              (exwm-workspace-rename-buffer "email - outlook"))
                             ((s-starts-with-p "Calendar - Greg Grubbs - Outlook" exwm-title)
                              (exwm-workspace-rename-buffer "calendar - outlook"))
                             ((s-starts-with-p "Google Hangouts - " exwm-title)
                              (exwm-workspace-rename-buffer "hangouts"))
                             ((s-matches? ".?Chat .+ mail.google.com" exwm-title)
                              (exwm-workspace-rename-buffer (s-replace "Chat " "GChat " exwm-title)))
                             ;; standalone apps
                             ((string= "Slack" exwm-class-name)
                              (exwm-workspace-rename-buffer (concat "slack stardog" "- " exwm-title)))
                             ((string= "Logseq" exwm-class-name)
                              (exwm-workspace-rename-buffer (concat exwm-title " - " exwm-class-name " App")))
                             ((member exwm-class-name '("Eom" "Eog" "zoom" "Spotify" ))
                              (exwm-workspace-rename-buffer (concat exwm-title " - " exwm-class-name)))
                             (:else
                              (exwm-workspace-rename-buffer
                               (s-replace-all browsers exwm-title)))))))
        #+end_src
**** Clean up on exit
     #+begin_src emacs-lisp
       (add-hook 'exwm-exit-hook
                 (lambda ()
                   (async-start-process "exwm-exit" "pkill" nil "-f" "schedule-rotate-wallpapers.sh" )))
     #+end_src

*** Start up the window manager
    As noted above, I do not use the EXWM system tray.
        #+begin_src emacs-lisp
	  (exwm-enable)
	  ;; (require 'exwm-systemtray)
	  ;; (exwm-systemtray-enable)
        #+end_src
*** Start up xrandr to react to display changes
        #+begin_src emacs-lisp
	  (exwm-randr-enable)
        #+end_src

*** Deal with brightness and volume, since we don't have a DE
    There is a =desktop-environment= package on Melpa, but it's overkill for what I need.
    TODO: Figure out how to specify these keys and modify =exwm-input-global-keys=
    instead.  This section doesn't work

        #+begin_src emacs-lisp :tangle no
          (exwm-input-set-key (kbd "<XF86MonBrightnessUp>")
                              (lambda ()
                                (interactive)
                                (call-process-shell-command "gjg-bright.sh +5")))
          (exwm-input-set-key (kbd "<XF86MonBrightnessDown>")
                              (lambda ()
                                (interactive)
                                (call-process-shell-command "gjg-bright.sh -5")))
          ;; N.B. keyboard backlight level (0 1 2) is kept in /sys/class/leds/dell\:\:kbd_backlight/brightness
          (exwm-input-set-key (kbd "<XF86AudioRaiseVolume>")
                              (lambda ()
                                (interactive)
                                (call-process-shell-command "amixer sset 'Master' 5%+")))
          (exwm-input-set-key (kbd "<XF86AudioLowerVolume>")
                              (lambda ()
                                (interactive)
                                (call-process-shell-command "amixer sset 'Master' 5%-")))
          (exwm-input-set-key (kbd "<XF86AudioMute>")
                              (lambda ()
                                (interactive)
                                (call-process-shell-command "amixer sset 'Master' toggle")))
        #+end_src
*** Navigate and manipulate windows
    Now that we will be running *everything* in Emacs, we will be doing a lot of window
    switching and frame splitting.  Here are some ways to bring sanity to that process and
    hopefully ease Emacs Pinky Syndrome.

    =buffer-expose= is an alternative to alt-tab

    TODO: look for alternative to buffer-expose, as it does not play
    well with EXWM - many times the EXWM windows such as the browsers
    become unusable, with click and normal keyboard events throwing
    warnings/errors
    Oneto consider:
    + [[https://github.com/casouri/emacs-mission-control][GitHub - casouri/emacs-mission-control: Mac mission-control-like buffer switch]]
      #+begin_src emacs-lisp :tangle no
        (straight-use-package
         '(mission-control
           :type git
           :host github
           :repo "casouri/emacs-mission-control"))
        (use-package mission-control :straight t
          :config
          (mcon-c-tab-setup-binding))
      #+end_src

*** Start the OS processes
    #+begin_src emacs-lisp
      (call-process-shell-command (expand-file-name "~/bin/emacswm.sh"))
      (setenv "EDITOR" "emacsclient")
    #+end_src

** And FINALLY - this must be last - close out the =when= clause
        #+begin_src emacs-lisp
        ) ;; when gjg/exwm-needed-p
        #+end_src

* Commonly used modes
** Start emacs server
   #+begin_src emacs-lisp
     (require 'server)
     (unless (server-running-p)
       (server-start))
   #+end_src
** Yafolding Mode
   Yafolding mode is useful in code and (maybe even but probably not in) Org.  Let's keep
   Org mode's keys unmolested, and use an additional modifier to toggle hide/show
   #+begin_src emacs-lisp
     (use-package yafolding :straight t
       :init
       (unbind-key (kbd "<C-return>") yafolding-mode-map)
       (unbind-key (kbd "<C-S-return>") yafolding-mode-map)
       (unbind-key (kbd "<C-M-return>") yafolding-mode-map)

       (define-key yafolding-mode-map (kbd "C-'") #'yafolding-toggle-element)
       (define-key yafolding-mode-map (kbd "C-M-'") #'yafolding-toggle-all))
       ;; (define-key yafolding-mode-map (kbd "<C-S-return>") #'yafolding-toggle-all)
       ;; (define-key yafolding-mode-map (kbd "<C-M-return>") #'yafolding-toggle-element))
   #+end_src
** Project.el
   Project.el is built in

   #+begin_src emacs-lisp
     ;; (use-package project :straight t)
     (setq project-switch-commands
        '((project-find-file "Find file")
          (project-find-regexp "Find regexp")
          (project-find-dir "Dired somewhere")
          (project-dired "Root dired" ?r)
          (project-shell "Shell" ?s)
          (magit-project-status "Magit" ?m)
          (treemacs-add-and-display-current-project "Treemacs" ?t)))
     (defun gjg/project-dired-choose ()
       "Visit a directory (with completion) in the current project."
       (interactive)
       (let* ((pr (project-current t))
              (dir (expand-file-name "~/projects/homelab"))
              (localdir (file-name-unquote (file-local-name (expand-file-name dir))))
              (dirs (process-file-shell-command (format "%s -H %s -type d " find-program (shell-quote-argument (directory-file-name localdir))))))

         (completing-read "Ohai: " dirs)))
         ;; (message dirs)))

         ;; (project-find-file-in (thing-at-point 'filename) dirs pr)))
   #+end_src
** EDE
   I have no use for the built-in EDE.  The only thing EDE does for me is to steal the
   =C-c .= keystroke away from Org Mode - thanks for nothin' EDE.

   I'll just remap the keys to the currently-unused =C-c e=

   #+begin_src emacs-lisp
     (with-eval-after-load 'ede
       (define-key ede-minor-mode-map (kbd "C-c e")
                   (lookup-key ede-minor-mode-map (kbd "C-c .")))
       (unbind-key (kbd "C-c .") org-mode-map))
   #+end_src

** Corfu - auto-complete and more
   I want something for auto-complete that behaves more like selectrum and other such
   tools

   + [[https://github.com/minad/corfu][GitHub - minad/corfu: corfu.el - Completion Overlay Region FUnction]]
   #+begin_src emacs-lisp
     (use-package corfu :straight t
       ;; Optional customizations
       :custom
       ;; (corfu-cycle t)                ;; Enable cycling for `corfu-next/previous'
       (corfu-auto t)                 ;; Enable auto completion
       (corfu-separator ?\s)          ;; Orderless field separator
       ;; (corfu-quit-at-boundary nil)   ;; Never quit at completion boundary
       ;; (corfu-quit-no-match nil)      ;; Never quit, even if there is no match
       ;; (corfu-preview-current nil)    ;; Disable current candidate preview
       ;; (corfu-preselect-first nil)    ;; Disable candidate preselection
       ;; (corfu-on-exact-match nil)     ;; Configure handling of exact matches
       ;; (corfu-echo-documentation nil) ;; Disable documentation in the echo area
       ;; (corfu-scroll-margin 5)        ;; Use scroll margin

       ;; Enable Corfu only for certain modes.
       ;; :hook ((prog-mode . corfu-mode)
       ;;        (shell-mode . corfu-mode)
       ;;        (eshell-mode . corfu-mode))

       ;; Recommended: Enable Corfu globally.
       ;; This is recommended since Dabbrev can be used globally (M-/).
       ;; See also `corfu-excluded-modes'.
       (corfu-excluded-modes '(shell-mode vterm-mode comint-mode))
       :init
       (global-corfu-mode))


     ;; Add extensions
     (use-package cape :straight t
       :config
       (setq cape-dabbrev-check-other-buffers nil)
     ;;   ;; Bind dedicated completion commands
     ;;   ;; Alternative prefix keys: C-c p, M-p, M-+, ...
       :bind (("C-c p p" . completion-at-point) ;; capf
     ;;          ("C-c p t" . complete-tag)        ;; etags
              ("C-c p d" . cape-dabbrev)        ;; or dabbrev-completion
     ;;          ("C-c p h" . cape-history)
              ("C-c p f" . cape-file)
     ;;          ("C-c p k" . cape-keyword)
     ;;          ("C-c p s" . cape-symbol)
     ;;          ("C-c p a" . cape-abbrev)
     ;;          ("C-c p i" . cape-ispell)
     ;;          ("C-c p l" . cape-line)
     ;;          ("C-c p w" . cape-dict)
     ;;          ("C-c p \\" . cape-tex)
     ;;          ("C-c p _" . cape-tex)
     ;;          ("C-c p ^" . cape-tex)
     ;;          ("C-c p &" . cape-sgml)
     ;;          ("C-c p r" . cape-rfc1345))
              )
       :init
       ;; Add `completion-at-point-functions', used by `completion-at-point'.
       (add-to-list 'completion-at-point-functions #'cape-dabbrev)
       (add-to-list 'completion-at-point-functions #'cape-file)
     ;;   ;;(add-to-list 'completion-at-point-functions #'cape-history)
     ;;   ;;(add-to-list 'completion-at-point-functions #'cape-keyword)
     ;;   ;;(add-to-list 'completion-at-point-functions #'cape-tex)
     ;;   ;;(add-to-list 'completion-at-point-functions #'cape-sgml)
     ;;   ;;(add-to-list 'completion-at-point-functions #'cape-rfc1345)
     ;;   ;;(add-to-list 'completion-at-point-functions #'cape-abbrev)
     ;;   ;; (add-to-list 'completion-at-point-functions #'cape-ispell)
     ;;   ;;(add-to-list 'completion-at-point-functions #'cape-dict)
     ;;   ;;(add-to-list 'completion-at-point-functions #'cape-symbol)
     ;;   ;;(add-to-list 'completion-at-point-functions #'cape-line)
       )


     (use-package orderless :straight t
       :init
       (setq completion-styles '(orderless basic)
         completion-category-defaults nil
         completion-category-overrides '((file (styles . (partial-completion))))))

     ;; A few more useful configurations...
     ;; (use-package emacs :straight t
     ;;
     ;;   :init
     ;;   ;; TAB cycle if there are only few candidates
     ;;   (setq completion-cycle-threshold 3)

     ;;   ;; Emacs 28: Hide commands in M-x which do not apply to the current mode.
     ;;   ;; Corfu commands are hidden, since they are not supposed to be used via M-x.
     ;;   ;; (setq read-extended-command-predicate
     ;;   ;;       #'command-completion-default-include-p)

     ;;   ;; Enable indentation+completion using the TAB key.
     ;;   ;; `completion-at-point' is often bound to M-TAB.
     ;;   (setq tab-always-indent 'complete))
   #+end_src
** Marginalia - crazy annotations for completions
   #+begin_src emacs-lisp
     (use-package marginalia :straight t
       :bind (("M-A" . marginalia-cycle)
              :map minibuffer-local-map
              ("M-A" . marginalia-cycle)
              )
       :init
       (marginalia-mode))
   #+end_src
** Markdown
   It's common to have very long lines in Markdown text - so turn on =longlines-mode=
   with word wrapping only for those files.
   #+begin_src emacs-lisp
     (use-package markdown-mode :straight t
       :hook
       (markdown-mode . visual-line-mode)
     )
   #+end_src
** TRAMP
*** Tramp general config
    TRAMP may prompt for passphrase for =~/.authinfo.gpg= upon nearly every invocation if
    =tramp-completion-use-auth-sources= is t.  So .... don't do that.
    #+begin_src emacs-lisp
      (custom-set-variables '(tramp-completion-use-auth-sources nil)
                            '(tramp-allow-unsafe-temporary-files t))
    #+end_src
*** Tweak remote bash shell prompt PS1
    #+begin_src bash :tangle ~/.emacs.d/init_bash.sh
      # Reset the prompt for remote TRAMP shells.
      if [ "${INSIDE_EMACS/*tramp*/tramp}" == "tramp" ] ; then
      #   PS1="[\u@\h \w]$ "
         PS1="[$(echo $PS1 | cut -d':' -f 1-2 ):\w]$ "
      fi
    #+end_src
*** Add methods for Docker, DC/OS, Google Cloud Shell
**** Add a helper script for Kubernetes =kube= method

     + Firstly, implement my custom way of handling multiple clusters
       #+begin_src bash :tangle ~/bin/load-kubeconfigs.sh
         # Stolen from https://medium.com/@alexgued3s/multiple-kubeconfigs-no-problem-f6be646fc07d

         # Start by "resetting" KUBECONFIG
         unset KUBECONFIG
         # If there's already a kubeconfig file in ~/.kube/config it will import that too and all the contexts
         DEFAULT_KUBECONFIG_FILE="$HOME/.kube/config"
         if test -f "${DEFAULT_KUBECONFIG_FILE}"
         then
           export KUBECONFIG="$DEFAULT_KUBECONFIG_FILE"
         fi
         # Your additional kubeconfig files should be inside ~/.kube/config-files
         ADD_KUBECONFIG_FILES="$HOME/.kube/config-files"
         mkdir -p "${ADD_KUBECONFIG_FILES}"

         OIFS="$IFS"
         IFS=$'\n'
         for kubeconfigFile in `find "${ADD_KUBECONFIG_FILES}" -type f -name "*.yml" -o -name "*.yaml"`
         do
             export KUBECONFIG="$kubeconfigFile:$KUBECONFIG"
         done
         IFS="$OIFS"
       #+end_src
     + This will work with the custom method.  It will honor the existing setting of
       context namespace, so set that first if the Pod is running in something other than
       =default= namespace.

       E.g.
       #+begin_src bash
         kn poodle # using alias
         kubectl config set-context --current --namespace poodle # full cmd
       #+end_src
       #+begin_src bash :tangle ~/bin/mykubectl
         source ~/bin/load-kubeconfigs.sh
         kubectl $@
       #+end_src

**** Define TRAMP methods
    #+begin_src emacs-lisp
      ;; add method to connect to Mesosphere DC/OS tasks
      ;; we need to execute a command like the following
      ;;  dcos task exec --tty --interactive <taskname> -- bash
      ;; example TRAMP URI:   //dcos:jupyter:
      (require 'tramp)
      (with-eval-after-load 'tramp
        ;; Add method to connect to Kubernetes pods
        ;; we need to execute a command like the following
        ;;  kubectl exec -it --namespace jhub jupyter-gregj -- /bin/bash
        ;; example TRAMP URI:   //kexec:jhub@jupyter:
        (add-to-list 'tramp-methods
                     '("kube"
                       (tramp-login-program "~/bin/mykubectl")
                       (tramp-login-args
                        (nil
                         ("exec" "-it")
                         ("--namespace" "%u")
                         ("%h")
                         ("--" "sh")))
                       (tramp-remote-shell "/bin/sh")
                       (tramp-remote-shell-args ("-i" "-c"))))

        ;; Google Cloud Shell
        (add-to-list 'tramp-methods
                     '("gshell"
                       (tramp-login-program        "gcloud alpha cloud-shell ssh")
                       (tramp-default-host "cloud-shell")
                       (tramp-login-args (("#%h")))
                       ;; (tramp-login-args           (("%h")))
                       ;; (tramp-async-args           (("-q")))
                       (tramp-remote-shell         "/bin/bash")
                       (tramp-remote-shell-args    ("-c"))
                       ;; (tramp-gw-args              (("-o" "GlobalKnownHostsFile=/dev/null")
                       ;;                              ("-o" "UserKnownHostsFile=/dev/null")
                       ;;                              ("-o" "StrictHostKeyChecking=no")))
                       (tramp-default-port         22)))
        ;; TRAMP gcloud ssh with no helper script
        (add-to-list 'tramp-methods
                     '("gssh"
                       (tramp-login-program        "gcloud compute ssh")
                       (tramp-login-args           (("%h")))
                       (tramp-async-args           (("-q")))
                       (tramp-remote-shell         "/bin/sh")
                       (tramp-remote-shell-args    ("-c")))))


    #+end_src
*** Handle SUDO - root and other users
    #+begin_src emacs-lisp
      ;; TRAMP SUDO FUN - snarfed from Peter Dyballa on gmane.emacs.help
      (defun my-tramp-header-line-function ()
        (when (string-match "^/.*su\\(do\\)?:" default-directory)
          (setq header-line-format
                (format-mode-line "----- THIS BUFFER IS VISITED WITH SUDO PRIVILEGES -----"
                                  'font-lock-warning-face))))

      (with-eval-after-load 'tramp
        (add-hook 'find-file-hook 'my-tramp-header-line-function)
        (add-hook 'dired-mode-hook 'my-tramp-header-line-function))
    #+end_src
*** Shell sugar
**** Open remote shell in current remote directory
#+begin_src emacs-lisp
  (defun gjg/open-shell-prompted (newdir)
    "Directly open shell local or TRAMP remote"
    (interactive "D")
    (message (format "Changing directory to %s" newdir))
    (cd newdir)
    (if (file-remote-p newdir)
        (shell (format "%s-sh" (file-remote-p newdir 'host)))
      (shell
       (format "%s-sh"
        (file-name-nondirectory
         (directory-file-name
          (file-name-directory newdir)))))))



  (defun gjg/open-remote-shell ()
    "If current buffer is remote, open a new uniquely named shell based on host name"
    (interactive)
    (if (file-remote-p default-directory)
        (progn
          ;; do stuff
          (message "Now I shall do stuff")
          (shell (concat (file-remote-p default-directory 'host) "-sh")))
      (shell
       (concat
        (file-name-nondirectory
         (directory-file-name
          (file-name-directory
           default-directory))) "-sh"))))
#+end_src

** Bookmark+
   Bookmark a function, bookmark crazy things
   #+begin_src emacs-lisp
     (use-package bookmark+ :straight t)
   #+end_src
** Dired
   =dired-dwim-target= is just awesome.  Whenever you have 2 Dired
   windows in a frame, hitting Copy or Rename from one Dired buffer
   automatically suggests the other as the target

   =dired-omit-files= is a regexp for files you want to hide using
   =dired-omit-mode= Depending on your workflow, that may include
   compiled files (.elc, .o etc) as well as normally hidden files.

   =auto-revert-mode= refreshes the visible buffer when something in
   the directory changes.

   #+begin_src emacs-lisp
     (require 'dired)
     (with-eval-after-load 'dired)
     ;; (use-package all-the-icons-dired :straight t)
     (use-package all-the-icons :straight t) ;; currently ([2022-12-03 Sat]) being used for org-agenda-category-icon-alist and maybe doom-modelinea
     (use-package dired-collapse :straight t)
     (use-package treemacs :straight t
       :defer t
       :config
       (progn
         (treemacs-fringe-indicator-mode 'only-when-focused)
         (when treemacs-python-executable
           (treemacs-git-commit-diff-mode t))
         (pcase (cons (not (null (executable-find "git")))
                      (not (null treemacs-python-executable)))
           (`(t . t)
            (treemacs-git-mode 'deferred))
           (`(t . _)
            (treemacs-git-mode 'simple)))
         (treemacs-modify-theme "Default"
           :icon-directory "~/emacs/pixmaps/"
           :config
           (progn
             (treemacs-create-icon :file "sparql-rdf.png" :extensions ("sparql" "rq" "ttl" "trig")))))
       :bind
       (:map treemacs-mode-map
             ("C-o" . treemacs-visit-node-no-split))
       )

     (use-package treemacs-icons-dired :straight t
       :hook
       (dired-mode . treemacs-icons-dired-enable-once))

     (define-key dired-mode-map [mouse-1] 'dired-find-file)
     (define-key dired-mode-map [mouse-2] 'dired-find-file)
     (keymap-unset dired-mode-map "N") ;; run man on file????
     (keymap-set dired-mode-map "N" (lambda () (interactive) (dired-display-file) (dired-next-line)))
     (setq dired-dwim-target t
           dired-omit-files "^\\.?#\\|^\\..*"
           delete-by-moving-to-trash nil
           dired-listing-switches "-alh --group-directories-first")
     (require 'dired-x)
     (delete ".bin" dired-omit-extensions)
     ;; set key binding in key map prior to dired-x being loaded - for autoload
     (define-key dired-mode-map "\C-x\M-o" 'dired-omit-mode)
     (define-key dired-mode-map (kbd "M-<up>") 'dired-up-directory)
     (define-key dired-mode-map (kbd "M-<down>") 'dired-find-file)
     (autoload 'dired-omit-mode "dired-x" "Dired-X")
     ;; (declare (special dired-x-hands-off-my-keys
     ;; 		  dired-bind-vm
     ;; 		  dired-omit-files-p))
     ;; (add-hook 'dired-load-hook
     ;; 	  (function
     ;; 	   (lambda ()
     ;; 	     (declare (special dired-x-hands-off-my-keys
     ;; 			       dired-bind-vm))
     ;; 	     (load-library "dired-x")
     ;; 	     (setq dired-x-hands-off-my-keys nil
     ;; 		   dired-bind-vm t))))

     (setq auto-revert-verbose nil)
     (add-hook 'dired-mode-hook
           (lambda ()
             (interactive)
             (dired-omit-mode 1)
             ;; (dired-hide-details-mode 1)
             ;; (all-the-icons-dired-mode 1)
             (auto-revert-mode 1)))
     ;; 		      ;; Set dired-x buffer-local variables here.  For example:
     ;; 		      (setq dired-omit-mode t)
     ;; 		      (setq dired-omit-files "^\\..*")
     ;; 		      )))
   #+end_src
*** Open file in relevant OS app
#+begin_src emacs-lisp
  ;; swiped from Gilaras Drakeson <gilaras@gmail.com>
  (defcustom gjg/os-open "xdg-open"
    "Command to open a document, e.g. `xdg-open` on Linux, `sensible-browser` on crostini, `open` on OS X, `explorer` or `cygpath` on Windows"
    :type 'string
    :group 'gjg)


  (defun dired-open (&optional file-list)
    (interactive
     (list (dired-get-marked-files t current-prefix-arg)))
    (progn
      (message (format "Calling %s %s" gjg/os-open file-list))
      (apply 'call-process gjg/os-open nil 0 nil file-list)))
  (define-key dired-mode-map (kbd "C-;") 'dired-open)
#+end_src
** Ediff
   #+begin_src emacs-lisp
     (setq ediff-split-window-function 'split-window-horizontally)
     (setq ediff-window-setup-function 'ediff-setup-windows-plain)
   #+end_src
*** Disable zoom-mode when using Ediff
    TODO: Figure out zoom config for this.  The below is a hack - I should be able to
    disable Zoom in its config by matching mode or buffer name.
    #+begin_src emacs-lisp :tangle no
      (add-hook 'ediff-before-setup-hook
                '(lambda ()
                   (setq gjg/zoom-mode zoom-mode) ;; save current state
                   (zoom-mode -1) ;; off unconditionally for Ediff
                   ))

      (add-hook 'ediff-quit-hook
                '(lambda ()
                   (zoom-mode (if gjg/zoom-mode 1 -1))  ;; reset to prior state
                   (message (format "gjg/zoom-mode is %s, zoom-mode is now %s" gjg/zoom-mode zoom-mode))
                   ))
    #+end_src
** Help and helpful modes
*** Add navigation to Help buffer
   #+begin_src emacs-lisp
     (setq help-window-select t)
     (add-hook 'help-mode-hook
               (lambda ()
                 (local-set-key (kbd "M-p") 'help-go-back)
                 (local-set-key (kbd "M-n") 'help-go-forward)
                 ))
   #+end_src
*** Use the Helpful package
   #+begin_src emacs-lisp
     (use-package helpful :straight t
       :config
       (global-set-key (kbd "C-h f") #'helpful-callable)
       (global-set-key (kbd "C-h v") #'helpful-variable)
       (global-set-key (kbd "C-h k") #'helpful-key)
       (global-set-key (kbd "C-h d") #'helpful-at-point)
       (global-set-key (kbd "C-h F") #'helpful-function)
       (global-set-key (kbd "C-h C") #'helpful-command))

     ;; (when (fboundp 'helpful-function)
     ;;   (progn
     ;;     ;; Note that the built-in `describe-function' includes both functions
     ;;     ;; and macros. `helpful-function' is functions only, so we provide
     ;;     ;; `helpful-callable' as a drop-in replacement.
     ;;     ;; (global-set-key (kbd "C-h f") #'helpful-callable)
     ;;     ;; (global-set-key (kbd "C-h v") #'helpful-variable)
     ;;     (global-set-key (kbd "C-h k") #'helpful-key)
     ;;     ;; Lookup the current symbol at point. C-c C-d is a common keybinding
     ;;     ;; for this in lisp modes.
     ;;     (global-set-key (kbd "C-c C-d") #'helpful-at-point)
     ;;     (setq counsel-describe-function-function #'helpful-callable)
     ;;     (setq counsel-describe-variable-function #'helpful-variable)))
   #+end_src

** Selectrum (will it replace Ivy which replaced Ido?)
   #+begin_src emacs-lisp
     (use-package selectrum :straight t)
     (selectrum-mode +1)
     (use-package selectrum-prescient :straight t)
     (selectrum-prescient-mode +1)
     (prescient-persist-mode +1)
   #+end_src


** Occur
*** Navigation
   #+begin_src emacs-lisp
     ;;     Some simple sex-ups for occur-mode
     (define-key occur-mode-map "n" 'occur-next)
     (define-key occur-mode-map "p" 'occur-prev)
     (defadvice occur-next (after gjg/occur-navigation-other-window)
       "Show match in other window as you navigate, as in rgrep"
       (occur-mode-display-occurrence))
     (ad-activate 'occur-next)
     (defadvice occur-prev (after gjg/occur-navigation-other-window)
       "Show match in other window as you navigate, as in rgrep"
       (occur-mode-display-occurrence))
     (ad-activate 'occur-prev)
   #+end_src
** Shell and related modes
   TODO: remove conflicting key bindings
*** Vterm
    #+begin_src emacs-lisp
      (use-package vterm :straight t
        :ensure t
        :config
        (define-key vterm-mode-map (kbd "M-p") nil)
        :bind (:map vterm-mode-map
                    (("M-p" . (lambda () (interactive) (vterm-insert  (kbd "<up>")))))))
    #+end_src
*** Coterm - comint with terminal emulation
    This thing is magnificent.  It provides good-enough terminal emulation in my beloved
    old friend shell-mode windows.
    #+begin_src emacs-lisp
      (use-package coterm :straight t
        :config
        (coterm-mode 1))
    #+end_src
*** Shell script mode :tangle no
    #+begin_src emacs-lisp
    #+end_src
*** Shell mode config
    #+begin_src emacs-lisp
      (custom-set-variables '(shell-kill-buffer-on-exit t)
                            '(shell-command-prompt-show-cwd t))
    #+end_src
*** Config for comint mode
    #+begin_src emacs-lisp
      (defun gjg/turn-on-comint-history (history-file)
        (setq comint-input-ring-file-name history-file)
        (comint-read-input-ring 'silent))
      (setq comint-input-ring-size 5000)
    #+end_src
*** Hook in shell history
    #+begin_src emacs-lisp
      (add-hook 'shell-mode-hook
                (lambda ()
                  (gjg/turn-on-comint-history (getenv "HISTFILE"))))
      (add-hook 'kill-buffer-hook #'comint-write-input-ring)
      (add-hook 'kill-emacs-hook
                (lambda ()
                  (--each (buffer-list)
                    (with-current-buffer it (comint-write-input-ring)))))
    #+end_src
*** Bash completions
    #+begin_src emacs-lisp
      (use-package bash-completion :straight t
        :config
        (bash-completion-setup))
    #+end_src
*** ANSI color
    The =xterm-color-filter= function is part of the =xterm-color= package.  It does the
    Lord's work in translating ANSI color codes to font properties so that things can look
    awesome.

    #+begin_src emacs-lisp
      (use-package xterm-color :straight t)
      (ansi-color-for-comint-mode-on)
      ;; try some xterm coloring in shell buffers
      (setq comint-output-filter-functions
            (remove 'ansi-color-process-output comint-output-filter-functions))
      (add-hook 'shell-mode-hook
            (lambda ()
              (abbrev-mode 1)
              (add-hook 'comint-preoutput-filter-functions 'xterm-color-filter nil t)))
    #+end_src
*** SSH Agent in subprocesses
    + Not really related to shell-mode, this assures our keychain is activated for things
      such as magit that fire off subproceess
      #+begin_src emacs-lisp
        (use-package keychain-environment :straight t)
        (keychain-refresh-environment)
      #+end_src
** Magit
*** Behavior
    #+begin_src emacs-lisp
      ;; (use-package magit-todos :straight t)
      (use-package magit :straight t
        :config
        (setq magit-clone-set-remote.pushDefault t))
    #+end_src
*** Initiate =magit-todos= only on =magit= invocation, since it loads slowly
    #+begin_src emacs-lisp :tangle no
      (use-package magit-todos :straight t)
      (add-hook 'magit-status-mode-hook
                (lambda ()
                  (magit-todos-mode 1)
                  ))
    #+end_src

** Spelling
   #+begin_src emacs-lisp
     ;; don't try to spell things in Org property drawers and code blocks
     ;; (add-to-list 'ispell-skip-region-alist '(":\\(PROPERTIES\\|LOGBOOK\\):" . ":END:"))
     ;; (add-to-list 'ispell-skip-region-alist '("#\\+begin_src" . "#\\+end_src"))
     ;; redefine the obsolete spell-word
     (defalias 'spell-word  'ispell-word)

     (defalias 'spell-buffer 'ispell-buffer)
   #+end_src
** CSV - Clumsy Stupid Varmint
   #+begin_src emacs-lisp
     (use-package csv-mode :straight t)
   #+end_src
** TTL - Ticky Tacky Lunacy
   #+begin_src emacs-lisp
     (use-package ttl-mode :straight t
       :init
       (add-to-list 'auto-mode-alist '("\\.\\(n3\\|ttl\\|trig\\)\\'" . ttl-mode))
       :config
       (setq ttl-indent-level 2))
   #+end_src
** YAML - You A Moth Licker
   #+begin_src emacs-lisp
     (use-package yaml-mode :straight t
       :hook (yaml-mode . (lambda () (yafolding-mode 1)
                            (toggle-truncate-lines 1))))
     (add-hook 'conf-mode-hook
               (lambda ()
                 (yafolding-mode 1)
                 (toggle-truncate-lines 1)))
   #+end_src
** Man pages
   Open man page in current window, rather than other window with
   #+begin_src emacs-lisp
     (custom-set-variables '(Man-notify-method 'pushy))
   #+end_src
** OpenVPN
   Mode to help using OpenVPN
   #+begin_src emacs-lisp :tangle no
     (use-package ovpn-mode :straight t
       :custom
       (ovpn-mode-authinfo-path "~/.local/.authinfo.gpg")
       (ovpn-mode-base-directory "~/.config/openvpn/")
       (ovpn-mode-preferred-terminal "alacritty")
       :bind (:map ovpn-mode-map
                   (("n" . next-line)
                   ("p" . previous-line)
                   ("m" . ovpn-mode-start-vpn-with-namespace))))
   #+end_src
** Ag / The Silver Searcher/Surfer
   #+begin_src emacs-lisp
     (use-package ag :straight t)
   #+end_src

** Highlight indentation
   #+begin_src emacs-lisp
     (use-package highlight-indentation :straight t)
   #+end_src
* Things that go graph in the night - Zettelkastenistische things!
  I love the simplicity of Denote.

  But I *also* love the pure graphy joy of =org-roam-ui= and long to view it, swim in its
  3D world, and navigate to notes with a click.  So far, combinations of Denote and Logseq
  are not doing it for me.

  I have as of [2022-11-11 Fri] a nice working config for Denote.  But I am going to copy
  the current set of those notes, move them into Org Roam and try again to see what that
  experience is like.

  I believe the dependency on an external Sqlite no longer exists in Emacs 29 -- because
  sqlite is apparently compiled into Emacs itself now!

  Overall, the great Zettelkasten problem must find a solution!
** Org Roam vs Denote
   I feel every time I try Org Roam that I am walking on eggshells, not understanding the
   full set of configurations and the "proper" use of it.  This time around, I got into
   the Org Roam protocol capture, and Org Roam capture templates, which makes things
   better - but these are actually very close to existing Org Mode capabilities with
   a little extra sauce added - quite against Denote's approach to avoid duplicating
   Emacs basics.

   I find that Denote doesn't get in my way, is fun to extend ... and I think I just
   talked myself into abandoning Org Roam *yet again*
*** Denote pros and cons
**** Pros
     + Very simple and understandable
     + Absolutely outstanding documentation
     + Unbelievable responsiveness from @prot on GitHub / other forums
     + Philospophy to let Emacs do Emacs things - not subsume everyting in a complex package
     + Easily configurable
     + No external dependencies
**** Cons
     + No "Denote UI" graphing - thus need to find external viz/nav tools
       The lack of graph viz has me trying Logseq, Obsidian and my own Org-to-RDF export
       Should I look at the code that loads Org Roam into sqlite???

*** Org Roam pros and cons
**** Pros
     + Graph-aware
     + Nodes can be defined at file or subtree level, simply add ID
     + Born to support Zettelkasten method (also a con)
     + Vis/Nav supported by the amazing Org Roam UI (such a big plus)
     + Sqlite - also a con
       Once you have a relational representation, you can do all sorts of useful things
       [[https://lucidmanager.org/data-science/visualise-org-roam/][Visualise Org-Roam Networks With igraph and R]]
**** Cons
     + Adding ID property to subtree turns it into a node - MAYBE UNINTENTIONALLY
     + External dependency on sqlite - now included in Emacs but still annoys me
     + Terrible documentation IMO - much thinner than Denote's with a much larger user base
     + Assumes Zettelkasten - which I can't say suits my purposes exactly
     + Oddly difficult to learn and get started with
     + Fragile and easily broken in my experience (especially org-roam-ui)


** Denote - note taking
   + Prot's denote - on System Crafters [[https://systemcrafters.net/live-streams/july-15-2022/][System Crafters Live! - July 15, 2022 - System Crafters]]

*** Initialize package
    Install and do initial configuration of Denote including Denote Dired
    #+begin_src emacs-lisp
      (use-package denote :straight t
        :defer nil
        :init
        (defun gjg/denote-project () (interactive) (project-switch-project "~/gregj-notes"))
        :bind
        ("C-S-d" . gjg/denote-project)
        :config
        (setq denote-directory (expand-file-name "~/gregj-notes/")
              denote-known-keywords '("journal" "projects" "ideas")
              denote-date-prompt-use-org-read-date t)
        ;; (setq denote-prompts '(title subdirectory))
        )
      (require 'denote)

      ;;(setq denote-dired-directories '("~/gregj-notes/"))
      ;; (add-to-list 'denote-dired-directories "~/gregj-notes/")
      (add-hook 'dired-mode-hook #'denote-dired-mode-in-directories)
      (add-to-list 'denote-dired-directories (expand-file-name "~/gregj-notes/journals/"))
      (custom-set-faces
       '(denote-faces-title
         ((t
           (:height 1.1 :weight semibold)))))
    #+end_src
*** Set up Capture template
    This might be further embellished to provide funcationality beyond simply using the
    =denote= function.

    #+begin_src emacs-lisp
      (with-eval-after-load 'org-capture
        (add-to-list 'org-capture-templates
                     '("n" "New note (with Denote)" plain
                       (file denote-last-path)
                       #'denote-org-capture
                       :no-save t
                       :immediate-finish nil
                       :kill-buffer t
                       :jump-to-captured t)))
    #+end_src
*** Journal
    :PROPERTIES:
    :ID:       d7faff4e-90a4-4b70-986f-739e3b936539
    :END:
    Use a =journals/= subdirectory to integrate nicely with Logseq
    #+begin_src emacs-lisp
      ;; Denote templates
      (add-to-list 'denote-templates '(journal . "* Thoughts\n\n* Tasks (require a category)\n" ) )

      ;; Here's a function for daily journal capture - compatible-ish with Logseq
      (defun gjg/denote-journal ()
        "Create an entry tagged 'journal' with the date as its title.
      If an entry for today is already present, visit that file.
      If there are more than one files that match, present a choice."
      ;; (directory-files (concat denote-directory "/journals") nil "^[0-9T]+--2022-10-27.+org$")
        (interactive)
        (let* ((dt (decode-time))
               (today (format "%d-%02d-%02d" (nth 5 dt) (nth 4 dt) (nth 3 dt)))
               (jfileregex (concat "^[0-9T]+--" today ".+org$"))
               (jfiles (directory-files (concat denote-directory "/journals") t jfileregex)))
          (cond
           ((= 1 (length jfiles))
            (find-file (car jfiles)))
           ((> (length jfiles) 1)
            (find-file (completing-read "Journal file (more than 1 found for today: " jfiles)))
           (t
            (denote
             (format-time-string "%Y-%m-%d")
             '("journal") ; multiple keywords are a list of strings: '("one" "two")
             nil          ; default Org file type
             (concat denote-directory "journals")
             nil          ; date - default to current-time
             'journal
             )))
          (save-buffer) ;; gotta save immediately to avoid creating duplicate dailies
          ))
    #+end_src

*** Function to bring up nested notes dired
    This function also works very nicely in the bookmark+ package, which allows
      bookmarking a function.  The function is not dependent on the =bookmark+= package,
      but is very useful with it
    #+begin_src emacs-lisp
      (defun gjg/dired-denote-nested-dirs ()
        "Dired view with Denote directory and subdirectories"
        (interactive)
        (dired denote-directory)
        (dired-maybe-insert-subdir "journals"))
    #+end_src
*** Function to quickly browse all notes with a particular keyword
    This relies on =gjg/dired-denote-nested-dirs=

    Bring up the notes dired, prompt for an existing keyword, then limit the dired view to
    just that keyword

    #+begin_src emacs-lisp
      (defun gjg/denote-browse-keyword (&optional keyword)
        "Bring up the notes dired, prompt for an existing keyword, then limit the dired view to
      just that keyword."
        (interactive)
        (let ((keyword (or keyword
                           (completing-read "Denote keyword: " (denote-keywords)))))
          (gjg/dired-denote-nested-dirs)
          (revert-buffer)
          ;; consider using dired-mark-files-containing-regexp !
          (dired-mark-files-regexp (concat "_" keyword))
          (dired-toggle-marks)
          (dired-do-kill-lines)))

      (bind-key "/" 'gjg/denote-browse-keyword dired-mode-map)
    #+end_src
*** Deregister the =:denote= link type
    I prefer to not make Denote itself a dependency - just use native Org Mode link types
    such as =id= and =file=

    #+begin_src emacs-lisp
      (setq org-link-parameters
            (delq (assoc "denote" org-link-parameters) org-link-parameters))
    #+end_src

** Org Roam UI
   TODO: Move this into Org Roam config (maybe)

   #+begin_src emacs-lisp :tangle no
     (use-package org-roam-ui :straight t
       ;; (:host github :repo "org-roam/org-roam-ui" :branch "main" :files ("*.el" "out"))
       :after org-roam
       ;;         normally we'd recommend hooking orui after org-roam, but since org-roam does not have
       ;;         a hookable mode anymore, you're advised to pick something yourself
       ;;         if you don't care about startup time, use
       ;;  :hook (after-init . org-roam-ui-mode)
       :config
       (setq org-roam-ui-sync-theme t
             org-roam-ui-follow t
             org-roam-ui-update-on-save t
             org-roam-ui-open-on-start t))
   #+end_src

** Org Roam
   I'm starting off with @daviwil's config (simplified) as it exists [2022-11-11 Fri]

   + [[https://www.reddit.com/r/emacs/comments/veesun/orgroam_is_absolutely_fantastic/][(2) org-roam is absolutely fantastic! : emacs â‰« www.reddit.com]]

*** Configuration and startup
    #+begin_src emacs-lisp :tangle no
      ;; (setq org-roam-database-connector 'sqlite-builtin) ; set before loading org-roam
      (use-package org-roam :straight t
        :hook
        (after-init . org-roam-mode)
        :init
        (setq
         org-roam-v2-ack t
         dw/daily-note-filename "%<%Y-%m-%d>.org"
         dw/daily-note-header "#+title: %<%Y-%m-%d %a>\n\n[[roam:%<%Y-%B>]]\n\n")

        :custom
        (org-roam-directory "~/projects/private-orgmode/roam-notes")
        (org-roam-completion-everywhere t)
        (setq org-id-extra-files (org-roam--list-files org-roam-directory))  ;; :bind (:map org-roam-mode-map
        ;;             (("C-c n l" . org-roam)
        ;;              ("C-c n f" . org-roam-find-file)
        ;;              ("C-c n g" . org-roam-show-graph))
        ;;             :map org-mode-map
        ;;             (("C-c n i" . org-roam-insert)))
        :bind (("C-c n l" . org-roam-buffer-toggle)
               ("C-c n f" . org-roam-node-find)
               ("C-c n i" . org-roam-node-insert)
               :map org-mode-map
               ("C-M-i" . completion-at-point)
               )
        :config
        ;; (org-roam-setup) ; following the lead of u/pragmat1c1
        (setq org-roam-node-display-template
              (concat "${title:70}"(propertize "${tags:30}" 'face 'org-tag) "${file:48}"))
        )
    #+end_src
*** Org Roam Capture templates
    Let's leave the default one alone for now - make a new 'g'reg template
    #+begin_src emacs-lisp :tangle no
      (require 'org-roam)
      (require 'org-roam-protocol) ; allow bookmarklets to work for "ref" template
      (push
       '("g" "greg" plain "%?" :target
         (file+head "${slug}.org" "#+title: ${title}") :unnarrowed nil)
       org-roam-capture-templates)
      (push
       '("r" "ref" plain "%?" :target
         (file+head "${slug}.org" "#+title: ${title}\n\n${body}") :unnarrowed t)
       org-roam-capture-ref-templates)


    #+end_src
*** Immediate thing in video
    Ref: comment by Umar Ahmad in [[https://www.youtube.com/watch?v=AyhPmypHDEw][Getting Started with Org Roam - Build a Second Brain in Emacs - YouTube]]
    #+begin_src emacs-lisp :tangle no
      ;; To get the old "immediate" insert you can add the following in your config:
      (defvar org-roam-capture-immediate-template
        (append (car org-roam-capture-templates) '(:immediate-finish t)))
      (defun org-roam-insert-immediate (arg &rest args)
        (interactive "P")
        (let ((args (push arg args))
              (org-roam-capture-templates (list org-roam-capture-immediate-template)))
          (apply #'org-roam-node-insert args)))
      ;; And then bind `org-roam-insert-immediate` to a keybinding.
    #+end_src

* Org mode stuff

** Org Contributions package
   Add =ignore= tag to headlines you don't want to export
   Refer to [[https://emacs.stackexchange.com/a/17677/418][org mode - Is it possible to export content of subtrees without their heading...]]
   #+begin_src emacs-lisp :tangle no
     (use-package org-contrib :straight t
       :config
       (require 'ox-extra)
       (ox-extras-activate '(ignore-headlines)))
   #+end_src
** Habits
   #+begin_src emacs-lisp
     (add-to-list 'org-modules 'org-habit t)
     (require 'org-habit)
     (setq org-habit-show-all-today t
           org-habit-show-done-always-green t
           org-habit-show-habits nil
           org-habit-graph-column 60
           ;; org-habit-completed-glyph 9989
           org-habit-preceding-days 7
           org-habit-following-days 2
           org-habit-show-done-always-green t
           org-habit-show-habits-only-for-today nil)
   #+end_src
** Org key mappings
   Disable some that get in the way
   #+begin_src emacs-lisp
     (with-eval-after-load 'org
       ;; little use for header COMMENT keyword
       (unbind-key (kbd "C-c ;") org-mode-map)       ; org-toggle-comment
       (unbind-key (kbd "C-c ;") org-mode-map)
       ;; don't accidentally archive things
       (unbind-key (kbd "C-c C-x C-a") org-mode-map) ; org-archive-subtree-default
       (unbind-key (kbd "C-c C-x C-s") org-mode-map) ; org-archive-to-subtree
       (unbind-key (kbd "C-c C-x A") org-mode-map)   ; org-archive-to-archive-sibling
       (unbind-key (kbd "C-c C-x a") org-mode-map)   ; org-toggle-archive-tag
       ;; remap the dangerous C-c C-w to avoid nuking regions
       (unbind-key (kbd "C-c C-r") org-mode-map)   ; org-reveal
       (unbind-key (kbd "C-c C-w") org-mode-map)     ; org-refile
       (bind-key (kbd "C-c C-r") 'org-refile org-mode-map)
       ;; keys that conflict with buffer movement
       (unbind-key (kbd "<M-right>") org-mode-map)   ; org-metaright
       (unbind-key (kbd "<M-left>") org-mode-map)    ; org-metaleft
       ;; keys that conflict with windmove package
       ;; (unbind-key (kbd "<S-up>") org-mode-map)       ; org-shiftup
       ;; (unbind-key (kbd "<S-down>") org-mode-map)     ; org-shiftdown
       ;; (unbind-key (kbd "<S-left>") org-mode-map)     ; org-shiftleft
       ;; (unbind-key (kbd "<S-right>") org-mode-map)    ; org-shiftright
       )
   #+end_src
** Org Babel and Source Code Blocks
*** Set default tangle Org Babel headers
    Here's a thought: *every* tangled file should have a link back to its originating Org
    source
    #+begin_src emacs-lisp
      (add-to-list 'org-babel-default-header-args '(:comments . "both") )
    #+end_src
*** Report time for code block execution
    + Ref: My answer on Emacs Stackexchange
       [[https://emacs.stackexchange.com/a/61357/418][timers - How to time org-mode code block execution? - Emacs Stack Exchange]]
    #+begin_src emacs-lisp :tangle no
      (defun gjg/time-call (time-call &rest args)
        (message "Ohai %s" args)
        (let ((start-time (float-time))
              (result (apply time-call args)))
          (message "Function call took %f seconds" (- (float-time) start-time))
          result))

      (advice-add 'org-babel-execute-src-block :around #'gjg/time-call)
    #+end_src
*** Config including template shortcuts
    TODO: install ob-jupyter package on systems with Jupyter
     #+begin_src emacs-lisp
       ;; (unless (version< org-version "9.2")
       ;;   (require 'org-tempo) ; required for Easy Templates since Org 9.2
       ;;   )
       (with-eval-after-load 'org
         (setq org-confirm-babel-evaluate nil
               org-export-with-sub-superscripts nil)

         ;; ;; The Dreadful Timeline has brought us indentation-sensitive languages
         ;; ;; Python, YAML, Heredoc seem to require that Org not format source code blocks
         ;; (setq org-src-preserve-indentation nil)
         (setq org-src-window-setup 'current-window)
         (setq org-structure-template-alist '(("C" . "comment")
                                              ("e" . "example")
                                              ("E" . "export")
                                              ("h" . "export html")
                                              ("l" . "export latex")
                                              ("\"" . "quote")
                                              ("qp" . "src sparql")
                                              ("qq" . "src sql")
                                              ("S" . "src")
                                              ("sc" . "src conf")
                                              ("sg" . "src sql :product gsql")
                                              ("sj" . "src json")
                                              ("sJ" . "src javascript")
                                              ("sl" . "src emacs-lisp")
                                              ("sL" . "src lisp") ;; Common Lisp
                                              ("so" . "src org")
                                              ("sp" . "src python")
                                              ("sP" . "src jupyter-python")
                                              ("sq" . "src sql")
                                              ("sr" . "src R")
                                              ("sR" . "src jupyter-R")
                                              ("ss" . "src bash")
                                              ("sy" . "src yaml"))))

     #+end_src
*** Report on tangling when buffer is narrowed
    When one means to french fry (tangle whole file) but pizzas instead (tangle narrowed
    file) one may have a bad time.  But it's often intended - so don't stop, prompt and
    annoy - simply report - result: joy.
    #+begin_src emacs-lisp
      (add-hook 'org-babel-tangle-finished-hook
                (lambda () (interactive)
                  (when (buffer-narrowed-p)
                    (message "Blocks were tangled from narrowed buffer. Check *Messages* for count." (buffer-name)))))
    #+end_src

** Org num mode
   #+begin_src emacs-lisp :tangle no
     ;; for use with org-num-mode
     (defun org-num-skip-top-level-format (numbering)
       "Number from subtree display function.
     NUMBERING is a list of numbers."
       (concat (mapconcat #'number-to-string (cdr numbering) ".") " "))
     (setq org-num-format-function 'org-num-skip-top-level-format)
   #+end_src
** Org Superstar - appearance of headers
   #+begin_src emacs-lisp
     (use-package org-superstar :straight t
       :hook
       (org-mode . org-superstar-mode))
   #+end_src
** Org-mode hook
   :PROPERTIES:
   :ID:       c1b7906b-4539-4cb7-94d5-285b5d17c404
   :END:
   On =auto-fill-mode=: I prefer to have it on, but hate when
   creating links and having it wrap while typing the description.
   For this reason, I want to get in the habit of only adding links
   using =C-c C-l= (=org-insert-link=)

   #+begin_src emacs-lisp
     (add-hook 'org-mode-hook
           (lambda ()
             (auto-fill-mode 1)
             (highlight-regexp ":tangle no" 'hi-pink)
             (highlight-regexp ":tangle /tmp/intothevoid.el" 'hi-aquamarine)
             ;; (org-modern-mode 1)
             (setq org-hide-leading-stars t
                   abbrev-mode 1
                   fill-column 90 ; good default for wide screens
                   org-use-property-inheritance t
                   org-link-search-must-match-exact-headline nil
                   ;; org-defkey org-mode-map [(control tab)] 'org-next-link
                   org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id)
             ;; steal back my keys
             (org-defkey org-mode-map [home] 'beginning-of-buffer)
             (org-defkey org-mode-map [end] 'end-of-buffer)
             ;; 	    ;; (local-set-key (kbd "C-c TAB") 'org-next-link)
             ;; 	    ;; (local-set-key (kbd "S C-c TAB") 'org-previous-link)
             ;; 	    (abbrev-mode 1)
             ;; 	    ;; set sub/superscript interpretation OFFFFFFOOOFFF
             ;; 	    (setq org-use-sub-superscripts nil)
             (setq org-catch-invisible-edits 'show-and-error )))
   #+end_src
** Org tree to indirect
   This useful feature is hampered by poor naming of the resulting buffer, making it very
   difficult to know whether you are editing the original buffer or the created indirect
   buffer.

   There are no user variables that influence the indirect buffer naming, and no hooks
   defined for any function related to =org-tree-to-indirect-buffer=

   It therefore seems the only way to affect it is to advise a function.
   #+begin_src emacs-lisp
     (defun gjg/rename-org-indirect-buffer (orig-fun &rest arg)
       (rename-buffer (concat "INDIRECT-" (buffer-name))))

     (advice-add 'org-tree-to-indirect-buffer :after 'gjg/rename-org-indirect-buffer)


   #+end_src
** Blogs - linking and image additions
   For blogging especially, we want to quickly add web links and images.  2 packages from
   m?elpa help here
   #+begin_src emacs-lisp :tangle no
     (use-package org-cliplink :straight t)
     (use-package org-download :straight t)
   #+end_src

   And here's a handy keyboard macro =gjg/url-grab-cliplink=

   Assume point is in an Org file, and there are two windows in the current frame *and*
   the other window is a Web browser (this only works in EXWM!).  Go to the browser
   window, copy the URL, then use =org-cliplink= at the starting point in the original Org window.

   #+begin_src emacs-lisp :tangle no
   (fset 'gjg/url-grab-cliplink
   (kmacro-lambda-form [?\C-x ?o ?\C-l ?\M-w tab ?\C-x ?o ?\M-x ?o ?r ?g ?- ?c ?l ?i ?p ?l ?i ?n ?k return] 0 "%d"))
   #+end_src

** Capture Templates
*** Functions to support capture templates
**** Bring in nicely formatted links to be used in the phone log capture template
      These entries are in a table in each customer engagement Org file named =people=

      #+begin_src emacs-lisp
        (defun gjg/annotate-person (s)
          "Provide annotations for completing-read using the data in a \"person\" table as used in my work files"
          (let ((item (assoc s minibuffer-completion-table)))
            (when item (concat
                        (string-pad "" (- 40 (string-width (nth 0 item) )))
                        (nth 2 item)
                        (if (string-empty-p (nth 4 item)) "" (concat " (" (nth 4 item) ")"))
                        ))))

        (defun gjg/add-person-from-table (table)
          "Add person from table to an Org unordered list - used with phone log capture template"
          (let* ((marginalia-align-offset 80)
                 (completion-extra-properties '(:annotation-function gjg/annotate-person))
                 (myperson (assoc (completing-read "Person: " table) table))
                 (myname (nth 0 myperson))
                 (title (nth 2 myperson))
                 (linkedin (nth 1 myperson))
                 (company (nth 4 myperson))
                 (location (nth 3 myperson)))

            ;; Name Title (Company) Location
            (format "+ %s - %s %s - %s"
                    (if (string-empty-p linkedin)
                        myname
                      (concat "[[" linkedin "][" myname "]]"))
                    title
                    (if (string-empty-p company)
                        ""
                      (concat "(" company ")"))
                    location)))
      #+end_src
**** Create new blog post file for blog capture
    #+begin_src emacs-lisp
      ;; *** Org capture
      ;; taken from StackOverflow answer https://stackoverflow.com/questions/11902620/org-mode-how-do-i-create-a-new-file-with-org-capture
      ;; (defun capture-blog-filename (path)
      (defun safe-blog-filename ()
        (let ((thedate (org-read-date nil nil nil "Date of post: "))
              (name (read-string "Blog post title: ")))
          (setq gjg/blogpost-title name)
          (expand-file-name (format "%s-%s.org"
                                    (format-time-string "%Y-%m-%d")
                                    (downcase
                                     (replace-regexp-in-string "-+$" ""
                                                               (replace-regexp-in-string "[^[:alnum:]]+" "-"
                                                                                         (replace-regexp-in-string "[[:punct:]]" "" name)))))
                            "~/projects/blogs/hypecyclist/content/post/"
                            )))
    #+end_src
*** Variables and hook setup
    I want to always be prompted to refile my corporate phone log - so I remap =C-c C-c=
    for only that capture template.
    #+begin_src emacs-lisp
      (setq org-default-notes-file "~/projects/notes.org")
      ;; (with-eval-after-load 'org-capture
      ;;   ;; (add-hook 'org-capture-mode-hook 'turn-on-auto-fill)
      ;;   (add-hook 'org-capture-mode-hook
      ;;             (lambda ()
      ;;               (let ((mykey (plist-get org-capture-plist :key)))
      ;;                 (if (string= "p" mykey )
      ;;                     (define-key org-capture-mode-map (kbd "C-c C-c") 'org-capture-refile)
      ;;                   (define-key org-capture-mode-map (kbd "C-c C-c") 'org-capture-finalize))))))
      (define-key global-map "\C-cc" 'org-capture)
      (setq org-capture-templates nil) ; initialize to nil prior to grand setup below
    #+end_src

*** Template definitions
   + First set up org-protocol (require the library) prior to using the related
     capture templates.

     If on a system with no =emacsclient= binary - such as Chrome OS - consider using the JS clip
     extension from ChromeOS.

   #+begin_src emacs-lisp
     (when (executable-find "emacsclient")
       (require 'org-protocol))
   #+end_src
**** Blog post
     Start a new blog post for hypecyclist.org using my default Hugo template
     #+begin_src emacs-lisp
       (push
        '("b" "Blog post" plain
                     (file safe-blog-filename)
                     (file "~/.emacs.d/hugo-default-blog.tmpl")
                     :jump-to-captured t)
        org-capture-templates)
     #+end_src

**** org-protocol capture - will I ever ever ever use this again??
     #+begin_src emacs-lisp :tangle no
       (push '("c" "org-protocol-capture" entry "~/projects/private-orgmode/inbox.org"
               "* TODO [[%:link][%:description]]\n\n %i" :immediate-finish nil)
             org-capture-templates)
     #+end_src

**** Add items to a/the inbox - GTD style
     #+begin_src emacs-lisp
       (push
        '("i" "inbox" entry
          (file "~/projects/private-orgmode/inbox.org")
          "* TODO %?\n  :LOGBOOK:\n  CREATED: %U\n  :END:")
        org-capture-templates
        )
     #+end_src

**** Phone/meeting/task - the heart of it all
     #+begin_src emacs-lisp
       (defun gjg/phone-meeting-template ()
         "Org capture template function for call/meeting logs.
       Pull in all customers from active engagements! "
         (format "* %%t %%^{type|%s} with %%^{with|%s}: %%^{subject|%s}
         %%i
         + Team: GG and %%?
           \#+begin_src emacs-lisp :var table=people :results append raw :exports results :eval never-export
            (gjg/add-person-from-table table)
           \#+end_src
       ,** Notes
         +
       ,** Next steps
       "
                 "Call|Meeting|Task"
                 (concat "Solutions Team|SE Team|PS|Fuller|Marketing|Sales|Engineering|Product|"
                         (s-join "|"
                                 (mapcar #'org-get-title
                                         (directory-files-recursively "~/projects/private-orgmode/stardog/engagements/"
                                                                      "org$")))
                         )
                 "Sync-up|Stand-up|Presentation|Intro|Biweekly Services Engagement Review|Weekly|Weekly cadence|Working session")

         )

       (push
        '("p" "Phone/Meeting" entry
          (file+headline gjg/employer-org-file "Calls and Meetings")
          (function gjg/phone-meeting-template)
          :prepend t :clock-in t :clock-keep t :jump-to-captured t) org-capture-templates)
     #+end_src

**** Clock in to a new work "t"ask
     #+begin_src emacs-lisp
       (push
        '             ("t" "Task - clock in using work file" entry
                       (file+headline gjg/employer-org-file "Tasks")
                       "* TODO %^{task description} \n  :LOGBOOK:\n  CREATED: %U\n  :END:\n%i\n   %?"
                       :prepend t :time-prompt nil :clock-in t :clock-keep t :jump-to-captured nil)
        org-capture-templates)
     #+end_src

**** Regular TODO
     #+begin_src emacs-lisp
       (push
        '             ("r" "Regular todo" entry
                       (file "~/projects/private-orgmode/inbox.org")
                       "* TODO %? \n  DEADLINE: %^T\n  :LOGBOOK:\n  CREATED: %U\n  :END:\n%i\n " :prepend nil :time-prompt t)
        org-capture-templates)
     #+end_src
** Exporting
*** General preferences
#+begin_src emacs-lisp
  (custom-set-variables '(org-export-with-sub-superscripts nil)
                        '(org-html-postamble nil))
#+end_src
*** Exporting Babel without evaluation
#+begin_src emacs-lisp
(custom-set-variables '(org-export-use-babel nil))
#+end_src
*** Export without theme interference
	:LOGBOOK:
	- State "DONE"       from "TODO"       [2020-01-14 Tue 10:40]
	- State "DONE"       from "STARTED"    [2020-01-14 Tue 10:40]
	- State "STARTED"    from "TODO"       [2019-09-17 Tue 19:37]
	:END:
	Wrap advice around any means of exporting HTML, including export-and-open
#+begin_src emacs-lisp
  (use-package material-theme :straight t)
  (use-package ox-gfm :straight t)
  (use-package htmlize :straight t)
  ;; export to html - use light theme for export
  ;; tip o' the hat to legoscia https://github.com/legoscia/dotemacs/blob/master/dotemacs.org#theme-for-org-html-export
  (defvar my-org-html-export-theme (intern gjg/preferred-light-theme))
  (defun my-with-theme (orig-fun &rest args)
    (load-theme my-org-html-export-theme)
    (unwind-protect
        (apply orig-fun args)
      (disable-theme my-org-html-export-theme)))

  (with-eval-after-load "ox-html"
    (advice-add 'org-export-to-buffer :around 'my-with-theme)
    (advice-add 'org-export-to-file :around 'my-with-theme))
#+end_src
** Speed commands
   The square bracket "show heading tidily" shortcuts can be used as a flexible
   slide show presentation.

   The OG functions from Dan Davison are now included here [[https://orgmode.org/worg/org-hacks.html#sec-1-3-2][Org ad hoc code, quick hacks and workarounds â‰« orgmode.org]]

   #+begin_src emacs-lisp
     (setq org-use-speed-commands t) ;; POWER USER BABY
     ;; DAN DAVISON nifty speed commands
     (defun ded/org-show-next-heading-tidily (&optional NO-NARROW)
       "Show next subtree, keeping other entries closed. Narrow to the subtree unless NO-NARROW is true."
       (interactive)
       (widen)
       (if (save-excursion (end-of-line) (outline-invisible-p))
           (progn (org-show-entry) (outline-show-children))
         (outline-next-heading)
         (unless (and (bolp) (org-at-heading-p))
           (org-up-heading-safe)
           (outline-hide-subtree)
           (error "Boundary reached"))
         (org-overview)
         (org-reveal t)
         (org-show-entry)
         (outline-show-children)
         (unless NO-NARROW (org-narrow-to-subtree))))

     (defun ded/org-show-previous-heading-tidily (&optional NO-NARROW)
       "Show previous subtree, keeping other entries closed. Narrow to the subtree unless NO-NARROW is true."
       (interactive)
       (widen)
       (let ((pos (point)))
         (outline-previous-heading)
         (unless (and (< (point) pos) (bolp) (org-at-heading-p))
           (goto-char pos)
           (outline-hide-subtree)
           (error "Boundary reached"))
         (org-overview)
         (org-reveal t)
         (org-show-entry)
         (outline-show-children)
         (unless NO-NARROW (org-narrow-to-subtree))))

     (add-to-list 'org-speed-commands
                  '("]" ded/org-show-next-heading-tidily))
     (add-to-list 'org-speed-commands
                  '("[" ded/org-show-previous-heading-tidily))
     (add-to-list 'org-speed-commands
                  '("s" save-buffer))
     (add-to-list 'org-speed-commands
                  '("d" org-toggle-narrow-to-subtree))

     ;; END DAN DAVISON nifty speed commands
     (setq org-speed-commands (delete '("a" . org-archive-subtree-default-with-confirmation) org-speed-commands))
   #+end_src
** Org Transclusion
   Super cool use found: put my very large People table from the main employer Org file,
   transclude it into the individual engagement / prospect files!

   Works fast, loads fast, pretty great
   #+begin_src emacs-lisp
     (use-package org-transclusion :straight t)
   #+end_src
** Org Agenda
*** Initialize Org Agenda
   #+begin_src emacs-lisp
     (require 'org-agenda)
     (setq org-agenda-custom-commands nil)
   #+end_src
*** Set up agenda files lists
    I keep one set of agenda files for personal / everyday use and another for work use.

    For work files, the rules are:
    + include the primary working file (e.g. mycompany.org.gpg)
    + include all all task files under the active engagements directory
      (e.g. ./mycompany/engagements/customer1/customer1.org.gpg)
    + Active task files are either any encrypted org file under engagements/ or the single
      unencrypted org file named for its containing directory
      (e.g. ./mycompany/engagements/customer2/customer2.org)
    + include the special case =inbox.org=

  #+begin_src emacs-lisp
    ;; Make sure we match encrypted files for Agenda
    ;; ref https://emacs.stackexchange.com/a/36543/418
    (unless (string-match-p "\\.gpg" org-agenda-file-regexp)
      (setq org-agenda-file-regexp
            (replace-regexp-in-string "\\\\\\.org" "\\\\.org\\\\(\\\\.gpg\\\\)?"
                                      org-agenda-file-regexp)))
    (global-set-key (kbd "C-c a") 'org-agenda)
    (setq gjg/org-agenda-directory "~/projects/private-orgmode/")
    (setq gjg/personal-org-agenda-files '("~/projects/private-orgmode/notes.org"
                                          "~/projects/private-orgmode/learning.org"
                                          "~/projects/private-orgmode/inbox.org"
                                          "~/projects/private-orgmode/someday.org"
                                          "~/projects/private-orgmode/projects.org"
                                          "~/projects/private-orgmode/habits.org"))
    (defun gjg/get-work-agenda-files ()
      "Return list of work agenda files exculding archive/ dir.  Can be called in :scope param of clocktable"
      (let ((engagement-files (directory-files-recursively (concat (f-dirname gjg/employer-org-file) "/engagements/")
                                                           "\\`[^.].*\\.org\\(\\.gpg\\)?\\'")))
        (add-to-list 'engagement-files gjg/employer-org-file t)
        (add-to-list 'engagement-files "~/projects/private-orgmode/inbox.org" t)
        ;; (add-to-list 'engagement-files "~/projects/private-orgmode/projects.org" t)
        ))
        ;; (add-to-list 'engagement-files "~/projects/private-orgmode/projects.org" t)))
    (add-to-list 'gjg/agenda-contexts-alist `(work ,(gjg/get-work-agenda-files)))
    (add-to-list 'gjg/agenda-contexts-alist `(home ,gjg/personal-org-agenda-files))
    (add-to-list 'gjg/agenda-contexts-alist `(fitness ,(list "~/projects/private-orgmode/fitness/fitness.org")))
    (add-to-list 'gjg/agenda-contexts-alist `(notes ,(list "~/gregj-notes/" "~/gregj-notes/journals/")))



    (setq gjg/work-agenda-files (gjg/get-work-agenda-files))
    ;; Set agenda files to personal, override in work-related templates
    (setq org-agenda-files gjg/personal-org-agenda-files)
  #+end_src
*** Set icons for agenda views
    These work by =category=
**** Resize icons to be used in agenda views
      Resize icons for use in agenda views to be square - helps with column alignment
      #+begin_src bash
        i=my-/where/ever/icon.png
        j=$(basename $i)
        convert -resize 512x512 $i -background transparent -gravity center -extent 512x512  ~/emacs/pixmaps/$j-512x512.png; done
      #+end_src
**** Set icon definitions by category
     #+begin_src emacs-lisp
       ;;(setq org-agenda-span 'day)
       ;;(setq org-agenda-skip-scheduled-if-done t)
       ;; (setq org-agenda-start-with-log-mode t)
       ;; (setq org-agenda-start-with-clockreport-mode nil)
       (setq org-agenda-category-icon-alist
             `(
               ("charity" "~/emacs/pixmaps/charity.png" nil nil :ascent center :height 32)
               ("coding" "~/emacs/pixmaps/math-function.png" nil nil :ascent center :height 32)
               ("emacs" "~/emacs/pixmaps/emacs-512x512.png" nil nil :ascent center :height 32)
               ("finances" "~/emacs/pixmaps/finances-512x512.png" nil nil :ascent center :height 32)
               ("fire" "~/emacs/pixmaps/fire.png" nil nil :ascent center :height 32)
               ("fitness" "~/emacs/pixmaps/fitness-heart-512x512.png" nil nil :ascent center :height 32)
               ("gwennie" "~/emacs/pixmaps/loon-512x512.png" nil nil :ascent center :height 32)
               ("ai"    "~/emacs/pixmaps/mindmap-icon-512x512.png" nil nil :ascent center :height 32)
               ("ideas" "~/emacs/pixmaps/mindmap-icon-512x512.png" nil nil :ascent center :height 32)
               ("inbox" "~/emacs/pixmaps/office-inbox-512x512.png" nil nil :ascent center :height 32)
               ("journal" "~/emacs/pixmaps/mindmap-icon-512x512.png" nil nil :ascent center :height 32)
               ("languages" ,(list (all-the-icons-fileicon "moment-tz" )) nil nil :ascent center :height 32)
               ("linux" "~/emacs/pixmaps/linux-color-512x512.png" nil nil :ascent center :height 32)
               ("music" "~/emacs/pixmaps/banjo-transparent-512x512.png" nil nil :ascent center :height 32)
               ("networking" "~/emacs/pixmaps/network-wired-512x512.png" nil nil :ascent center :height 32)
               ("notes" "~/emacs/pixmaps/mindmap-icon-512x512.png" nil nil :ascent center :height 32)
               ("social" "~/emacs/pixmaps/icon-social-events-512x512.png" nil nil :ascent center :height 32)
               ("Stardog" "~/emacs/pixmaps/stardog-logo-512x512.png" nil nil :ascent center :height 32)
               ("work-habit" "~/emacs/pixmaps/gtd-logo-2019-512x512.png" nil nil :ascent center :height 32)
               ;; ("inbox" ,(list (all-the-icons-material "inbox" )) nil nil :ascent center :height 32)
               ;; Customers / engagements
               ("cis" "~/emacs/pixmaps/cis-security-logo-512x512.png" nil nil :ascent center :height 32)
               ("disney" "~/emacs/pixmaps/disney-logo-512x512.png" nil nil :ascent center :height 32)
               ("faithlife" "~/emacs/pixmaps/faithlife-logo-512x512.png" nil nil :ascent center :height 32)
               ("forge" "~/emacs/pixmaps/Forge-Global.png" nil nil :ascent center :height 32)
               ("guidehouse" "~/emacs/pixmaps/guidehouse-logo-512x512.png" nil nil :ascent center :height 32)
               ("gates" "~/emacs/pixmaps/gates-foundation.png" nil nil :ascent center :height 32)
               ("hagerty" "~/emacs/pixmaps/hagerty.png" nil nil :ascent center :height 32)
               ("ida" "~/emacs/pixmaps/ida-logo-512x512.png" nil nil :ascent center :height 32)
               ("investec" "~/emacs/pixmaps/investec-logo-512x512.png" nil nil :ascent center :height 32)
               ("john deere" "~/emacs/pixmaps/tractor-flat-512x512.png" nil nil :ascent center :height 32)
               ("navitas" "~/emacs/pixmaps/navitas-favicon.png" nil nil :ascent center :height 32)
               ("optum" "~/emacs/pixmaps/optum-logo-512x512.png" nil nil :ascent center :height 32)
               ("picpay" "~/emacs/pixmaps/picpay-logo-512x512.png" nil nil :ascent center :height 32)
               ("sherwin" "~/emacs/pixmaps/Paint-3D-icon-logo.png" nil nil :ascent center :height 32)
               ("UL" "~/emacs/pixmaps/UL_Mark.svg.png" nil nil :ascent center :height 32)
               ("vizient" "~/emacs/pixmaps/vizient-logo-512x512.png" nil nil :ascent center :height 32)))
       (setq org-agenda-sticky t
             org-agenda-fontify-priorities t
             org-agenda-hide-tags-regexp "noagenda"
             org-agenda-restore-windows-after-quit t
             -agenda-entry-text-maxlines 10
             org-agenda-diary-file "~/projects/private-orgmode/diary.org"
             org-agenda-include-diary t
             org-special-ctrl-a/e t
             org-agenda-clockreport-parameter-plist '(:link t :maxlevel 99)
             org-cycle-separator-lines 1
             org-clock-history-length 12)

       (setq org-agenda-exporter-settings
             '((ps-number-of-columns 1)
               (ps-landscape-mode t)
               (org-agenda-add-entry-text-maxlines 10)
               (htmlize-output-type 'css)))

      #+end_src
**** Test icons for alignment and um .... prettiness
     Test the icons set in
     #+begin_src org :tangle /tmp/test-icons.org
       ,* Ohai
         Use this to check icons and alignment in a TODO agenda buffer narrowed to this file

       ,* TODO check a thing
         :PROPERTIES:
         :CATEGORY: emacs
         :END:
       ,* TODO check a thing
         :PROPERTIES:
         :CATEGORY: Stardog
         :END:
       ,* TODO check a thing
         :PROPERTIES:
         :CATEGORY: notes
         :END:
       ,* TODO check a thing
         :PROPERTIES:
         :CATEGORY: work-habit
         :END:
       ,* TODO check a thing
         :PROPERTIES:
         :CATEGORY: linux
         :END:
       ,* TODO check a thing
         :PROPERTIES:
         :CATEGORY: music
         :END:
       ,* TODO check a thing
         :PROPERTIES:
         :CATEGORY: networking
         :END:
       ,* TODO check a thing
         :PROPERTIES:
         :CATEGORY: languages
         :END:
       ,* TODO check a thing
         :PROPERTIES:
         :CATEGORY: Chubb
         :END:
       ,* TODO check a thing
         :PROPERTIES:
         :CATEGORY: john deere
         :END:
       ,* TODO check a thing
         :PROPERTIES:
         :CATEGORY: PicPay
         :END:
       ,* TODO check a thing
         :PROPERTIES:
         :CATEGORY: guidehouse
         :END:
       ,* TODO check a thing
         :PROPERTIES:
         :CATEGORY: optum
         :END:
       ,* TODO check a thing
         :PROPERTIES:
         :CATEGORY: inbox
         :END:
       ,* TODO check a thing
         :PROPERTIES:
         :CATEGORY: social
         :END:
       ,* TODO check a thing
         :PROPERTIES:
         :CATEGORY: fitness
         :END:
       ,* TODO check a thing
         :PROPERTIES:
         :CATEGORY: gwennie
         :END:
       ,* TODO check a thing
         :PROPERTIES:
         :CATEGORY: finances
         :END:
     #+end_src
*** Custom Agenda definitions
**** Cross-context agendas
***** Basic Agenda with work habits added
     #+begin_src emacs-lisp
       (add-to-list 'org-agenda-custom-commands
                    '("A" "Agenda + work habits"
                      (
                       (agenda "" ((org-agenda-span 'day)
                                   (org-agenda-sorting-strategy
                                    (quote ((agenda time-up priority-down tag-up))))
                                   ;; (org-agenda-category-filter-preset (list "-work-habit"))
                                   (org-agenda-files (cons "~/projects/private-orgmode/work-habits.org" gjg/personal-org-agenda-files))
                                   (org-deadline-warning-days 0)))
                       )) t)
     #+end_src
***** Notes/Roam/Denote TODOs
      TODO: make category section of agenda the value of keywords in the front matter
      #+begin_src emacs-lisp
        ;; for example, category would be "linux-steam-deck"
        ;; (mapconcat 'identity (mapcar #'substring-no-properties org-file-tags) "-")
        ;; (string-join (mapcar #'substring-no-properties org-file-tags) "-")
        ;; use just org files in the notes directory
        (add-to-list 'org-agenda-custom-commands '("n" . "Notes prefix key")) ; describe prefix
        (add-to-list 'org-agenda-custom-commands
                     '("na" "Notes agenda"
                       ((agenda "" (
                                    (org-agenda-files '("~/gregj-notes/" "~/gregj-notes/journals/"))
                                    (org-agenda-span 'week)
                                    )
                                ))
                       ) t)
        (add-to-list 'org-agenda-custom-commands
                     '("nr" "Zettelkastenistische REVIEW" tags "-reviewed-do_not_review"
                       ((org-agenda-files '("~/gregj-notes/" "~/gregj-notes/journals/"))
                        (org-agenda-overriding-header "Notes Review")
                        ;; (org-agenda-prefix-format "")
                        )))
        (add-to-list 'org-agenda-custom-commands
                     '("nt" "Zettelkastenistische Note TODOs" todo ""
                       ((org-agenda-files '("~/gregj-notes/" "~/gregj-notes/journals/"))
                        (org-agenda-overriding-header "TODO items from Zettelkasten/Denote/Roam notes")
                        ;; (org-agenda-prefix-format "")
                        )))
      #+end_src
**** Work agendas
***** The big (W)ork agenda
       These views use the work files

       TODO  why does starting with clocktable and/or log-mode not work??
       #+begin_src emacs-lisp
         (add-to-list 'org-agenda-custom-commands
                      '("W" "Work Agenda"
                        (
                         ;; Work / Laptop Habits section
                         ;; (agenda ""
                         ;;         ((org-agenda-files '("~/projects/private-orgmode/work-habits.org"))
                         ;;          (org-agenda-start-with-log-mode nil)
                         ;;          (org-agenda-start-with-clockreport-mode nil)
                         ;;          (org-agenda-overriding-header "Work/Laptop Morning Tasks")))
                         ;; Work agenda with clocked time
                         (agenda ""
                                 ((org-agenda-span 'day)
                                  (org-agenda-files (cons "~/projects/private-orgmode/work-habits.org" gjg/work-agenda-files ))
                                  (org-agenda-start-with-log-mode '(clock))
                                  (org-deadline-warning-days 2)
                                  (org-agenda-start-with-clockreport-mode t)
                                  (org-agenda-start-with-log-mode t)
                                  )
                                 )
                         ;; TODOs for Stardog and prospects/customers
                         (todo ""
                               ((org-agenda-span 'day)
                                (org-agenda-files gjg/work-agenda-files)
                                (org-agenda-overriding-header "Stardog and customer TODOs")
                                (org-deadline-warning-days 21)
                                ))
                         ))
                      t)
       #+end_src
***** special filtering
      #+begin_src emacs-lisp
        (add-to-list 'org-agenda-custom-commands '("p" . "Priority filtered TODO"))
        (add-to-list 'org-agenda-custom-commands
                     '("pa" "#A Priority" todo ""
                       ((org-agenda-entry-types '(:scheduled))
                        (org-agenda-skip-function '(org-agenda-skip-entry-if 'notregexp "\\[#A\\]")))))
        (add-to-list 'org-agenda-custom-commands
                     '("pb" "#B Priority" todo ""
                       ((org-agenda-entry-types '(:scheduled))
                        (org-agenda-skip-function '(org-agenda-skip-entry-if 'notregexp "\\[#B\\]")))))
        (add-to-list 'org-agenda-custom-commands
                     '("pc" "#C Priority" todo ""
                       ((org-agenda-entry-types '(:scheduled))
                        (org-agenda-skip-function '(org-agenda-skip-entry-if 'notregexp "\\[#C\\]")))))

      #+end_src
**** Home based agendas
***** Fitness and @home
      #+begin_src emacs-lisp
        ;; TODO Filter on fitness tag
        (add-to-list 'org-agenda-custom-commands
                     '("f" "Fitness"
                       ((agenda "" (
                                    (org-agenda-span 'day)
                                    (org-agenda-files '("~/projects/private-orgmode/fitness/fitness.org")))))) t)
        (add-to-list 'org-agenda-custom-commands
                     '("h" "thing TODO at Home"
                       (
                        (agenda "" ((org-agenda-span 'day)
                                    (org-agenda-sorting-strategy
                                     (quote ((agenda time-up priority-down tag-up))))
                                    (org-agenda-category-filter-preset (list "-habits"))
                                    (org-agenda-files (cons "~/projects/private-orgmode/work-habits.org" gjg/personal-org-agenda-files))
                                    (org-deadline-warning-days 0)))
                        (tags-todo "+dailies+SCHEDULED<=\"<today>+1\"" ((org-agenda-files gjg/personal-org-agenda-files)))
                        (tags "reading")
                        (tags "writing")
                        (tags-todo "refile"))
                       ((org-agenda-tag-filter-preset '("-project" "-@office"))
                        )) t)

        (add-to-list 'org-agenda-custom-commands
                     '("i" "Inbox review"
                       ((todo "TODO"
                              ((org-agenda-overriding-header "Review and Refile")
                               (org-agenda-files '(,(concat gjg/org-agenda-directory "inbox.org"))))))) t)
      #+end_src
***** Started/Paused/Waiting personal tasks
      #+begin_src emacs-lisp
      ;; (add-to-list 'org-agenda-custom-commands
      ;; '("P" "Projects" tags "Project|project|PROJECT" ((org-use-tag-inheritance nil))))

      (add-to-list 'org-agenda-custom-commands
                   '("S" "Started Tasks" todo "STARTED" ((org-agenda-todo-ignore-with-date nil))))

      (add-to-list 'org-agenda-custom-commands
                   '("w" "Tasks waiting on something" tags "WAITING|PAUSED" ((org-use-tag-inheritance nil))))

      #+end_src
*** Agenda hooks setup
    #+begin_src emacs-lisp
      ;; org-agenda: some handy keys
      ;; you might also want to set:
      (setq org-agenda-skip-unavailable-files t)
      (add-hook 'org-agenda-mode-hook
                (lambda ()
                  ;; undo the horrendous "o" key binding (bound to 'delete-other-windows)
                  ;;       (local-unset-key "o")
                  ;; rebind to a sweet and beautiful function
                  (org-defkey org-agenda-mode-map "o" 'org-agenda-show)
                  (yafolding-mode 1)
                  (local-unset-key "a") ;; don't let this accidentally archive a tree!
                  ;; "R" is used for clock report by default
                  ;; (define-key org-agenda-mode-map "R" 'org-agenda-refile)
                  (define-key org-agenda-mode-map "'" 'org-agenda-clockreport-mode)
                  (define-key org-agenda-mode-map  "g" 'org-agenda-redo) ;; instead of org-agenda-redo-all
                  ;; (define-key org-agenda-mode-map "h" 'org-habit-toggle-display-in-agenda)
                  ))
      (add-hook 'org-export-preprocess-hook
                (lambda ()
                  (org-dblock-update 2) ;; update all dynamic blocks in the buffer
                  ))
      ;; Function stolen from Bernt Hansen on gmane.emacs.orgmode: insert inactive time stamp for new entries

      (setq org-agenda-format-date
            (concat "%Y-%m-%d %a "
                    (make-string (- (window-width) 15) (string-to-char "_"))))

   #+end_src
*** Clock table
    #+begin_src emacs-lisp
      ;; First set clock summary to *not* show hours as days
      ;; ref: https://stackoverflow.com/a/54376827/457574
      (with-eval-after-load 'org-clock
        ;; (setq org-duration-format (quote h:mm)) ;; only in Org 9.1+
        (plist-put org-clocktable-defaults :fileskip0 t)
        (plist-put org-clocktable-defaults :emphasize t)
        (plist-put org-clocktable-defaults :link t)
        (plist-put org-clocktable-defaults :narrow '75!))
    #+end_src
*** Agenda context
    This is something to help separate work time.

    No dependency on Org or Org Agenda being loaded

    #+begin_src emacs-lisp
      ;; (let* ((thetime (decode-time))
      ;;        (dow (nth 6 thetime))
      ;;        (hour (nth 2 thetime)))
      ;;   (if (and (< dow 6) (> hour 7) (< hour 18))
      ;;       (gjg/select-agenda-context 'work)
      ;;     (gjg/select-agenda-context 'home)))
      (gjg/select-agenda-context 'home) ;; default to 'home context regardless
    #+end_src

** Tags/TODOs/Projects Oh My
   #+begin_src emacs-lisp
     (setq org-tag-persistent-alist
       '(("habit")
         ("billable")
         ("noexport" . ?x)
         ))
     (setq org-tag-alist '(("project" . ?p)
               ("processed" . ?.)
               ("NEXT" . ?n)
               ("noexport" . ?x)
               ("cloud" . ?c)
               (:startgroup . nil)
               ("@customer")
               ("@office" . ?o)
               ("@home" . ?h)
               ("@errands" . ?e)
               ("@happy-hour")
               (:endgroup . nil)
               ("maybe-someday" . ?m)
               ("writing" . ?w)
               ))
     ;; Projects are identified by a :Project: tag unless they are marked DONE;
     ;;   Any project must have one sub-task identified by :NEXT: to be considered un-stuck
     ;;   MAYBE: exclude special tags like Someday/Maybe
     (setq org-stuck-projects '("Project|project/-DONE"
                nil
                ("NEXT")
                ""))
     (setq org-columns-default-format "%TODO %CATEGORY %60ITEM(Task)%5Effort(Estim){:} %5CLOCKSUM(Clock) %SCHEDULED(Time) %DEADLINE")
     (setq org-todo-keywords (quote ((sequence "TODO(t)" "STARTED(s!)" "PAUSED(p!)" "|" "DONE(d!)")      ;; ordinary sequence is Todo -> Started -> Done
                     (sequence "WAITING(w@/!)" "MAYBE(m!)" "NEXT(n!)" "OPEN(O@)" "|" "CANCELLED(c@/!)" "SUBMITTED(S)") ;; "oddball" states that any task may be set to
                     ;; (sequence "QUOTE(q!)" "QUOTED(Q!)" "|" "APPROVED(A@)" "EXPIRED(E@)" "REJECTED(R@)")     ;; sequence for quotes
                     )))
     ;; (setq org-todo-keyword-faces
     ;;       '(("TODO"
     ;;          (:foreground "#ff39a3" :weight bold))
     ;;         ("STARTED" . "#E35DBF")
     ;;         ("CANCELLED" :foreground "green" :weight bold :strike-through t)
     ;;         ("PROPOSED" . "pink")
     ;;         ("PAUSED"  . "yellow")
     ;;         ("WAITING" . "yellow")))

     ;; (setq org-todo-state-tags-triggers
     ;;       (quote (("CANCELLED" ("CANCELLED" . t))
     ;; 	      ("WAITING" ("WAITING" . t) ("NEXT"))
     ;; 	      ("SOMEDAY" ("WAITING" . t))
     ;; 	      (done ("NEXT") ("WAITING"))
     ;; 	      ("TODO" ("WAITING") ("CANCELLED"))
     ;; 	      ("STARTED" ("WAITING") ("NEXT" . t)))))
     ;; Change task state to STARTED when clocking in
     (setq org-clock-in-switch-to-state "STARTED")

     (setq org-tags-exclude-from-inheritance '("Project" "project" "interview2"))
					     ;(setq org-tag-alist '(("project" . ?p)("car" . ?c)))
   #+end_src
** Refile
   I think the best approach here is to use =org-agenda-files= as the source for refile
   targets.  Then set =org-agenda-files= to whatever is appropriate for current context -
   i.e., work vs home

   Zettelkastenistische noten should *always* be available

   #+begin_src emacs-lisp
     ;; navigate to files using org-refile; use C-u C-c C-w
     (setq org-outline-path-complete-in-steps nil) ; use completion framework for quicker completion
     ;; Refile targets should be limited to org-agenda-files
     ;; TODO remove inbox.org based on absolute expanded path
     (setq org-refile-targets '((org-agenda-files :maxlevel . 2))
           org-refile-use-outline-path 'file
           org-refile-target-verify-function (lambda () (not (member "ARCHIVE" (org-get-tags)))))

     (defun gjg/org-refile-goto ()
       "Call org-refile with arg to visit an org-mode location. A convenience function to bind to a global key."
       (interactive)
       (org-refile 1))


   #+end_src

** Clocking time
*** Variables and keys
    Keep =org-clock-persist= unset (its default) to avoid opening files that may have had
    clock activity - the problem in my case is that many of those files are encrypted so I
    have to enter a pass phrase just to open nearly any Org mode file!  The problematic
    code is in the =org-clock= library:
    #+begin_src emacs-lisp :tangle no
      (defun org-clock-load ()
        "Load clock-related data from disk, maybe resuming a stored clock."
        (when (and org-clock-persist (not org-clock-loaded))
          (if (not (file-readable-p org-clock-persist-file))
          (message "Not restoring clock data; %S not found" org-clock-persist-file)
            (message "Restoring clock data")
            ;; Load history.
            (load-file org-clock-persist-file)
            (setq org-clock-loaded t)
            (pcase-dolist (`(,(and file (pred file-exists-p)) . ,position)
                   org-clock-stored-history)
          (org-clock-history-push position (find-file-noselect file)))
      ...
    #+end_src
    #+begin_src emacs-lisp
      (setq org-clock-persist nil
            org-duration-format 'h:mm ; format of clocktable - show hours, not days
            org-clock-string-limit 60 ; truncate very long clocked tasks
            org-clock-report-include-clocking-task t
            org-read-date-prefer-future 'time)
      ;; (org-clock-persistence-insinuate)
      ;; make the clock jump key global!
      (global-set-key (kbd "s-j") 'org-clock-goto)
    #+end_src
*** Clock in also to Harvest for work files
    + [[https://kgajera.github.io/hrvst-cli/][Getting Started | Harvest CLI â‰« kgajera.github.io]]
      #+begin_src bash
        npm install -g hrvst-cli
      #+end_src
    + Goal - when clocking in on work tasks (org file is somewhere in
      ~/projects/private-orgmode/rancher), prompt for project/task to start timer for in
      Harvest also.

      TODO: Make =hcl= commands async
      #+begin_src emacs-lisp :tangle no
        (defun gjg/start-harvest-timer ()
          (interactive)
          (let ((harvest-alias
                 (completing-read
                  "Harvest project: "
                  (split-string
                   (concat "non-harvest,"
                           (string-trim (shell-command-to-string "hcl aliases"))) "[ ,]+"))))
                  ;; nil ; no predicate to limit choices
                  ;; nil ; do not require match
                  ;; "non-harvest")))
            (if (string= "@" (substring harvest-alias 0 1))
                (progn
                      (message (format "Clocking in to %s" harvest-alias))
                      (call-process-shell-command
                       (format "hcl start %s '%s'" harvest-alias org-clock-heading)
                       nil
                       "harvest-commands"))
              (message "Not clocking into Harvest"))))


        (defun gjg/stop-harvest-timer ()
          (interactive)
          (call-process-shell-command
           "hcl stop"
           nil
           "harvest-commands")
          (message "Stopped harvest timer (if any)"))

        ;; (add-hook 'org-clock-in-hook 'gjg/start-harvest-timer)
        ;; (add-hook 'org-clock-out-hook 'gjg/stop-harvest-timer)

                  ;; (message (format "Selected task is %s" org-clock-heading) )))
      #+end_src
*** Start nag timer during work hours
    #+begin_src emacs-lisp :tangle no
      (let* ((datetime (decode-time))
              (hour (nth 2 datetime))
              (dow  (nth 6 datetime)))
        (if (and (> dow 0) (< dow 6) (> hour 7) (< hour 18))
            (gjg/nag)
          (gjg/cancel-nag)))
    #+end_src
** Behavior
#+begin_src emacs-lisp
  (setq org-adapt-indentation t
        org-agenda-window-setup 'current-window ; make c-y pay attention to current level
        org-yank-adjusted-subtrees t
        ;; org-yank-folded-subtrees nil
        org-insert-heading-respect-content t    ; new headings go AFTER CONTENT, even from the middle of content area
        org-indirect-buffer-display 'other-window
        org-reverse-note-order t                ; notes go at the top
        org-return-follows-link t
        org-treat-S-cursor-todo-selection-as-state-change nil ; use S-arrow without having to log state change!
        org-log-into-drawer t
        org-export-use-babel nil
        org-export-with-sub-superscripts nil
        org-html-extension "org.html"
        org-replace-disputed-keys t)
  ;; delete the seleted region when something is typed - don't do that
  (delete-selection-mode -1)

  ;; show only current/today's/all time in the clock task modeline
  ;; this SHOULD be settable on a file basis by using property CLOCK_MODELINE_TOTAL
  (setq org-clock-mode-line-total 'today)
  (setq org-loop-over-headlines-in-active-region t)
#+end_src
** Org Drill flashcards
#+begin_src emacs-lisp :tangle no
(defun gjg/org-drill-set-cloze1 ()
  "Set current question as `cloze1` type"
  (interactive)
  (insert ":PROPERTIES:\n:DRILL_CARD_TYPE: hide1cloze\n:END:\n")
  )

#+end_src
* Presentation and screencasting
  Most everything I use is encoded in my own Org-as-presentation method using the
  ded/org-show-{next,prev}-heading-tidily bound to global keys

  The rest is outside of Emacs (OBS Studio for example)

  But for this one bitlet: echoing keystrokes during a screencast.
  #+begin_src emacs-lisp
    (use-package command-log-mode :straight t :defer t)
  #+end_src
* Programming language modes

** All modes derived from =prog-mode=
   #+begin_src emacs-lisp
     (add-hook 'prog-mode-hook
               (lambda ()
                      (rainbow-delimiters-mode 1)
                 (corfu-mode 1)
                 (yafolding-mode 1)
                 (electric-pair-local-mode 1)))
   #+end_src

   Let's throw in IELM =inferior-emacs-lisp-mode=, which derives from =comint-mode=
   #+begin_src emacs-lisp
     (add-hook 'inferior-emacs-lisp-mode-hook
               (lambda ()
                 (rainbow-delimiters-mode 1)
                 (corfu-mode 1)
                 (electric-pair-local-mode 1)))

   #+end_src
   And we'll do the same for the Sly REPL(s)
   #+begin_src emacs-lisp
     (add-hook 'sly-mrepl-mode-hook
               (lambda ()
                 (rainbow-delimiters-mode 1)
                 (electric-pair-local-mode 1)))
   #+end_src
** Language Servers and setup for LSP / Eglot
*** Language Servers
**** Bash
     #+begin_src bash
       sudo npm install --save-dev bash-language-server
     #+end_src
**** Go
     #+begin_src bash
       sudo apt -y install gopls
     #+end_src
**** Go
     #+begin_src bash
       go install golang.org/x/tools/gopls@latest
     #+end_src

**** JavaScript / TypeScript / Node.js
     #+begin_src bash
       sudo npm install --save-dev typescript-language-server
     #+end_src
**** Python
     #+begin_src bash
       sudo apt -y install python3-pyls
     #+end_src
**** R
     #+begin_src R
       install.packages("languageserver")
     #+end_src
**** SQL
     #+begin_src bash
       sudo npm i -g sql-language-server
     #+end_src
**** YAML
     #+begin_src bash
       sudo npm install --save-dev yaml-language-server
     #+end_src
*** Eglot
    Best LSP supporting mode available - and a built-in as of Emacs 29!
    #+begin_src emacs-lisp
      (when (< emacs-major-version 29)
        (use-package eglot :straight t))
    #+end_src
** SPARQL
   #+begin_src emacs-lisp
     (use-package sparql-mode :straight t
       :mode "\\.\\(sparql\\|rq\\|sms\\|sms2\\)\\'"
       ;; :hook (sparql-mode . lsp-deferred)
       ;; :config
       ;; (add-to-list 'lsp-language-id-configuration '(sparql-mode . "sparql"))
       ;; :custom
       ;; (sparql-language-server)
       )
   #+end_src
   #+begin_src emacs-lisp
     ;; (add-to-list 'lsp-language-id-configuration '(".*\\.sparql" . "sparql"))
;;     (add-to-list 'lsp-language-id-configuration '(sparql-mode . "sparql"))
   #+end_src

** Clojure
   #+begin_src emacs-lisp
     ;; (add-hook 'cider-repl-mode-hook #'company-
     (use-package clojure-mode :straight t
       :mode "\\.clj[sc]?\\'"
       ;; :config
       ;; (add-hook 'clojure-mode-hook #'lispy-mode)
       )

     (use-package cider :straight t
       ;; :mode "\\.clj[sc]?\\'"
       )
     ;; ;; (add-to-list 'load-path "~/emacs/cider")
     ;; (autoload 'cider "cider" "Cider for Clojure")
     ;; (require 'cider)
     ;; (eval-after-load "cider"
     ;;   '(progn
     ;;      ;; (require 'cider)
     ;;      ;; (defadvice cider--lein-present-p (around gjg-find-the-damn-script activate)
     ;;      ;;   "Lein shell script is not detected on Windows as executable"
     ;;      ;;   (if (eq window-system 'w32)
     ;;      ;;       (setq ad-return-value (or (file-remote-p default-directory)
     ;;      ;;    			     (locate-file "lein" exec-path nil 'exists)))
     ;;      ;;     (ad-do-it)))
     ;;      (add-hook 'cider-repl-mode-hook 'company-mode)
     ;;      (add-hook 'cider-mode-hook 'company-mode)))

   #+end_src
** Go
   Initial configuration was nabbed from a 2-parter by @tleydn
   [[http://tleyden.github.io/blog/2014/05/22/configure-emacs-as-a-go-editor-from-scratch/][Configure Emacs as a Go Editor From Scratch]]

   #+begin_src emacs-lisp :tangle no
     (use-package go-mode :straight t
       :defer t
       :custom
       :config
       (add-hook 'go-mode-hook (lambda () (add-hook 'before-save-hook 'ime-go-before-save)))
       (use-package go-autocomplete :straight t)
       (auto-complete-mode 1)
       (setenv "GOPATH" (expand-file-name "~/projects/coding/go/"))
       )
     ;; (setenv "GOPATH" (expand-file-name "~/projects/coding/go/"))
     ;; (defun my-go-mode-hook ()
     ;;   ; Use goimports instead of go-fmt
     ;;   (setq gofmt-command "goimports")
     ;;   ;; Call Gofmt before saving
     ;;   (add-hook 'before-save-hook 'gofmt-before-save)
     ;;   ;; jump into code with M-. and jump back with M-*
     ;;   (local-set-key (kbd "M-.") 'godef-jump)
     ;;   (local-set-key (kbd "M-*") 'pop-tag-mark)
     ;;   ;; Customize compile command to run go build
     ;;   ;; NOTE: may want to start with =go generate= for some projects
     ;;   (if (not (string-match "go" compile-command))
     ;;       (set (make-local-variable 'compile-command)
     ;;            "go build -v && go test -v && go vet"))
     ;;   ;; ; Go oracle/guru
     ;;   ;; (load-file "$GOPATH/src/golang.org/x/tools/cmd/oracle/oracle.el")
     ;;   ;; (load-file "$GOPATH/sr")
     ;;   (auto-complete-mode 1)
     ;;   )
     ;; (add-hook 'go-mode-hook 'my-go-mode-hook)
     ;; (with-eval-after-load 'go-mode
     ;;   (require 'go-autocomplete))
   #+end_src

** Rust
   + [[https://robert.kra.hn/posts/2021-02-07_rust-with-emacs/][Configuring Emacs for Rust development | Robert Krahn]]
   #+begin_src emacs-lisp :tangle no
     (use-package rust-mode :straight t)
   #+end_src

** Javascript
*** Prefer =js2= mode
   #+begin_src emacs-lisp :tangle no
     (use-package js :straight t 2-mode

       :config
       (add-to-list 'auto-mode-alist '("\\.js$" . js2-mode)))
   #+end_src
*** Treat =.cue= as JSON or Bazel
    #+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("\\.cue$" . bazel-mode))

    #+end_src
** Python
*** LSP Language Server
    Just make sure the language server is installed before using LSP with Python
    #+begin_src bash
      pip install -U setuptools
      pip install python-lsp-server[all]
    #+end_src
*** Python mode setup
   #+begin_src emacs-lisp
     ;; Python

     (use-package python :straight t
       :custom
       (org-babel-python-command "python3")
       :config
       (setq python-shell-interpreter "ipython3"
             python-shell-interpreter-args "-i --simple-prompt")
       (setq org-babel-python-command "python3")
       (add-hook 'python-mode-hook
                 (lambda ()
                   (setq indent-tabs-mode nil)
                   (setq python-indent-offset 4)
                   (setq tab-width 4)
                   (pyvenv-mode t)))
       )
     (use-package pyvenv :straight t
       :config
       (setenv "WORKON_HOME" (expand-file-name "~/.local/python-venvs/")))
     (custom-set-variables '(org-babel-python-command "python3"))

     ;; (setq ansi-color-drop-regexp
     ;;       "\033\\[\\([ABCDsuK]\\|[12][JK]\\|=[0-9]+[hI]\\|[0-9;]*[Hf]\\|\\?[0-9]+[hl]\\|[0-9]+[CD]\\|J\\|6n\\)")
   #+end_src
*** Treat Bazel/Starlark files as Python
    #+begin_src emacs-lisp
      (add-to-list 'auto-mode-alist '("\\.starlark$" . python-mode))
    #+end_src
** Jupyter
   + Interesting blog post: [[https://sqrtminusone.xyz/posts/2021-05-01-org-python/][Replacing Jupyter Notebook with Org Mode]]
     + consider setting =(org-babel-jupyter-override-src-block "python")=
     + consider =(setq ob-async-no-async-languages-alist '("python" "jupyter-python"))=
   +

   #+begin_src emacs-lisp :tangle no
     ;; (use-package jupyter :straight t
     ;;
     ;;   )
     ;; config from https://martinralbrecht.wordpress.com/2020/08/23/conda-jupyter-and-emacs/
     (use-package jupyter :straight t
       :commands (jupyter-run-server-repl
                  jupyter-run-repl
                  jupyter-server-list-kernels)
       :init (eval-after-load 'jupyter-org-extensions ; conflicts with my helm config, I use <f2 #>
               '(unbind-key "C-c h" jupyter-org-interaction-mode-map)))
     ;; (use-package ob-ipython :straight t  ; abandoned project https://github.com/syl20bnr/spacemacs/issues/9941#issuecomment-543227397
     ;;   )
     ;; (use-package ein :straight t  )
     ;; (when (memq window-system '(mac ns x))
     ;;   (exec-path-from-shell-initialize))
   #+end_src
** R
   #+begin_src emacs-lisp :tangle no
     (use-package polymode :straight t
       :config
       (add-to-list 'auto-mode-alist '("\\.Snw" . poly-noweb+r-mode))
       (add-to-list 'auto-mode-alist '("\\.Rnw" . poly-noweb+r-mode))
       (add-to-list 'auto-mode-alist '("\\.Rmd" . poly-markdown+r-mode)))
     (use-package ess :straight t
       :config
       (setq ess-sas-edit-keys-toggle nil)
       :init (require 'ess-site))
   #+end_src
** Lisp
*** Common Lisp
    Here we will assume SBCL
    + Install SBCL from [[https://www.sbcl.org/getting.html][the website]]
    + [[https://lispcookbook.github.io/cl-cookbook/getting-started.html#install-quicklisp][Install Quicklisp]]
    + [[https://lispcookbook.github.io/cl-cookbook/getting-started.html#install-quicklisp][Getting started with Common Lisp]]
    + [[https://github.com/joaotavora/sly][joaotavora/sly: Sylvester the Cat's Common Lisp IDE â‰« github.com]]
    #+begin_src emacs-lisp :tangle no
      (load (expand-file-name "~/quicklisp/slime-helper.el"))
      ;; Replace "sbcl" with the path to your implementation
      (setq inferior-lisp-program "sbcl")
    #+end_src
    #+begin_src emacs-lisp
      (use-package sly :straight t
        :config
        (setq inferior-lisp-program "sbcl"
              org-babel-lisp-eval-fn 'sly-eval
              sly-symbol-completion-mode nil)
        (electric-pair-local-mode 1))
    #+end_src

*** Guile Scheme
    +
   Setup for Guile Scheme - primarily for use on Guix system
   #+begin_src emacs-lisp :tangle no
     (use-package geiser :straight t
       :config
       (setq geiser-default-implementation 'guile
             geiser-active-implementations '(guile)
             geiser-implementations-alist '(((regexp "\\.scm$") guile))
             ;; geiser-repl-default-port 44555 ; for Gambit Scheme (from @daviwil)
             ))
     (use-package geiser-guile :straight t)
   #+end_src
*** Racket Scheme
    :PROPERTIES:
    :ID:       4c49ed92-563b-488a-988a-de54a24dd7c1
    :END:
   #+begin_src emacs-lisp :tangle no
     (use-package geiser :straight t
       :config
       (setq geiser-default-implementation 'racket
             geiser-active-implementations '(racket)
             geiser-implementations-alist '(((regexp "\\.scm$") racket))
             ;; geiser-repl-default-port 44555 ; for Gambit Scheme (from @daviwil)
             ))
     (use-package geiser-racket :straight t  )
     (with-eval-after-load 'eglot
       (add-to-list 'eglot-server-programs '(scheme-mode . ("racket" "-l" "racket-langserver"))))
   #+end_src
** SQL and even GSQL
*** Crazy removal of sql-login-delay
    SQL connections are very very fast, yet I always wait ~8 seconds before I can start
    typing in a new interactive SQL buffer (at least for MySQL/MariaDB).  Why?  There's a
    section in the =sql-product-interactive= function that waits for pending output from a
    process for no apparent reason, snippet below
    #+begin_src emacs-lisp :tangle no
      (while (and proc
                  (memq (process-status proc) '(open run))

                  (or (accept-process-output proc step) ; ALWAYS returns nil IME

                      (<= 0.0 (setq secs (- secs step))))
                  (progn (goto-char (point-max))
                         (not (re-search-backward sql-prompt-regexp 0 t))))
        (sql-progress-reporter-update rpt))  # ....
    #+end_src

    Therefore, I shall try globally setting sql-login-delay to zero.  Wish me luck!
    #+begin_src emacs-lisp
      (setq sql-login-delay 0)
    #+end_src
*** Format SQL
    Emacs doesn't come out of the box with a useful SQL formatter, so go ahead and use an
    external process

    Ref https://emacs.stackexchange.com/a/35683/418

    #+begin_src bash
      pip3 install sqlparse
    #+end_src

    #+begin_src emacs-lisp :tangle no
      (defun gjg/sqlparse-region (beg end)
        (interactive "r")
        (shell-command-on-region
         beg end
         "python -c 'import sys, sqlparse; print(sqlparse.format(sys.stdin.read(), reindent=True))'"
         t t))
    #+end_src
*** Save command history for all SQL modes
    WIP WIP WIP
    Try setting comint-input-ring-file-name as buffer-local for sql-interactive-mode

    ref: [[https://stackoverflow.com/a/61192837/457574][emacs sql mode could not save history - Stack Overflow]]
    #+begin_src emacs-lisp :tangle no
      (defun gjg/sql-save-history-hook ()
        (let ((lval 'comint-input-ring-file-name)
              (rval 'sql-product))
          (if (symbol-value rval)
              (let ((filename
                     (concat "~/.emacs.d/sql/"
                             (symbol-name (symbol-value rval))
                             "-history.sql")))
                (set (make-local-variable lval) filename))
            (message "SQL history will not be saved because %s is nil"
                     (symbol-name rval)))))

      (add-hook 'sql-interactive-mode-hook 'gjg/sql-save-history-hook)
      (add-hook 'kill-buffer-hook 'comint-write-input-ring)
    #+end_src

*** MySQL / MariaDB

    + Assure that client prompt is recognized for both products
   #+begin_src emacs-lisp
     ;; (add-hook 'sql-interactive-mode-hook (lambda ()
     ;;                                        (setq sql-prompt-regexp "\\(Maria[BD]*\\|MySQL\\) [^\\>]+\\>")
     ;;                                        ))
     (with-eval-after-load 'sql
       ;; (sql-set-product-feature 'mysql :prompt-regexp "^\\(MariaDB\\|[Mm][Yy][Ss][Qq][Ll]\\) *\\[?[\\[\\]]]_a-zA-Z0-9()]*\\]?> ")
       (sql-set-product-feature 'mysql :prompt-regexp
                                "^\\(MariaDB\\|MySQL\\|mysql\\) \\[[\\(\\)_a-zA-Z]*\\]> ")
       (setq sql-mysql-options '("-C" "-t" "-f" "-n"))
       (sql-set-product-feature 'sqlite :prompt-regexp
                                "^\\(sqlite\\|\\|mysql\\) *\\[[\\(\\)_a-zA-Z]*\\]> ")
       )
   #+end_src
   + Allow for alternative port
     #+begin_src emacs-lisp
       (setq sql-mysql-login-params '(user password server database port))
       (setq sql-port 3306)
     #+end_src

*** Postgresql
    + Allow for alternative port
     #+begin_src emacs-lisp :tangle no
       (setq sql-postgres-login-params '(user password server database port))
       ;; (setq sql-port 3306)
     #+end_src
*** GSQL for TigerGraph
    Working on syntax highlighting for GSQL
    #+begin_src emacs-lisp :tangle no
      (load "~/projects/emacs/gsql-mode.el/gsql-mode")
    #+end_src
** Music notation - Lilypond et al
   :PROPERTIES:
   :ID:       20957aac-6d4a-4597-b68f-3a646ed238e5
   :END:
   =lilypond-mode= is provided by Lilypond installation - in debian it will be found
   installed in =/usr/share/emacs/site-lisp/lilypond-mode.el=

   #+begin_src emacs-lisp :tangle no
     (require 'lilypond-mode nil t) ; comes from lilypond OS package
     (use-package lilypond :straight t) ; provides ob-lilypond
   #+end_src

   =lilypond-mode= is not derived from =prog-mode= but we want the same hooks
   #+begin_src emacs-lisp :tangle no
     (setq LilyPond-mode-hook prog-mode-hook)
   #+end_src
** FINAL step after all language modes have been configured
   #+begin_src emacs-lisp
     (use-package ob-http :straight t)
     (org-babel-do-load-languages
      'org-babel-load-languages
      (append org-babel-load-languages
              '(
                (sparql . t)
                (clojure . t)
                (http . t) ;; curl
                (js . t)
                (latex . t)
                (lisp . t)
                ;;                (jupyter . t) ;; makes Emacs core dump??? (related to compiled zmq)
                (plantuml . t)
                (lilypond . t)
                (python . t)
                (shell  . t)
                (sql . t)
                )))
   #+end_src
* Devops
** Working with containers
   This is largely a function of TRAMP.  I have added simple ways to
   get Dired and =shell-mode= in
   + Docker containers using =docker-tramp= package
   + DC/OS tasks with the =dcos= TRAMP method
   + Kubernetes pods with the =kube= TRAMP method.  This will grab a
     shell on the first container defined in the pod
   + Google Cloud Shell with =gshell= TRAMP method

** Highlight Terraform and Ansible messages
   This function highlights the typical lines for:
   + Terraform (Creation/Destruction complete)
   + Ansible (RUNNING/STAGE/TASK/PLAY)
   + Docker build (Step n/n)

  #+begin_src emacs-lisp
    (defun gjg/highlight-terraform-stuff ()
      (interactive)
      ; Terraform patterns
      (highlight-regexp "Creation complete" 'hi-green)
      (highlight-regexp "Destruction complete" 'hi-pink)
      ; Docker build
      (highlight-regexp "Step [0-9]+/[0-9]+ : [A-Z]+" 'hi-aquamarine)
      ; Ansible
      (highlight-regexp "\\(RUNNING\\|STAGE\\|TASK\\|PLAY\\) .+" 'hi-black-b))

    (defun gjg/highlight-squid ()
      (interactive)
      ;; Registry pull-through cache
      (highlight-regexp "^HIT" 'hi-green)
      (highlight-regexp "^MISS" 'hi-pink)
      ;; Docker pull-through registry patterns
      (highlight-regexp "\"HIT\"" 'hi-green)
      (highlight-regexp "\"MISS\"" 'hi-pink)
      ;; Squid caching patterns
      (highlight-regexp "[A-Z_]*_HIT[A-Z_]*" 'hi-green)
      (highlight-regexp "[A-Z_]*_MISS[A-Z_]*" 'hi-pink)
      (highlight-regexp "[A-Z_]*_UNMODIFIED[A-Z_]*" 'hi-green)
      (highlight-regexp "application/[-a-z0-9A-Z]+" 'hi-yellow)
      (highlight-regexp "/[^/]+\.rpm" 'hi-black-b)
      (highlight-regexp "/[^/]+\.deb" 'hi-black-b))
  #+end_src

* Parade of Modelines
 The mode line is the most tweaky damn part of Emacs.  I can't get my head around the
 format mechanism, hence all packages must be tried.

 Fancy icons may require fonts (like =texlive-fonts-extra=)

** Frame title and mode line tweaks
  #+begin_src emacs-lisp
    ;; (require 'spaceline-config)
    ;; (setq spaceline-always-show-segments t)
    ;; (spaceline-spacemacs-theme)
    ;; show column number in modeline - in addition to line number
    (line-number-mode 1)
    (column-number-mode 1)
    ;; do not show load average
    (setq display-time-default-load-average nil)

    (setq frame-title-format (concat "emacs@" (system-name) " - %f; %b"))
    ;; fancy git icon
    (defadvice vc-mode-line (after strip-backend () activate)
      (when (stringp vc-mode)
        (let ((gitlogo (replace-regexp-in-string "^ Git." " ï„¦ " vc-mode))) ;; symbol from fonts-font-awesome
          (setq vc-mode gitlogo))))

  #+end_src
** Awesome Tray
   #+begin_src emacs-lisp :tangle no
     (use-package awesome-tray
       :straight (awesome-tray :type git :host github :repo "manateelazycat/awesome-tray")
       :config
       (setq awesome-tray-active-modules
             '("location" "git" "buffer-read-only" "buffer-name" "mode-name" "input-method" "battery" "date")
             awesome-tray-buffer-name-buffer-changed t
             awesome-tray-buffer-read-only-style "%")
       (awesome-tray-mode 0))
   #+end_src
** Doom modeline
   #+begin_src emacs-lisp
     (use-package doom-modeline :straight t
       :ensure t
       :after eshell     ;; Make sure it gets hooked after eshell
       :hook (after-init . doom-modeline-mode)
       ;; :custom-face
       ;; ;; (mode-line ((t (:height 0.85))))
       ;; (mode-line-inactive ((t (:height 0.95))))
       :custom
       ;; (doom-modeline-height 15)
       ;; (doom-modeline-bar-width 6)
       (doom-modeline-lsp t)
       (doom-modeline-github nil)
       ;; (doom-modeline-mu4e nil)
       ;; (doom-modeline-irc nil)
       (doom-modeline-minor-modes t)
       ;; (doom-modeline-persp-name nil)
       (doom-modeline-buffer-file-name-style 'truncate-except-project)
       (doom-modeline-major-mode-icon nil)
       :config
       ; remove selection-info segment from default
       (doom-modeline-def-modeline 'main
         '(bar workspace-name window-number modals matches follow buffer-info remote-host buffer-position word-count parrot )
         '(objed-state misc-info persp-name battery grip irc mu4e gnus github debug repl lsp minor-modes input-method indent-info buffer-encoding major-mode process vcs checker time))
       (doom-modeline-mode 1)
       ;; (doom-modeline-add-variable-watcher
       ;;  'doom-modeline--buffer-file-state-icon
       ;;  (lambda (_sym val op _where)
       ;;    (when (string= (buffer-name _where) "tryit.el")
       ;;      (message "DEBUG: %s %s %s %s" _sym val op _where))
       ;;    (when (eq op 'set)
       ;;      ;; (when (and val (not (string-empty-p val)))
       ;;        (setq doom-modeline--buffer-file-state-icon
       ;;              "ðŸš«"
       ;;              ;; (string-replace "î…¡" "OHAI" val)
       ;;              )
       ;;      ;; )
       ;;  )))
       )
     (use-package minions :straight t
       :hook (doom-modeline-mode . minions-mode)
       :custom
       (minions-mode-line-lighter "ï†’"))

   #+end_src
** Moodline
   #+begin_src emacs-lisp :tangle no
     (use-package mood-line :straight t
       :config
       (mood-line-mode 1))
   #+end_src
** Simple mode line
   #+begin_src emacs-lisp :tangle no
     (use-package simple-modeline :straight t

       :config
       (simple-modeline-mode 1))
   #+end_src
** Smart Mode line
   + Smart mode line defines a face for battery charging/discharging - thus green for
     10% plugged in, and red for 90% on battery.  I prefer the way =battery.el= sets
     faces for level of charge with +/- optionally for charging/discharging.
   #+begin_src emacs-lisp :tangle no
     (use-package smart-mode-line-powerline-theme :straight t)
     (use-package smart-mode-line :straight t
       :config
       (sml/setup))

     (advice-remove 'battery-update 'ad-Advice-battery-update)
   #+end_src
** Hide the little bleeder altogether
   Set to hide globally, then bind a Super key to toggle only the current buffer. Super
   nice to use when screen sharing - provides ={global-}hide-mode-line-mode=
   #+begin_src emacs-lisp
     (use-package hide-mode-line :straight t
       :config
       (global-hide-mode-line-mode 0)
       (bind-key "s-m" 'mood-line-mode))
   #+end_src
* Section of trying-things-out-and-please-remember-to-delete-them-if-they-dont-work-out
** TODO Review, optionally promote or delete new Emacs packages
   SCHEDULED: <2023-03-18 sÃ¡b .+1w>
   :PROPERTIES:
   :STYLE:    habit
   :END:

** Org super links
   + In constant search of cool backlinks
   + [[https://github.com/toshism/org-super-links][GitHub - toshism/org-super-links: Package to create links with auto backlinks]]
   #+begin_src emacs-lisp :tangle no
     (use-package org-super-links
       :straight (org-super-links :type git :host github :repo "toshism/org-super-links" :branch "develop")
       :bind (("C-c s s" . org-super-links-link)
              ("C-c s l" . org-super-links-store-link)
              ("C-c s C-l" . org-super-links-insert-link)))
   #+end_src
** Theme magic - sync system with EMACS theme (unused)
   Make use of this at any time with =M-x theme-magic-from-emacs=

   Consider putting this in a hook when changing themes - or simply in my
   =gjg/go-{light,dark}= functions

   #+begin_src emacs-lisp :tangle no
     (use-package theme-magic :straight t)
   #+end_src
** New built-in functions in 29 to consider adding to workflow
   + rename-visited-file
   + [X] frame parameter: alpha-background (set-frame-parameter (selected-frame) 'alpha-background 0.90)
     + used now in my =set-transparency= function
   + var x-gtk-use-native-input
   + var: pixel-scroll-precision-mode - looks like a no-brainer
   + split-root-window-below, split-root-window-right
   + var: show-paren-context-when-offscreen
   + dabbrev-capf for use on completion-at-point functions
   + project-list-buffers =C-x p C-b=
   + var dired-omit-lines
   + New connection methods "docker", "podman" and "kubernetes".
     + I may retire my custom commands for same
   + var python-shell-dedicated
   + pkg vtable.el
   + pkg wallpaper
   + python-ts-mode, json-ts-mode, bash-ts-mode etc
   +
   #+begin_src emacs-lisp
     (setq show-paren-context-when-offscreen 'overlay)
   #+end_src
** Org-ros screen grabber into Org Mode
   [[https://www.reddit.com/r/orgmode/comments/10c0cmf/orgros_screenshot_utility_for_orgmode_and_its/][[org-ros] Screenshot utility for org-mode - and it's future. : orgmode â‰« www.reddit.com]]
** Org drill flashcards
   There was a time I used this a lot

   org-drill implements both spaced repetition and [[https://gitlab.com/phillord/org-drill#incremental-reading][incremental reading]].

   #+begin_src emacs-lisp :tangle no
     (use-package org-drill :straight t
       :config
       (setq org-drill-add-random-noise-to-intervals-p t
	     org-drill-adjust-intervals-for-early-and-late-repetitions-p t

       ))
   #+end_src
** Alternative to Org Drill: Org FC
   #+begin_src bash
     sudo apt-get -y install gawk
   #+end_src
   #+begin_src emacs-lisp
     ;; (straight-use-package 'hydra)
     (use-package hydra :straight t)
     (use-package org-fc :straight t
       :defer nil
       :load-path "~/projects/emacs/org-fc/"
       :custom (org-fc-directories '("~/projects/private-orgmode/"))
       :config
       (require 'org-fc-hydra)
       (require 'org-fc-keymap-hint)
       (global-set-key (kbd "C-c f") 'org-fc-hydra/body)
       (add-hook 'org-fc-after-flip-hook 'org-fold-show-subtree))
   #+end_src
** Mermaid diagramming
   + [[https://github.com/mermaid-js/mermaid-cli][Releases Â· mermaid-js/mermaid-cli â‰« github.com]]
   #+begin_src bash
     npm install -g @mermaid-js/mermaid-cli
   #+end_src
** GitHub-flavoured markdown
   A minor mode providing syntax highlighting and live preview!
   In my environment, activate =myspark= environment first, with for example =M-x pyvenv-workon=
   + Requires a python environment with =grip=
     #+begin_src bash
       pip install grip
     #+end_src
     #+begin_src emacs-lisp
       (use-package grip-mode :straight t :defer t)
     #+end_src
** sqls or sql-language-server with eglot for SQL interface
   [[https://www.reddit.com/r/emacs/comments/ijbvwv/eglot_sqls_sql_client/][(3) eglot + sqls = SQL client? : emacs â‰« www.reddit.com]]

   #+begin_src emacs-lisp
     ;; Emacs 29 has eglot as a built-in, so lose the use-package stuff
     (require 'eglot)
     (bind-key "C-c C-d" 'eglot-help-at-point eglot-mode-map)
     (bind-key "C-c C-r" 'eglot-code-actions  eglot-mode-map)

     ;; (setq eglot-sync-connect t)
     (add-to-list 'display-buffer-alist
                  '("\\*sqls\\*"
                    (display-buffer-reuse-window display-buffer-at-bottom)
                    (reusable-frames . visible)
                    (window-height . 0.3)))

     (defclass eglot-sqls (eglot-lsp-server) () :documentation "SQL's Language Server")
       (add-to-list 'eglot-server-programs '(sql-mode . (eglot-sqls "sqls")))
       (cl-defmethod eglot-execute-command
         ((server eglot-sqls) (command (eql executeQuery)) arguments)
         "For executeQuery."
         ;; (ignore-errors
         (let* ((beg (eglot--pos-to-lsp-position (if (use-region-p) (region-beginning) (point-min))))
                (end (eglot--pos-to-lsp-position (if (use-region-p) (region-end) (point-max))))
                (res (jsonrpc-request server :workspace/executeCommand
                                      `(:command ,(format "%s" command) :arguments ,arguments
                                                 :timeout 0.5 :range (:start ,beg :end ,end))))
                (buffer (generate-new-buffer "*sqls*")))
           (with-current-buffer buffer
             (eglot--apply-text-edits `[
                                        (:range
                                         (:start
                                          (:line 0 :character 0)
                                          :end
                                          (:line 0 :character 0))
                                         :newText ,res)
                                        ]
                                      )
             (org-mode))
           (pop-to-buffer buffer))
         )
       (cl-defmethod eglot-execute-command
         ((server eglot-sqls) (_cmd (eql switchDatabase)) arguments)
         "For switchDatabase."
         (let* ((res (jsonrpc-request server :workspace/executeCommand
                                      `(:command "showDatabases" :arguments ,arguments :timeout 0.5)))
                (menu-items (split-string res "\n"))
                (menu `("Eglot code actions:" ("dummy" ,@menu-items)))
                (db (if (listp last-nonmenu-event)
                        (x-popup-menu last-nonmenu-event menu)
                      (completing-read "[eglot] Pick an database: "
                                       menu-items nil t
                                       nil nil (car menu-items))
                      ))
                )
           (jsonrpc-request server :workspace/executeCommand
                            `(:command "switchDatabase" :arguments [,db] :timeout 0.5))
           ))



     ;; (use-package eglot :straight t
     ;;   :bind (:map eglot-mode-map
     ;;               ("C-c C-d" . eglot-help-at-point)
     ;;               ("C-c C-r" . eglot-code-actions))
     ;;   :config
     ;;   (setq eglot-sync-connect 1)

     ;;   (add-to-list 'display-buffer-alist
     ;;                '("\\*sqls\\*"
     ;;                  (display-buffer-reuse-window display-buffer-at-bottom)
     ;;                  (reusable-frames . visible)
     ;;                  (window-height . 0.3)))

     ;;   (defclass eglot-sqls (eglot-lsp-server) () :documentation "SQL's Language Server")
     ;;   (add-to-list 'eglot-server-programs '(sql-mode . (eglot-sqls "sqls")))
     ;;   (cl-defmethod eglot-execute-command
     ;;     ((server eglot-sqls) (command (eql executeQuery)) arguments)
     ;;     "For executeQuery."
     ;;     ;; (ignore-errors
     ;;     (let* ((beg (eglot--pos-to-lsp-position (if (use-region-p) (region-beginning) (point-min))))
     ;;            (end (eglot--pos-to-lsp-position (if (use-region-p) (region-end) (point-max))))
     ;;            (res (jsonrpc-request server :workspace/executeCommand
     ;;                                  `(:command ,(format "%s" command) :arguments ,arguments
     ;;                                             :timeout 0.5 :range (:start ,beg :end ,end))))
     ;;            (buffer (generate-new-buffer "*sqls*")))
     ;;       (with-current-buffer buffer
     ;;         (eglot--apply-text-edits `[
     ;;                                    (:range
     ;;                                     (:start
     ;;                                      (:line 0 :character 0)
     ;;                                      :end
     ;;                                      (:line 0 :character 0))
     ;;                                     :newText ,res)
     ;;                                    ]
     ;;                                  )
     ;;         (org-mode))
     ;;       (pop-to-buffer buffer))
     ;;     )
     ;;   (cl-defmethod eglot-execute-command
     ;;     ((server eglot-sqls) (_cmd (eql switchDatabase)) arguments)
     ;;     "For switchDatabase."
     ;;     (let* ((res (jsonrpc-request server :workspace/executeCommand
     ;;                                  `(:command "showDatabases" :arguments ,arguments :timeout 0.5)))
     ;;            (menu-items (split-string res "\n"))
     ;;            (menu `("Eglot code actions:" ("dummy" ,@menu-items)))
     ;;            (db (if (listp last-nonmenu-event)
     ;;                    (x-popup-menu last-nonmenu-event menu)
     ;;                  (completing-read "[eglot] Pick an database: "
     ;;                                   menu-items nil t
     ;;                                   nil nil (car menu-items))
     ;;                  ))
     ;;            )
     ;;       (jsonrpc-request server :workspace/executeCommand
     ;;                        `(:command "switchDatabase" :arguments [,db] :timeout 0.5))
     ;;       ))
   #+end_src
** OPENAI ChatGPT and DALL-E
*** package org-ai
   ref: [[https://github.com/rksm/org-ai][rksm/org-ai: ChatGPT and DALL-E in org-mode using the OpenAI APIs â‰« github.com]]
   #+begin_src emacs-lisp :tangle no
     (straight-use-package
      '(org-ai :type git :host github :repo "rksm/org-ai"
               :local-repo "org-ai"
               :files ("*.el" "README.md")))
   #+end_src

   #+begin_ai :temperature 1
   is emacs the greatest editor?

[AI]: As an AI language model, I cannot form an opinion on which editor is the greatest. It ultimately depends on personal preference and the specific needs of the user. Emacs is a popular editor among programmers due to its extensive customization options and powerful features. However, other editors such as Vim, Sublime Text, and Atom also have a loyal user base with their own unique strengths and weaknesses.

[ME]: What ingredients would you think would be in a cocktail named "The Zegroni"?

[AI]: As an AI language model, I can suggest cocktail ingredients commonly used in similar cocktail names for "The Zegroni" based on classic cocktail recipes:

- Gin: A traditional Negroni drink contains gin, which is a popular spirit used in classic cocktails.
- Campari: Campari is used in a classic Negroni drink, and its bitterness adds depth to the cocktail's flavor.
- Sweet Vermouth: Vermouth is a fortified wine used as a key ingredient in a Negroni drink. Sweet vermouth balances Campari's bitterness and adds a mellow flavor to the drink.
- Orange Peel: Adding a twist of orange peel garnish at the end will accentuate the citrus flavor present in gin and add an aromatic and flavorful finish to the drink.

So, The Zegroni cocktail might include gin, Campari, sweet vermouth, and an orange peel garnish. However, the cocktail's actual recipe would depend on the bartender's interpretation and personal preference.

[ME]:
   #+end_ai
*** package gptel

    + [X] TODO: add completing-read with marginalia for =gptel-directives= (named prompts)
    + [ ] TODO: indicate system prompt(s) and model(s) used in *gpt-mode* buffer
    + ref: [[https://github.com/karthink/gptel][karthink/gptel: A no-frills ChatGPT client for Emacs â‰« github.com]] This package
      has it all: auth-source, Org Mode buffers, Markdown mode or other-mode buffers if
      you prefer, named prompts for special occasions, a transient mode interface, model
      choice, temperature settings, streaming support, multiple APIs, multiple chat
      sessions, an active GitHub. A dedication to keeping everything in plain text
      (without metadata markup)

    Because I want to augment, tweak and contribute to this package, I tell
    =straight-use-package= to pull from my fork and my branch.

    #+begin_src emacs-lisp
      (straight-use-package
       '(gptel :type git :host github :repo "karthink/gptel"
               :fork (:host github :branch "gregoryg" :repo "gregoryg/gptel")))
      (setq gptel-default-mode 'org-mode
            gptel-use-curl nil
            gptel-model 'gpt-4)
      ;; defer nothing
      (require 'gptel)
      (require 'gptel-curl)
      (require 'gptel-transient)
    #+end_src

    And my supplementos

    #+begin_src emacs-lisp
      ;; pandoc -f gfm -t org|sed '/:PROPERTIES:/,/:END:/d'

      (defun gjg/gptel--convert-markdown->org (str)
        "Convert string STR from markdown to org markup using Pandoc.
      Remove the property drawers Pandoc insists on inserting for org output."
        ;; point will be at the last user position - assistant response will be after that to the end of the buffer (hopefully without the next user prompt)
        ;; So let's
        (interactive)
        (let* ((org-prefix (alist-get 'org-mode gptel-prompt-prefix-alist))
               (shift-indent (progn (string-match "^\\(\\*+\\)" org-prefix) (length (match-string 1 org-prefix))))
               (sentence-end "\\([.?!
      ]\\)"))
          ;; TODO: consider placing original complete response in the kill ring
          ;; (with-temp-buffer
          (with-current-buffer (get-buffer-create (make-temp-name "*gptel-convert-"))
            (insert str)
            (shell-command-on-region (point-min) (point-max)
                                     (format "pandoc -f gfm -t org --shift-heading-level-by=%d|sed '/:PROPERTIES:/,/:END:/d'" shift-indent)
                                     nil ;; use current buffer
                                     t   ;; replace the buffer contents
                                     "*gptel-convert-error*")
            (goto-char (point-min))
            (insert (format "%sAssistant: %s\n" (alist-get 'org-mode gptel-prompt-prefix-alist) (or (sentence-at-point t) "[resp]")))
            (goto-char (point-max))
            (buffer-string))))

      (defun gjg/gptel-convert-org-with-pandoc (content buffer)
        "Transform CONTENT acoording to required major-mode using `pandoc'.
      Currenly only `org-mode' is supported
      This depends on the `pandoc' binary only, not on the  Emacs Lisp `pandoc' package."
        (pcase (buffer-local-value 'major-mode buffer)
          ('org-mode (gjg/gptel--convert-markdown->org content))
          (_ content)))

      (custom-set-variables '(gptel-response-filter-functions
                              '(gjg/gptel-convert-org-with-pandoc)))
      (defun gjg/gptel--annotate-directives (s)
        "Make the directives selection look fancy."
        (let* ((item (assoc (intern s) minibuffer-completion-table))
               (desc (s-truncate 40 (nth 1 item)))
               (prompt (s-truncate 80 (s-replace "\n" "\\n" (nth 2 item)))))
          (when item (concat
                      (string-pad "" (- 40 (string-width s)))
                      desc
                      (string-pad "" (- 55 (string-width desc)))
                      prompt
                      ))))

      (defun gjg/gptel-select-system-prompt (&optional directive-key)
        "Set system message in local gptel buffer to directive/prompt indicated by DIRECTIVE-KEY."
        (interactive)
        (let* ((marginalia-align-offset 80)
               (completion-extra-properties '(:annotation-function gjg/gptel--annotate-directives))
               (directive-key (or directive-key
                                  (intern
                                   (completing-read
                                    ;; "New directive: "
                                    (format "Current prompt %s: "
                                            (truncate-string-to-width gptel--system-message 90 nil nil (truncate-string-ellipsis) ))
                                    gptel-directives
                                    nil ;; predicate/filter
                                    nil ;; do not require a match - allow custom prompt
                                    nil ;; no initial input
                                    nil ;; no history specified
                                    "default" ;; default value if return is nil
                                    )))))
          (setq-local gptel--system-message (nth 2 (assoc directive-key gptel-directives)))))

      (defun gjg/insert-clean-website-text (url)
        "Run a shell command to return clean body text from the given URL."
        (interactive)
        (if (executable-find "text-from-url.py")
            (insert (shell-command-to-string (concat "text-from-url.py " url)))
          (message "Command not found: text-from-url.py")
            )
        )




      ;; debug gptel--transform-response
      ;; What are popular genres of acoustic string music, output as topics and subtopics in markdown?
    #+end_src

** Deft
   #+begin_src emacs-lisp :tangle no
     (use-package deft :straight t
       :bind ("<f8>" . deft)
       :config
       (setq
        deft-extensions '("org" "md" "txt")
        deft-directory "~/gregj-notes/"
        deft-recursive t))
   #+end_src
** REST API helper
   #+begin_src emacs-lisp
     (use-package request :straight t :ensure t)
   #+end_src

   Sample usage
   #+begin_src emacs-lisp
   #+end_src
** Reading list stuff
   #+begin_src emacs-lisp
     (use-package org-books :straight t)
     (push
      '("v" "Video+Book reading list" entry
        (file+headline "~/projects/private-orgmode/reading-list.org" "Books")
        "* %^{title}\n  %^{author}p%^{format|kindle}p\n  %?"
        :prepend nil :jump-to-captured t)
      org-capture-templates)
   #+end_src
* Final steps
#+begin_src emacs-lisp
(shell (get-buffer-create "sh1"))
#+end_src
